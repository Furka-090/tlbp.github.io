<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>7. Örneklere Dönüş</title>
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)"/>
    <link rel="prev" href="ruby-ug-arrays.html" title="6. Diziler"/>
    <link rel="next" href="ruby-ug-control.html" title="8. Denetim Yapıları"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="/style/belgeler.css"/>
    <link rel="stylesheet" type="text/css" href="/style/nav.css"/>
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('ruby-ug-arrays.html')">Önceki</button>
          <div class="dropdown-content">6. Diziler</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('ruby-ug.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('ruby-ug-control.html')">Sonraki</button>
          <div class="dropdown-content">8. Denetim Yapıları</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="chapter" id="ruby-ug-b2examples">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title">7. Örneklere Dönüş</h1>
            </div>
          </div>
        </div>
        <div class="toc">
          <div class="toc-title">İçindekiler</div>
          <dl class="toc">
            <dt>7.1. <a href="ruby-ug-b2examples.html#ruby-ug-factorials">Faktöriyeller</a></dt>
            <dt>7.2. <a href="ruby-ug-b2examples.html">Dizgeler</a></dt>
            <dt>7.3. <a href="ruby-ug-b2examples.html">Düzenli İfadeler</a></dt>
          </dl>
        </div>
        <p>
   Şimdi eski örneklere tekrar göz atalım.
  </p>
        <p>
   Aşağıdakini daha önce  <a class="xref" href="ruby-ug-examples.html" title="3. Basit Örnekler"><em>Basit Örnekler</em></a> kısmında görmüştük.
  </p>
        <pre class="screen">
def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
print fact(ARGV[0].to_i), "\n"
</pre>
        <p>
   Bu bizim ilk örneğimiz olduğu için her satırı teker teker açıklayalım.
  </p>
        <section class="sect1" id="ruby-ug-factorials">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">7.1. Faktöriyeller</h2>
              </div>
            </div>
          </div>
          <pre class="screen">def fact(n)</pre>
          <p>
    İlk satırda bir işlev (ya da daha özel olarak bir <em class="wordasword">yöntem</em>; yöntemin ne olduğunu ileriki kısımlarda göreceğiz) tanımlamak için <span class="command"><strong>def</strong></span> deyimini kullanıyoruz. Burada işlevimiz <code class="function">fact</code>'ın <code class="literal">n</code> adında tek bir bağımsız değişken aldığını görüyoruz.
   </p>
          <pre class="screen">if n == 0</pre>
          <p>
    <span class="command"><strong>if</strong></span> bir denetim deyimidir. Eğer koşul sağlanıyorsa onu takip eden kod değerlendirilir, aksi taktide <span class="command"><strong>else</strong></span> kısmına geçilir.
   </p>
          <pre class="screen">1</pre>
          <p>
    Eğer koşul sağlandıysa <span class="command"><strong>if</strong></span>'in değeri 1 olacaktr.
   </p>
          <pre class="screen">else</pre>
          <p>
    Sağlanmadıysa, bu deyimle başlayan <span class="command"><strong>end</strong></span> ile biten kod parçası değerlendirilir.
   </p>
          <pre class="screen">n * fact(n-1)</pre>
          <p>
    Yani, eğer koşul sağlanmamışsa sonuç <span class="command"><strong>n</strong></span> kere <span class="command"><strong>fact(n-1)</strong></span> olacaktır.
   </p>
          <pre class="screen">end</pre>
          <p>
    İlk <span class="command"><strong>end</strong></span>, <span class="command"><strong>if</strong></span> deyimini kapatmak için kullanılır.
   </p>
          <pre class="screen">end</pre>
          <p>
    İkinci <span class="command"><strong>end</strong></span> <span class="command"><strong>def</strong></span> ifadesini kapatmak için kullanılır.
   </p>
          <pre class="screen">print fact(ARGV[0].to_i), "\n"</pre>
          <p>
    Bu bizim komut satırından <code class="function">fact()</code> işlevini çalıştırmamızı ve sonuçları ekranda görmemizi sağlar.
   </p>
          <p>
    <span class="command"><strong>ARGV</strong></span> komut satırı girdilerini içeren özel bir dizidir. <span class="command"><strong>ARGV</strong></span> dizisinin tüm elemanları dizgeler olduğu için, <span class="command"><strong>to_i</strong></span> yöntemiyle tamsayıya dönüştürmek zorundayız. Ruby Perl'deki gibi dizgeleri tamsayılara kendiliğinden dönüştürmez.
   </p>
          <p>
    Hmmm... Eğer bu yazılıma negatif bir sayı girersek ne olur? Sorunu görebildiniz mi? Peki düzeltebilir misiniz?
   </p>
        </section>
        <section class="sect1">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">7.2. Dizgeler</h2>
              </div>
            </div>
          </div>
          <p>
    <a class="xref" href="ruby-ug-strings.html" title="4. Dizgeler"><em>Dizgeler</em></a> bölümündeki bulmaca örneğimizi tekrar inceleyelim. Bu sefer biraz daha uzun, kolaylık açısından satırları numaralandırdık.
   </p>
          <pre class="screen">
1   words = ['kestane', 'gurgen', 'palamut']
2   secret = words[rand(3)]
3
4   print "tahmin et? "
5   while guess = STDIN.gets
6     guess.chop!
7     if guess == secret
8       print "Bildin!\n"
9       break
10    else
11      puts "Üzgünüm kaybettin.\n"
12    end
13    print "tahmin et? "
14  end
15  puts "Kelime ", secret, ".\n"
</pre>
          <p>
    Bu yazılımda yeni bir denetim yapısı gördük: <span class="command"><strong>while</strong></span>.
    Verilen koşul doğru olduğu sürece <span class="command"><strong>while</strong></span> ve <span class="command"><strong>end</strong></span> arasındaki kod tekrar tekrar çalıştırılacaktır.
   </p>
          <p>
    2. satırdaki <code class="function">rand(3)</code> işlevi 0 ile 2 arasında rastgele sayı üretir. Bu rastgele sayı <code class="literal">words</code> dizisinin elemanlarından birini çıkarmak için kullanılır.
   </p>
          <p>
    5. satırda <code class="function">STDIN.gets</code> yöntemiyle standart girdiden bir satır okuduk. Eğer satırı alırken <code class="literal">EOF</code> (end of file) karakterine rastlanırsa <code class="function">gets</code> işlevi <span class="command"><strong>nil</strong></span> değerini döndürecektir. <span class="command"><strong>while</strong></span> ile ilişkilendirilmiş kod <code class="literal">^D</code> (ya da DOS altında ^Z) görene kadar tekrarlanacaktır.
   </p>
          <p>
    6. satırdaki <code class="function">guess.chop!</code> işlevi <code class="literal">guess</code> değişkeninin sonundaki satırsonu karakterini temizlemeye yarar.
   </p>
          <p>
    15. satırda gizli kelimeyi yazdırıyoruz. Bunu üç bağımsız değişken ile birlikte bir yazdırma deyimi olarak kullandık (birbiri ardına yazdırılarak) ancak bunu daha verimli hale getirmek için <code class="function">secret</code> yerine bir tek bağımsız değişken alan <code class="function">#(secret)</code> yöntemini tanımlayabilirdik:
   </p>
          <pre class="screen">puts "Kelime #{secret}.\n"   </pre>
          <p>
    Birçok yazılımcı, bu yolun çıktı vermek için daha açık olduğunu düşünürler. Tek bir dizge oluşturur ve bu dizgeyi <span class="command"><strong>puts</strong></span>'a tek bir bağımsız değişken gibi sunar.
   </p>
          <p>
    Standart betik çıktısında <span class="command"><strong>puts</strong></span> kullanma düşüncesini işledik, ancak bu betik 4. ve 13. satırlarda <span class="command"><strong>print</strong></span>'i de kullanır. Bu ikisi aynı şey değildir. <span class="command"><strong>print</strong></span> dizgeyi kendisine verildiği gibi çıktılarken, <span class="command"><strong>puts</strong></span>; aynı zamanda çıktı satırının sonlanmasını sağlar. 4. ve 13. satırlarda <span class="command"><strong>print</strong></span> kullanıldığı için, işleç bir sonraki satırın başlangıcına geçeceği yerde, işleci ekrana çıktılanan dizgenin yanında bırakır. Bu durum kullanıcı girdisi için tanınabilir bir durumdur. Aşağıdaki dört çıktı çağrısı da aynı sonucu verir:
   </p>
          <pre class="screen">
#satırsonu karakteri yoksa, puts tarafından eklenir:
puts  "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir."

#satırsonu karakteri print komutuna verilmelidir:
print "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.\n"

#çıktıyı + ile birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.'+"\n"

# ya da birden fazla dizge vererek birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.', "\n"
</pre>
        </section>
        <section class="sect1">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">7.3. Düzenli İfadeler</h2>
              </div>
            </div>
          </div>
          <p>
    Son olarak <a class="xref" href="ruby-ug-regex.html" title="5. Düzenli İfadeler"><em>Düzenli İfadeler</em></a> bölümündeki yazılımı inceleyeceğiz.
   </p>
          <pre class="screen">
1   st = "\033[7m"
2   en = "\033[m"
3
4   while TRUE
5     print "str&gt; "
6     STDOUT.flush
7     str = gets
8     break if not str
9     str.chop!
12    print "pat&gt; "
13    STDOUT.flush
14    re = gets
15    break if not re
16    re.chop!
17    str.gsub! re, "#{st}\\&amp;#{en}"
18    print str, "\n"
19  end
20  print "\n"
</pre>
          <p>
    4. satırda <span class="command"><strong>while</strong></span>'ın koşulu sonsuz döngüyü sağlamak için <span class="command"><strong>true</strong></span> yapılmıştır. Ancak döngüden çıkabilmek için 8. ve 13. satırlarda <span class="command"><strong>break</strong></span> kullandık. Bu iki <span class="command"><strong>break</strong></span> aynı zamanda <span class="command"><strong>if</strong></span> deyiminin niteleyicilerinden biridir. Bir <em class="emphasis">if niteleyicisi</em> sadece ve sadece koşul sağlandığı zaman sol yandaki terimini çalıştırır.
   </p>
          <p>
    <code class="function">chop!</code> için (9. ve 14 satıra bakın) hakkında söylenecek çok şey var. Ruby'de geleneksel olarak yöntem isimlerinin sonuna '<span class="command"><strong>!</strong></span>' ya da '<span class="command"><strong>?</strong></span>' ekleriz. Ünlem işareti (<span class="command"><strong>!</strong></span> bazen "bang!" diye söylenir) potansiyel olarak yıkıcı bir görev görür, daha da açmak gerekirse; dokunduğu değeri değiştiren bir işleçtir. <code class="function">chop!</code> bir dizgeye doğrudan etki eder ancak ünlem işareti olmayan bir <code class="function">chop</code> bir kopya üzerinde çalışır. Aşağıda ikisi arasındaki fark görülüyor:
   </p>
          <pre class="screen eval">
ruby&gt; <em class="emphasis evalinput">s1 = "forth"</em>
   <em class="emphasis evaloutput">"forth"</em>
ruby&gt; <em class="emphasis evalinput">s1.chop!</em>       # Bu s1'in değerini değiştirir.
   <em class="emphasis evaloutput">"fort"</em>
ruby&gt; <em class="emphasis evalinput">s2 = s1.chop</em>   # s2'ye değiştirilmiş bir kopyasını koyar.
   <em class="emphasis evaloutput">"for"</em>
ruby&gt; <em class="emphasis evalinput">s1</em>             # ... s1'e dokunmaz.
   <em class="emphasis evaloutput">"fort"</em>
</pre>
          <p>
    İlerde sonunda soru işareti olan yöntem isimleriyle karşılaşacaksınız (<span class="command"><strong>?</strong></span> genelde "huh?" şeklinde telaffuz edilir). Bu <span class="command"><strong>true</strong></span> ya da <span class="command"><strong>false</strong></span> döndüren bir 'doğrulama' yöntemidir.
   </p>
          <p>
    15. satırda dikkat edilmesi gereken önemli bir uyarı yer almaktadır. Öncelikle <code class="function">gsub!</code>'in başka bir sözde 'yıkıcı' yöntem olduğuna dikkat edelim. <code class="literal">re</code>'ye uyan her ne varsa <code class="literal">str</code>'nin yerine koyar (<span class="command"><strong>sub</strong></span> ikame etmekten (substitute), <span class="command"><strong>g</strong></span> ise globalden gelir);  sadece ilk bulunanı değil, dizgedeki <code class="literal">tüm</code> eşleşen kısımları değiştirir. Çok iyi, çok güzel; fakat eşleştirilen kısımları neyle değiştireceğiz? 1. ve 2 satırda önalan ve artalan renklerini peşpeşe değiştiren <code class="literal">st</code> ve <code class="literal">en</code> adlı iki dizge tanımladık.  15. satırdaysa bunları, olduğu gibi yorumlandıklarından emin olmak için <span class="command"><strong>#{}</strong></span> arasına yazdık (<em class="emphasis">değişken isimlerinin yazdırıldığını görmeyiz</em>).  Bunların arasında da "<span class="command"><strong>\\&amp;</strong></span>" kodunu görüyoruz. Bu küçük bir hiledir. Yer değiştirilen dizge çift tırnak arasında olduğu için  bir çift ters bölü işareti tek bir taneymiş gibi yorumlanır. Böylece <code class="function">gsub!</code>'in göreceği şey "<span class="command"><strong>\&amp;</strong></span>" olur ve  bu da ilk konumda ne eşleştirildiyse onu gösteren özel bir koda dönüştürülür. Yani yeni dizge eşleşen parçaları farklı renkte gösterilen eski dizge olur.
   </p>
        </section>
      </section>
    </section>
    <footer/>
  </body>
</html>
