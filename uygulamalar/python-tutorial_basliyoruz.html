<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>3. Python'a Giriş</title>
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)"/>
    <link rel="prev" href="python-tutorial_yorumlayici.html" title="2. Yorumlayıcının Kullanımı"/>
    <link rel="next" href="python-tutorial_akis-denetimi.html" title="4. Akış Denetimi"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="/style/belgeler.css"/>
    <link rel="stylesheet" type="text/css" href="/style/nav.css"/>
    <link rel="icon" type="image/png" href="/images/belgeler-logo.png"/>
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial_yorumlayici.html')">Önceki</button>
          <div class="dropdown-content">2. Yorumlayıcının Kullanımı</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial_akis-denetimi.html')">Sonraki</button>
          <div class="dropdown-content">4. Akış Denetimi</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="chapter" id="python-tutorial_basliyoruz">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title">3. Python'a Giriş</h1>
            </div>
          </div>
        </div>
        <div class="toc">
          <div class="toc-title">İçindekiler</div>
          <dl class="toc">
            <dt>3.1. <a href="python-tutorial_basliyoruz.html#python-tutorial_calc">Python'u Hesap Makinesi Olarak Kullanmak</a></dt>
            <dd>
              <dl>
                <dt>3.1.1. <a href="python-tutorial_basliyoruz.html">Sayılar</a></dt>
                <dt>3.1.2. <a href="python-tutorial_basliyoruz.html">Dizgeler</a></dt>
                <dt>3.1.3. <a href="python-tutorial_basliyoruz.html">Listeler</a></dt>
              </dl>
            </dd>
            <dt>3.2. <a href="python-tutorial_basliyoruz.html#python-tutorial_ilkler">Programlamaya Doğru İlk Adımlar</a></dt>
          </dl>
        </div>
        <p>
   Aşağıdaki örneklerde giriş ve çıkış, komut satırının varlığına veya
   yokluğuna (<code class="literal">&gt;&gt;&gt; </code> veya <code class="literal">... </code>)
   bağlıdır. Örnekleri tekrar etmek için komut satırında görünen her şeyi
   yazmalısınız. <code class="literal">&gt;&gt;&gt; </code> veya <code class="literal">... </code>
   ile başlamayan bütün satırlar yorumlayıcı çıktısını temsil eder.
   İkincil komut satırındaki boş bir satır (sadece "... ")) olan yerlerde
   bir şey yazmanıza gerek yok. O satırlar boş olup bir deyimler öbeğinin
   bitirilmesi için kullanılır. Bu kılavuzdaki alıştırmaların çoğu,
   etkileşimli komut satırına yazılanlar dahil, açıklamalar içerir.
   Python dilinde açıklamalar "#" ile başlarlar ve bulundukları satır
   sonuna kadar devam eder. Bir dizge içinde bulunan "#"
   işareti bir açıklama başlatmaz. Bu sadece bir "#" karakteridir. Örnekler:
  </p>
        <pre class="screen">
# Bu bir açıklama.
SAYI = 1 # ve bu ikinci açıklama
# ... bu da üçüncü!
DIZGE = "# Bu bir açıklama değil."
</pre>
        <section class="sect1" id="python-tutorial_calc">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">3.1. Python'u Hesap Makinesi Olarak Kullanmak</h2>
              </div>
            </div>
          </div>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">3.1.1. Sayılar</h3>
                </div>
              </div>
            </div>
            <p>
     Şimdi bazı basit komutlar deneyelim. Yorumlayıcıyı çalıştırın ve birincil
     komut satırının gelmesini bekleyin.
    </p>
            <p>
     Yorumlayıcı basit bir hesap makinesi olarak iş görürebilir: istediğiniz
     herhangi bir ifadeyi yazın ve yorumlayıcı sonucu verecektir. İşleçler
     ( +,-,*,/ ) çoğu yazılımlama dillerindekine benzer çalışır (Pascal ve
     C de olduğu gibi mesela). İfadeleri gruplamak için parantezler de
     kullanılabilir. Örnekler:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> 2+2
4
<code class="prompt">&gt;&gt;&gt;</code> # Bu bir açıklama
<code class="prompt">...</code> 2+2
4
<code class="prompt">&gt;&gt;&gt;</code> 2+2 # bu da komutlarla aynı satırda bir açıklama
4
<code class="prompt">&gt;&gt;&gt;</code> (50-5*6)/4
5
<code class="prompt">&gt;&gt;&gt;</code> # Tam sayı bölme işlemlerinde ise:
<code class="prompt">...</code> 7/3
2
<code class="prompt">&gt;&gt;&gt;</code> 7/-3
-3
</pre>
            <p>
     C'de olduğu gibi eşit işareti ( <code class="literal">=</code> ) bir değişkene
     değer atamak için kullanılır. Atamanın değeri çıkışta yazılmaz:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> genislik = 20
<code class="prompt">&gt;&gt;&gt;</code> yukseklik = 5*9
<code class="prompt">&gt;&gt;&gt;</code> genislik * yukseklik
900
</pre>
            <p>
     Bir değer aynı anda birden fazla değişkene atanabilir:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> x = y = z = 5 # x, y ve z beş değerini alır
<code class="prompt">&gt;&gt;&gt;</code> x
5
<code class="prompt">&gt;&gt;&gt;</code> y
5
<code class="prompt">&gt;&gt;&gt;</code> z
5
</pre>
            <p>
     Tam gerçel sayı desteği vardır. Farklı türdeki değerlerin olduğu
     işlemlerde sonuç gerçel sayıya dönüştürülür:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> 3 * 3.75 / 1.5
7.5
<code class="prompt">&gt;&gt;&gt;</code> 7.0 / 2
3.5
</pre>
            <p>
     Karmaşık sayılar da desteklenmektedir. Sayıların sanal kısımları
     <code class="literal">j</code> veya <code class="literal">J</code> soneki ile yazılır.
     Gerçek kısmı sıfır olmayan karmaşık sayılar <code class="literal">(gerçek +
     sanalj)</code> şeklinde yazılırlar ya da
     <code class="literal">complex(gerçek, sanal)</code> işlevi ile kullanılır.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> 1j * 1J
(-1+0j)
<code class="prompt">&gt;&gt;&gt;</code> 1j * complex(0,1)
(-1+0j)
<code class="prompt">&gt;&gt;&gt;</code> 3+1j*3
(3+3j)
<code class="prompt">&gt;&gt;&gt;</code> (3+1j)*3
(9+3j)
<code class="prompt">&gt;&gt;&gt;</code> (1+2j)/(1+1j)
(1.5+0.5j)
</pre>
            <p>
     Karmaşık sayılar daima iki gerçel sayı ile ifade edilirler; biri
     gerçek diğer sanal kısım için. <code class="literal">Z</code> gibi bir karmaşık
     sayının gerçek ya da sanal kısımlarına erişmek için
     <code class="literal">Z.real</code> ve <code class="literal">Z.imag</code> kullanılır.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a=1.5+0.5j
<code class="prompt">&gt;&gt;&gt;</code> a.real
1.5
<code class="prompt">&gt;&gt;&gt;</code> a.imag
0.5
</pre>
            <p>
     Tamsayı veya gerçel sayıya dönüştürme işlevleri (<code class="literal">float()</code>, <code class="literal">int()</code> ve <code class="literal">long()</code>) karmaşık sayılar için çalışmazlar; bir karmaşık sayıyı gerçek bir sayıya dönüştürmenin doğru bir yolu mevcut değildir. <code class="literal">abs(z)</code> ile karmaşık sayının büyüklüğünü ve <code class="literal">z.real</code> ile gerçek kısmını elde edebilirsiniz.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a=3.0+4.0j
<code class="prompt">&gt;&gt;&gt;</code> float(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: can't convert complex to float; use e.g. abs(z)
<code class="prompt">&gt;&gt;&gt;</code> a.real
3.0
<code class="prompt">&gt;&gt;&gt;</code> a.imag
4.0
<code class="prompt">&gt;&gt;&gt;</code> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
<code class="prompt">&gt;&gt;&gt;</code>
</pre>
            <p>
     Etkileşimli kipte son yazdırılan değer <code class="literal">_</code> değişkenine
     atanır. Yani Python'u hesap makinesi olarak kullanırken bazen işlemlere
     şu şekilde devam etmek daha kolaydır:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> vergi= 17.5 / 100
<code class="prompt">&gt;&gt;&gt;</code> fiyat= 3.50
<code class="prompt">&gt;&gt;&gt;</code> fiyat * vergi
0.61249999999999993
<code class="prompt">&gt;&gt;&gt;</code> fiyat + _
4.1124999999999998
<code class="prompt">&gt;&gt;&gt;</code> round(_, 2)
4.1100000000000003
<code class="prompt">&gt;&gt;&gt;</code>
</pre>
            <p>
     Bu değişken ( <code class="literal">_</code> ) kullanıcı tarafından salt okunur
     olarak kabul edilmelidir. Buna kasıtlı olarak değer atamayın. Bu aynı
     isimli bir yerel değişken yaratır.
    </p>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">3.1.2. Dizgeler</h3>
                </div>
              </div>
            </div>
            <p>
     Sayılara ek olarak, Python dizgeler üzerinde de işlemler yapabilir.
     Dizgeler farklı şekillerde ifade edilebilir. Tek veya çift tırnak
     işareti içine alınabilirler:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> 'dizge'
'dizge'
<code class="prompt">&gt;&gt;&gt;</code> "Python\'un gücü"
"Python'un gücü"
<code class="prompt">&gt;&gt;&gt;</code> "doesn't"
"doesn't"
<code class="prompt">&gt;&gt;&gt;</code> '"Yes," he said.'
'"Yes," he said.'
<code class="prompt">&gt;&gt;&gt;</code> "\"Yes,\" he said."
'"Yes," he said.'
<code class="prompt">&gt;&gt;&gt;</code> '"Isn\'t," she said.'
'"Isn\'t," she said.'
</pre>
            <p>
     Dizgeler birkaç şekilde birden fazla satıra yayılabilir. Yeni
     satırlar ters eğik çizgi ile şöyle gösterilebilirler:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> merhaba = "Bu C de de kullandığınıza benzer\n\
<code class="prompt">...</code> birkaç satır kaplayan bir dizge.\n\
<code class="prompt">...</code>     Bu satırın başındaki \
<code class="prompt">...</code> girintinin belirgin olduğuna \
<code class="prompt">...</code> dikkat edin\n"
<code class="prompt">&gt;&gt;&gt;</code> print merhaba
</pre>
            <p>ve bu şu çıktıyı verir:</p>
            <pre class="screen">
Bu C de de kullandığınıza benzer
birkaç satır kaplayan bir dizge.
        Bu satırın başındaki girintinin belirgin olduğuna dikkat edin

<code class="prompt">&gt;&gt;&gt;</code>
</pre>
            <p>
     Karakter dizisini <code class="literal">r</code> ile imleyerek <em class="emphasis">ham
     dizge</em> yapacak olursak, <code class="literal">\n\</code> karakterleri
     yorumlanmaz, dizgenin bir parçası haline gelir. Örneğin:
    </p>
            <pre class="screen">
merhaba = r"Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi."

print merhaba
</pre>
            <p>şu çıktıyı verir:</p>
            <pre class="screen">
Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi.
</pre>
            <p>
     Karakter dizileri bir çift üçlü tırnak içinde de gösterilebilirler:
     Dizgeler bir çift üçlü tırnak içinde de gösterilebilirler:
     <code class="literal">"""</code> veya <code class="literal">'''</code>. Bu
     gösterim şeklinde satır sonlarının <code class="literal">\n</code>
     ile gösterilmesine gerek yoktur ve onlar olmadan da yeni
     satırlar doğru şekilde görünür. Örnek:
    </p>
            <pre class="screen">
print """
Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
"""
</pre>
            <p>ifadesi şu çıktıyı verir:</p>
            <pre class="screen">Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
</pre>
            <p>
     Yorumlayıcı dizge işlemlerinin sonucunu girişine yazıldığı şekli
     ile çıkışa yazar. Dizgeler <code class="literal">+</code> işleçi
     ile birleştirilip, <code class="literal">*</code> ile tekrarlanabilir:
    </p>
            <pre class="screen">
kelime = 'Alo' + 'ooo'
<code class="prompt">&gt;&gt;&gt;</code> kelime
'Aloooo'
<code class="prompt">&gt;&gt;&gt;</code> '&lt;' + kelime*5 + '&gt;'
'&lt;AlooooAlooooAlooooAlooooAloooo&gt;'
</pre>
            <p>
     Yan yana iki dizge değişkeni otomatik olarak birleştirilir yani
     yukarıdaki örnekteki ilk satır <code class="literal">kelime = 'Alo' 'ooo'</code>
     şeklinde de yazılabilirdi. Bu sadece iki dizge değişkeni ile olur.
     Keyfî dizgeler arasında olamaz:
    </p>
            <pre class="screen">
import string
<code class="prompt">&gt;&gt;&gt;</code> 'str' 'ing' # &lt;- Bu doğru
'string'
<code class="prompt">&gt;&gt;&gt;</code> string.strip('str') + 'ing' # &lt;- Bu da doğru
'string'
<code class="prompt">&gt;&gt;&gt;</code> string.strip('str') 'ing' # &lt;- Bu geçersız !!!
File "&lt;stdin&gt;", line 1, in ?
string.strip('str') 'ing'
                        ^
SyntaxError: invalid syntax
</pre>
            <p>
     C'de olduğu gibi, Python'da da dizgeler indislenebilir.
     Dizgenin ilk karakterinin indisi sıfırdır. Python'da ayrı bir karakter
     veri türü yoktur. Bir karakter tek karakterli bir dizgedir. Icon
     dilinde (70'li yıllarda Ralph ve Marge Griswold'ün geliştirdiği Pascal
     benzeri bir SNOBOL4 türevi) olduğu gibi dizgelerin bölümleri
     dilim gösterimi <code class="literal">[ : ]</code> ile ifade edilebilir.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[4]
'o'
<code class="prompt">&gt;&gt;&gt;</code> kelime[0:2]
'Al'
<code class="prompt">&gt;&gt;&gt;</code> kelime[2:4]
'oo'
</pre>
            <p>
     C dilinden farklı olarak, Python'da dizgeler değiştirilemez.
     Bir dizgenin indislenen bir konumuna değer atamaya çalışmak hatadır:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[0] = 'x'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support item assignment
<code class="prompt">&gt;&gt;&gt;</code> kelime[:1] = 'Splat'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support slice assignment
</pre>
            <p>
     Yukarıdaki soruna elde edilmek istenen dizge için yeni bir karakter
     dizisi oluşturularak çözüm bulunabilir. Bu kolay ve etkilidir:
    </p>
            <pre class="screen">
'x' + kelime[1:]
'xloooo'
<code class="prompt">&gt;&gt;&gt;</code> 'Splat' + kelime[4]
'Splato'
</pre>
            <p>
     Dilimlerin varsayılan başlangıç ve bitiş değerleri oldukça kullanışlıdır.
     Başlangıç değeri yoksa sıfır kabul edilir ve eğer bitiş değeri yoksa
     dilimlenen dizgenin boyu kadar olduğu kabul edilir. Örnekler:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[:2] # İlk iki karakter
'Al'
<code class="prompt">&gt;&gt;&gt;</code> kelime[2:] # İlk iki karakter dışındaki karakterler
'oooo'
</pre>
            <p>
     <code class="literal">s[:i] + s[i:] = s</code> olup dilimleme işlemlerinin
     kullanışlı bir şeklidir. Örnek:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[:2] + kelime[2:]
'Aloooo'
<code class="prompt">&gt;&gt;&gt;</code> kelime[:3] + kelime[3:]
'Aloooo'
</pre>
            <p>
     Çok büyük veya küçük dilim aralıkları akıllıca ele alınır. Bitiş değeri
     büyük ise bunun boyu dizgenin boyuna eşit olur. Başlangıç
     değeri bitişten büyük ise boş bir dizge elde edilir.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[1:100]
'loooo'
<code class="prompt">&gt;&gt;&gt;</code> kelime[10:]
''
<code class="prompt">&gt;&gt;&gt;</code> kelime[2:1]
''
</pre>
            <p>
     İndisler negatif sayılar da olabilir. Bu durumda saymaya sağ
     taraftan başlanır.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[-1] # Son karakter
'o'
<code class="prompt">&gt;&gt;&gt;</code> kelime[-2] # Sondan ikinci
'o'
<code class="prompt">&gt;&gt;&gt;</code> kelime[-2:] # Son iki karakter
'oo'
<code class="prompt">&gt;&gt;&gt;</code> kelime[:-2] # Son iki karakter dışındaki karakterler
'Aloo'
</pre>
            <p>
     -0 ın 0 ile aynı olduğuna dikkat edin; yani yine soldan sayar!
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[-0] # (-0 = 0 olduğundan)
'A'
</pre>
            <p>
     Sınır dışındaki negatif dilim indisleri küçültülürler; fakat bunu
     dilim olmayan tek bir indis ile denemeyin:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> kelime[-100:]
'Aloooo'
<code class="prompt">&gt;&gt;&gt;</code>; kelime[-10] # hata !
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1
IndexError: string index out of range
</pre>
            <p>
     Dilimlerin nasıl çalıştığını hatırlamanın en iyi yolu indislerin
     karakterler arasını işaret ettiğini düşünmektir; şu şekilde bu daha
     iyi görülebilir:
    </p>
            <pre class="screen">
 +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1
</pre>
            <p>
     Negatif olmayan indisler için dilim boyu indisler arası fark kadardır.
     Örneğin kelime[1:3] diliminin boyu 2 dir.
    </p>
            <p>
     Yerleşik işlev <code class="literal">len()</code> bir dizgenin boyunu verir.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> s = 'ArrestedDevelopmentZingalamaduni'
<code class="prompt">&gt;&gt;&gt;</code> len(s)
32
</pre>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">3.1.3. Listeler</h3>
                </div>
              </div>
            </div>
            <p>
     Python'da diğer veri türlerini bir gruba almayı sağlayan birkaç bileşik veri
     türü vardır. Bunların en kullanışlı olanlarından biri listelerdir. Listeler
     kare parantez içinde virgül ile birbirinden ayrılmış değerlerden (eleman)
     oluşur. Liste elemanlarının aynı türden olması gerekmez.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a = ['salam', 'zeytin', 100, 1234]
<code class="prompt">&gt;&gt;&gt;</code> a
['salam', 'zeytin', 100, 1234]
</pre>
            <p>
     Listeler de dizgeler gibi indislenebilir. İndisler sıfırdan başlar.
     Listeler dilimlenebilir, birleştirilebilir vs...
    </p>
            <pre class="screen"><code class="prompt">&gt;&gt;&gt;</code> a[0]
'salam'
<code class="prompt">&gt;&gt;&gt;</code> a[3]
1234
<code class="prompt">&gt;&gt;&gt;</code> a[-2]
100
<code class="prompt">&gt;&gt;&gt;</code> a[1:-1]
['zeytin',100]
<code class="prompt">&gt;&gt;&gt;</code> a[:2] + ['yumurta', 2*2]
['salam','zeytin', 'yumurta', 4]
<code class="prompt">&gt;&gt;&gt;</code> 3*a[:3] + ['Oley!']
['salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'Oley!']
</pre>
            <p>
     Değiştirilemez (mutable) olan dizgelerin aksine, listelerin her bir
     elemanı değiştirilebilir:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a
['salam', 'zeytin', 100, 1234]
<code class="prompt">&gt;&gt;&gt;</code> a[2] = a[2] + 23
<code class="prompt">&gt;&gt;&gt;</code> a
['salam', 'zeytin', 123, 1234]
</pre>
            <p>
     Liste dilimlerine de atama yapılabilir ve bu listenin boyunu da
     değiştirilebilir.
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code>
# Bazı elemanları değiştir:
<code class="prompt">...</code> a[0:2] = [1, 12]
<code class="prompt">&gt;&gt;&gt;</code> a
[1, 12, 123, 1234]
<code class="prompt">&gt;&gt;&gt;</code> # Bazı elemanları sil:
<code class="prompt">...</code> a[0:2] = []
<code class="prompt">&gt;&gt;&gt;</code> a
[123, 1234]
&gt;&gt;&gt; # Listenin içine elemanlar ekle:
<code class="prompt">...</code> a[1:1] = ['bletch', 'xyzzy']
<code class="prompt">&gt;&gt;&gt;</code> a
[123, 'qwerty', 'xyzzy', 1234]
<code class="prompt">&gt;&gt;&gt;</code> a[:0] = a # Listenin kopyasını listenin başına ekle
<code class="prompt">&gt;&gt;&gt;</code> a
[123, 'qwerty', 'xyzzy', 1234, 123, 'qwerty', 'xyzzy', 1234]
</pre>
            <p>
     Yerleşik işlev <code class="literal">len()</code> listeler ile de çalışır:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> len(a)
8
</pre>
            <p>İç içe listeler yaratılabilir. Örnek:</p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> q = [2, 3]
<code class="prompt">&gt;&gt;&gt;</code> p = [1, q, 4] # buradaki q üst satırda tanımlanan listedir
<code class="prompt">&gt;&gt;&gt;</code> len(p)
3
<code class="prompt">&gt;&gt;&gt;</code> p[1]
[2, 3]
<code class="prompt">&gt;&gt;&gt;</code> p[1][0]
2
<code class="prompt">&gt;&gt;&gt;</code> p[1].append('xtra')     # append daha sonra açıklanacak
<code class="prompt">&gt;&gt;&gt;</code> p
[1, [2, 3, 'xtra'], 4]
<code class="prompt">&gt;&gt;&gt;</code> q
[2, 3, 'xtra']
</pre>
            <p>
     Üstteki örnekte <code class="literal">p[1]</code> ve <code class="literal">q</code>'nun
     aynı nesne olduğuna dikkat edin!
    </p>
          </section>
        </section>
        <section class="sect1" id="python-tutorial_ilkler">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">3.2. Programlamaya Doğru İlk Adımlar</h2>
              </div>
            </div>
          </div>
          <p>
    Tabii ki Python kullanarak iki ile ikiyi toplamaktan daha karmaşık işler
    yapabiliriz. Mesela bir Fibonacci serisini şöyle yazabiliriz:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> # Fibonacci serisi:
<code class="prompt">...</code> # iki elemanın toplamı bir sonraki elemanı verir
<code class="prompt">...</code> a, b = 0, 1
<code class="prompt">&gt;&gt;&gt;</code> while b &lt; 10:
<code class="prompt">...</code>     print b
<code class="prompt">...</code>     a, b = b, a+b
<code class="prompt">...</code>
1
1
2
3
5
8
</pre>
          <p>
    Bu örnekte birkaç yeni özellik gösterilmektedir:
   </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>
      İlk satırda bir <em class="emphasis">çoklu değer atama</em> var; a ve b
      değişkenleri bir anda 0 ve 1 değerlerini alır. Bu özellik son
      satırda da kullanılmaktadır. Son satırda dikkat çeken bir diğer
      olay da ifadenin sağ kısmının soldan sağa doğru atama işlemlerinden
      önce hesaplandığıdır.
     </p>
              </li>
              <li class="listitem">
                <p>
      <code class="literal">while</code> döngüsü, verilen koşul (burada: b &lt; 10)
      doğru olduğu sürece tekrarlanır. Python'da, C'de olduğu gibi,
      sıfır dışındaki herhangi bir değer doğru ve sıfır yanlış kabul
      edilir. Koşul bir dizge veya liste de olabilir. Boyu sıfır olmayan
      her şey doğru iken, boş listeler, dizgeler, vs yanlış kabul edilir.
     </p>
                <p>
      Üstteki örnekte basit bir kıyaslama işlemi var. Standart kıyaslama
      işlemleri C'de olduğu gibi yazılır: &lt; (küçük), &gt; (büyük), ==
      (eşit), &lt;= (küçük eşit), &gt;= (büyük eşit), != (eşit değil).
     </p>
              </li>
              <li class="listitem">
                <p>
      Döngü bloğu girinitli yazılmıştır. Girintili yazma Python'un ifadeleri
      gruplama yoludur. Etkileşimli kipte girintili bir öbek yazıldığı zaman
      boş bir satır ile sonlandırılmalıdır (çünkü yorumlayıcı yazmayı ne zaman
      bıraktığınızı bilemez). Grintili bir öbek içindeki her satırın aynı
      girinti miktarına sahip olması gerektiğine dikkat ediniz. Girintiler
      için boşluk veya sekme karakterleri kullanılabilir.
     </p>
              </li>
              <li class="listitem">
                <p>
      <code class="literal">print</code> deyimi kendisine verilen ifadenin veya
       ifadelerin değerini yazar. Birden fazla ifade verilmesi durumunda
       bunlar aralarında boşluk ile yazılır:
      </p>
                <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> i = 256*256
<code class="prompt">&gt;&gt;&gt;</code> print 'İşlemin sonucu:', i
İşlemin sonucu: 65536
</pre>
                <p>
      Sona eklenen bir virgül ise çıktı satırından sonra yeni satıra
      geçilmesini engeller:
     </p>
                <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a, b = 0, 1
<code class="prompt">&gt;&gt;&gt;</code> while b &lt; 1000:
<code class="prompt">...</code>     print b,
<code class="prompt">...</code>     a, b = b, a+b
<code class="prompt">...</code>
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</pre>
              </li>
            </ul>
          </div>
        </section>
      </section>
    </section>
    <footer/>
  </body>
</html>
