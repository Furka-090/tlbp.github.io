<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>4. Akış Denetimi</title>
    <link rel="stylesheet" type="text/css" href="../../style/nav.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/images/belgeler-logo.png" />
    <meta name="robots" content="index, follow" />
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial_basliyoruz.html')">Önceki</button>
          <div class="dropdown-content">3. Python'a Giriş</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('python-tutorial_veri-yapilari.html')">Sonraki</button>
          <div class="dropdown-content">5. Veri Yapıları</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="chapter" id="python-tutorial_akis-denetimi">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title">4. Akış Denetimi</h1>
            </div>
          </div>
        </div>
        <div class="toc">
          <div class="toc-title">İçindekiler</div>
          <dl class="toc">
            <dt>4.1. <a href="python-tutorial_akis-denetimi.html#python-tutorial_if"><code class="literal">if</code> Deyimi</a></dt>
            <dt>4.2. <a href="python-tutorial_akis-denetimi.html#python-tutorial_for"><code class="literal">for</code> Deyimi</a></dt>
            <dt>4.3. <a href="python-tutorial_akis-denetimi.html#python-tutorial_range"><code class="literal">range()</code> işlevi</a></dt>
            <dt>4.4. <a href="python-tutorial_akis-denetimi.html#python-tutorial_break">Döngülerde <code class="literal">break</code>, <code class="literal">continue</code>
    ve <code class="literal">else</code> Deyimleri</a></dt>
            <dt>4.5. <a href="python-tutorial_akis-denetimi.html#python-tutorial_pass"><code class="literal">pass</code> Deyimi</a></dt>
            <dt>4.6. <a href="python-tutorial_akis-denetimi.html#python-tutorial_func">İşlev Tanımlama</a></dt>
            <dt>4.7. <a href="python-tutorial_akis-denetimi.html#python-tutorial_func-more">İşlev Tanımları Üzerine Daha Fazla Bilgi</a></dt>
            <dd>
              <dl>
                <dt>4.7.1. <a href="python-tutorial_akis-denetimi.html">Bağımsız Değişken Değerlerini Önceden Belirleme</a></dt>
                <dt>4.7.2. <a href="python-tutorial_akis-denetimi.html">Bağımız değişken olarak anahtar kelime</a></dt>
                <dt>4.7.3. <a href="python-tutorial_akis-denetimi.html">Keyfî Bağımsız Değişken Listeleri</a></dt>
                <dt>4.7.4. <a href="python-tutorial_akis-denetimi.html">Lambda Biçemli İşlevler</a></dt>
                <dt>4.7.5. <a href="python-tutorial_akis-denetimi.html">Belgelendirme Dizgeleri</a></dt>
              </dl>
            </dd>
          </dl>
        </div>
        <p>
   Bir önceki bölümde tanıtılan <code class="literal">while</code> deyiminin yanısıra
   Python'da diğer yazılımlama dillerinde de bulunan genel akış denetim
   deyimleri (bazı farklarla birlikte) vardır.
  </p>
        <section class="sect1" id="python-tutorial_if">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.1. <code class="literal">if</code> Deyimi</h2>
              </div>
            </div>
          </div>
          <p>
    Belki de en iyi bilinen deyim türü <code class="literal">if</code> deyimidir. Örnek:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> x = int(raw_input("Lütfen bir sayı girin: "))
<code class="prompt">&gt;&gt;&gt;</code> if x &lt; 0:
<code class="prompt">...</code>      x = 0
<code class="prompt">...</code>      print 'Negatif sayı sıfırlandı'
<code class="prompt">...</code> elif x == 0:
<code class="prompt">...</code>      print 'Sıfır'
<code class="prompt">...</code> elif x == 1:
<code class="prompt">...</code>      print 'Bir'
<code class="prompt">...</code> else:
<code class="prompt">...</code>      print 'Birden büyük'
<code class="prompt">...</code>
</pre>
          <p>
    Sıfır veya daha fazla <code class="literal">elif</code> deyimi olabilir, ve
    <code class="literal">else</code> deyimi seçimliktir. <code class="literal">elif</code>
    deyimi <code class="literal">else if</code> deyiminin kısaltılmışıdır ve aşırı
    girintileri engellemesi açısından faydalıdır. Bir <code class="literal">if ... elif
    ... elif ...</code> deyimleri dizisi diğer dillerde bulunan
    <code class="literal">switch</code> veya <code class="literal">case</code> deyimlerinin
    yerine kullanılabilir.
   </p>
        </section>
        <section class="sect1" id="python-tutorial_for">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.2. <code class="literal">for</code> Deyimi</h2>
              </div>
            </div>
          </div>
          <p>
    <code class="literal">for</code> deyimi Pascal veya C dillerinde görülenden biraz
    farklıdır. Python'daki <code class="literal">for</code> deyimi herhangi bir sıranın
    (liste, dizge, vs.) elemanları üzerinde sırayla yinelenir. Örnek:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> # Bazı dizgelerin boylarını ölçelim:
<code class="prompt">...</code> a = ['kedi', 'pencere', 'kertenkele']
<code class="prompt">&gt;&gt;&gt;</code> for x in a:
<code class="prompt">...</code>     print x, len(x)
<code class="prompt">...</code>
kedi 4
pencere 7
kertenkele 10
</pre>
          <p>
    Üzerinde yinelenilen sırada değişiklik yapmak güvenli değildir
    (bu sadece listelerde olabilir). Eğer böyle bir şey yapacaksanız
    bu iş için dilim gösterimi ile listenin bir kopyasını
    kullanabilirsiniz:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> for x in a[:]: # tüm listenin bir kopyasını oluştur
<code class="prompt">...</code> if len(x) &gt; 8: a.insert(0, x)
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> a
['kertenkele', 'kedi', 'pencere', 'kertenkele']
</pre>
        </section>
        <section class="sect1" id="python-tutorial_range">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.3. <code class="literal">range()</code> işlevi</h2>
              </div>
            </div>
          </div>
          <p>
    Eğer bir sayı sırası üzerinde tekrarlamalar yapmak isterseniz, belirli
    bir sıraya göre üretilen sayılardan oluşan bir liste oluşturan
    <code class="literal">range()</code> yerleşik işlevini kullanabilirsiniz.
    Örnek:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
          <p>
    Verilen bitiş noktası asla üretilen listenin bir parçası olmaz;
    <code class="literal">range(10)</code> ifadesi 10 elemanı olan bir liste oluşturur.
    Listenin başlayacağı sayıyı ve artış miktarını da belirlemek mümkündür.
    Artış miktarı negatif de olabilir.
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> range(5, 10)
[5, 6, 7, 8, 9]
<code class="prompt">&gt;&gt;&gt;</code> range(0, 10, 3)
[0, 3, 6, 9]
<code class="prompt">&gt;&gt;&gt;</code> range(-10, -100, -30)
[-10, -40, -70]
</pre>
          <p>
    <code class="literal">range()</code> ve <code class="literal">len()</code> işlevlerini bir
    arada kullanarak da bir listenin elemanları üzerinde döngüler
    kurabilirsiniz:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> a = ['Python', 'yazılımlama', 'öğrenmek', 'çok', 'kolay !']
<code class="prompt">&gt;&gt;&gt;</code> for i in range(len(a)):
<code class="prompt">...</code>     print i, a[i]
<code class="prompt">...</code>
0 Python
1 yazılımlama
2 öğrenmek
3 çok
4 kolay
</pre>
        </section>
        <section class="sect1" id="python-tutorial_break">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.4. Döngülerde <code class="literal">break</code>, <code class="literal">continue</code>
    ve <code class="literal">else</code> Deyimleri</h2>
              </div>
            </div>
          </div>
          <p>
    <code class="literal">break</code> deyimi, C'de olduğu gibi, içinde kaldığı en küçük
    <code class="literal">for</code> veya <code class="literal">while</code> döngüsünden
    çıkılmasına ve döngü deyiminin tamamen sona ermesine neden olur.
   </p>
          <p>
    <code class="literal">continue</code> deyimi döngü içindeki diğer deyimlerin
    atlanıp bir sonraki yineleme işleminin başlamasına sebep olur.
   </p>
          <p>
    Döngülerde <code class="literal">else</code> ifadesi de kullanılabilir;
    <code class="literal">else</code> bloğu döngü bittiğinde (<code class="literal">for</code>
    için) veya devamlılık koşulu geçersiz olduğunda (<code class="literal">while</code>
    için) işletilir; fakat döngü <code class="literal">break</code> deyimi ile sona
    erdiyse işletilmez. Bunu asal sayılar bulan aşağıdaki örnekte görebilirsiniz:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> for n in range(2, 10):
<code class="prompt">...</code>     for x in range(2, n):
<code class="prompt">...</code>         if n % x == 0:
<code class="prompt">...</code>            print n, 'asal sayı değil. çarpanlar:', x, '*', n/x
<code class="prompt">...</code>            break
<code class="prompt">...</code>     else:
<code class="prompt">...</code>          # çarpan bulunmadan döngü biter ise
<code class="prompt">...</code>          print n, 'asal sayıdır'
<code class="prompt">...</code>
2 asal sayıdır
3 asal sayıdır
4 asal sayı değil. çarpanlar: 2 * 2
5 asal sayıdır
6 asal sayı değil. çarpanlar: 2 * 3
7 asal sayıdır
8 asal sayı değil. çarpanlar: 2 * 4
9 asal sayı değil. çarpanlar: 3 * 3
</pre>
        </section>
        <section class="sect1" id="python-tutorial_pass">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.5. <code class="literal">pass</code> Deyimi</h2>
              </div>
            </div>
          </div>
          <p>
    <code class="literal">pass</code> deyimi hiçbir şey yapmaz. Python sözdizim
    kurallarına göre bir ifadenin gerekli olduğu, fakat yazılımın bir
    şey yapması gerekmediği zaman kullanılabilir:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> while 1:
<code class="prompt">...</code>       pass # klavyeden CTRL+C ile kesilene kadar sürer
<code class="prompt">...</code>
</pre>
        </section>
        <section class="sect1" id="python-tutorial_func">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.6. İşlev Tanımlama</h2>
              </div>
            </div>
          </div>
          <p>
    Herhangi bir değere kadar Fibonacci serisi yazan bir işlev yazalım:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> def fib(n):     # n'e kadar Fibonacci serisini yazdır
<code class="prompt">...</code>     "n'e kadar Fibonacci serisini yazdır"
<code class="prompt">...</code>     a, b = 0, 1
<code class="prompt">...</code>     while b &lt; n:
<code class="prompt">...</code>         print b,
<code class="prompt">...</code>         a, b = b, a+b
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> # Tanımladığımız işlevi çağıralım:
<code class="prompt">...</code> fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
</pre>
          <p>
    <code class="literal">def</code> anahtar kelimesi bir işlev tanımını başlatır.
    Bu deyimden sonra bir işlev adı ve parantez içinde bağımsız değişkenler yazılır.
    İşlevin gövdesini oluşturan yazılım satırları sonraki satırdan itibaren
    girintili olarak yazılır. İşlev gövdesinin ilk satırı bir dizge de
    olabilir; bu dizge işlevin belgelenmesinde kullanılır (docstring).
   </p>
          <p>
    İşlevlerin belgelenmesinde kullanılan dizgeleri (docstring) otomatik
    olarak çevrim içi ya da basılı belgeler oluşturmak için kullanan
    yazılımlar vardır. Ayrıca bazı geliştirme ortamları bunları yazılım
    yazarken kolaylık sağlaması için etkileşimli olarak yazılımcıya
    sunar. Yazdığınız işlevlere bunları eklemeyi bir alışkanlık haline
    getirmeniz faydalı olur.
   </p>
          <p>
    Bir işlevin çağrılması (çalıştırılması) bu işlevdeki yerel değişkenlerin
    olduğu bir simge tablosu oluşturur. İşlev içerisinde bütün değer atama
    işlemlerinde değerler yerel simge tablosuna kaydedilir. Bir değişkene
    başvuru durumunda ise önce yerel (local), sonra genel (global) ve en son
    yerleşik (built-in) simge tablosunda arama yapılır. Bu yüzden genel
    değişkenlere doğrudan değer atama yapılamaz (eğer
    <code class="literal">global</code> ifadesi içinde kullanılmamışlar ise); ancak
    bunlara başvuru yapılabilir (reference).
   </p>
          <p><span class="notfoot"></span>
    İşlev çağırıldığında işlevin bağımsız değişkenleri yerel simge tablosuna
    eklenir; yani bağımsız değişkenler işleve değeri ile çağrı (call by value)
    kullanılarak iletilir (yani bağımsız değişkene yapılan değişiklikler
    yereldir, çağıran işlevdeki bağımsız değişkenlerde bir değişme
    olmaz).<a id="idm77684" href="#ftn.idm77684" class="footnote"><sup class="footnote">[68]</sup></a>
   </p>
          <p>
    Bir işlev başka bir işlevi çağırdığında bu çağrı için yeni bir yerel simge
    tablosu oluşturulur.
   </p>
          <p>
    Bir işlev tanımı işlev adının yürürlükte olan simge tablosuna eklenmesine
    sebep olur. İşlevin adı yorurumlayıcı tarafından kullanıcı tanımlı işlev
    veri türü olarak tanınır. Bu değer başka bir isime atanabilir ve bu da bir
    işlev olarak kullanılabilir. Bu genel bir isim değiştirme yolu olabilir:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> fib
&lt;function object at 10042ed0&gt;
<code class="prompt">&gt;&gt;&gt;</code> f = fib # f de fib işlevi olur
<code class="prompt">&gt;&gt;&gt;</code> f(100)
1 1 2 3 5 8 13 21 34 55 89
</pre>
          <p>
    <code class="literal">fib</code>'in bir işlev olmayıp bir yordam (procedure)
    olduğunu düşünebilirsiniz. Python'da yordamlar, çağıran işleve
    değer geri döndürmeyen işlevlerdir. Aslında yordamlar da bir değer
    geri döndürürler, ama bu sıkıcı bir konudur. Bu değere
    <code class="literal">None</code> denir ve yerleşik bir değişkendir.
    Yorumlayıcı yazılacak tek değer bu ise normalde <code class="literal">None</code>
    yazmaz. Bunu görmeyi çok istiyorsanız şunu deneyin:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> print fib(0)
None
</pre>
          <p>
    Fibonacci serisini yazdırmak yerine, bunu bir liste şeklinde geri
    döndüren işlev yazmak basittir:
   </p>
          <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> def fib2(n): # n e kadar fibonacci serisi geri döndürür
<code class="prompt">...</code>     " n e kadar fibonacci serisi içeren liste geri döndürür"
<code class="prompt">...</code>     sonuc = []
<code class="prompt">...</code>     a, b = 0, 1
<code class="prompt">...</code>     while b &lt; n:
<code class="prompt">...</code>         sonuc.append(b)    # değeri listeye ekle
<code class="prompt">...</code>         a, b = b, a+b
<code class="prompt">...</code>     return sonuc
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> f100 = fib2(100)    # işlevi çağır
<code class="prompt">&gt;&gt;&gt;</code> f100                # sonucu yazdır
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</pre>
          <p>
    Bu örnekte de bazı yeni Python özelliklerini görüyoruz:
   </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>
      <code class="literal">return</code> deyimi bir işlevden değer geri döndürür.
      Bağımsız değişkeni olmayan bir <code class="literal">return</code> deyimi
      <code class="literal">None</code> geri döndürür. Sona eren bir yordam
      (procedure) da <code class="literal">None</code> geri döndürür.
     </p>
              </li>
              <li class="listitem">
                <p>
      <code class="literal">sonuc.append(b)</code> ifadesi sonuç liste nesnesinin
      bir yöntemini çağırmaktadır. Bir yöntem bir nesneye `ait olan' ve
      <code class="literal">nesne.yöntemAdı</code> şeklinde adlandırılan bir
      işlevdir. <code class="literal">nesne.yöntemAdı</code> ifadesinde nesne
      herhangi bir nesne (bir ifade de olabilir) ve <code class="literal">yöntemAdı</code>
      da nesnenin türüne bağlı bir yöntemdir. Farklı veri türleri farklı
      yöntemlere sahiptir. Farklı veri türlerinin ayni isimli
      yöntemleri olabilir. Sonraki bölümlerde anlatılacağı gibi, kendi
      veri türlerinizi ve yöntemlerinizi oluşturmanız mümkündür.
      Yukarıdaki örnekte görülen <code class="literal">append()</code> yöntemi
      liste nesneleri için tanımlıdır ve bir listenin sonuna yeni
      elemanlar ekler. Bu örnekte bu <code class="literal">sonuc = sonuc + [b]</code>
      ifadesinin yaptığını yapar; ancak daha verimlidir.
     </p>
              </li>
            </ul>
          </div>
        </section>
        <section class="sect1" id="python-tutorial_func-more">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title" style="clear: both">4.7. İşlev Tanımları Üzerine Daha Fazla Bilgi</h2>
              </div>
            </div>
          </div>
          <p>
    Değişken sayıda bağımsız değişken alan işlevler tanımlamak da mümkündür.
    Bunun için kullanılan üç yöntem olup bunlar birleştirilerek
    kullanılabilir.
   </p>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">4.7.1. Bağımsız Değişken Değerlerini Önceden Belirleme</h3>
                </div>
              </div>
            </div>
            <p>
     İşlev bağımsız değişkenlerine öntanımlı değerler atamak da mümkündür.
     Böylece çağıran işlev bu bağımsız değişkenleri sağlamazsa bunlar önceden
     belirlenmiş öntanımlı değerlerini alır. Örnek:
    </p>
            <pre class="screen">
def onay_al(prompt, denemeler=4, sikayet='Evet veya hayır, lütfen !'):
    while True:
        ok = raw_input(prompt)
        if ok in ('e', 'evet'): return 1
        if ok in ('h', 'hayır'): return 0
        denemeler = denemeler - 1
        if denemeler &lt; 0: raise IOError, 'kararsız kullanıcı'
        print sikayet
</pre>
            <p>
     Bu işlev <code class="literal">onay_al('Programdan çıkmak istiyor musunuz?')</code>
     ya da <code class="literal">onay_al('Dosyayı silmek istiyor musunuz?', 2)</code>
     şeklinde çağırılabilir.
    </p>
            <p>
     İşlevin öntanımlı bağımsız değişkenleri işlevin tanımlandığı anda, o an
     yürürlükte olan etki alanı içinde değerlendirilir. Yani:
    </p>
            <pre class="screen">
i = 7
def f(arg = i):
    print arg

i = 6
f()
7
</pre>
            <div class="admon warning">
              <h3 class="admon-title">Uyarı</h3>
              <div class="admon-contents">
                <p>
      İşlevin öntanımlı bağımsız değişkenleri sadece bir defa değerlendirilir.
      Bu durum bağımsız değişkenin liste gibi değiştirilebilir bir nesne olduğu durumlarda farklılık yaratır. Örneğin aşağıdaki işlev ardarda
      çağırıldığında bağımsız değişkenlerinin değerlerini biriktirir:
     </p>
                <pre class="screen">
def f(a, L = []):
    L.append(a)
    return L
print f(1)
print f(2)
print f(3)
</pre>
                <p>Bu şu çıktıyı verir:</p>
                <pre class="screen">
[1]
[1, 2]
[1, 2, 3]
</pre>
              </div>
            </div>
            <p>
     Eğer öntanımlı bağımsız değişken değerlerinin birbirini izleyen
     çağrılarla paylaşılmasını istemiyorsanız yukarıdaki işlevi şu şekilde
     yazabilirsiniz:
    </p>
            <pre class="screen">
def f(a, L = None):
    if L is None:
        L = []
    L.append(a)
    return L
</pre>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">4.7.2. Bağımız değişken olarak anahtar kelime</h3>
                </div>
              </div>
            </div>
            <p>
     İşlevler <code class="literal">anahtar kelime = değer</code> şeklindeki anahtar
     kelimelerle de çağırılabilir. Örneğin şu işlev:
    </p>
            <pre class="screen">
def otomobil(yakit,  hareket=' uçar', model='Anadol'):
    print "Eğer", yakit, "koyarsan bu", model, hareket
</pre>
            <p>
     aşağıdaki gibi çağırılabilir:
    </p>
            <pre class="screen">
otomobil('roket yakıtı')
otomobil(hareket = 'dans eder', yakıt = 'zeytin yağı' )
otomobil('ispirto', model = 'Kartal')
otomobil('su','bozulur','Şahin')
</pre>
            <p>
     Şu çağrılar ise hatalıdır:
    </p>
            <pre class="screen">
otomobil()                           # gerekli bağımsız değişken eksik
otomobil(yakıt = 'su','zeytin yağı') # anahtar kelimeden sonra gelen
                                     # anahtar kelime olmayan bağımsız değişken
otomobil('mazot', yakit = 'benzin')  # aynı bağımsız değişken için iki değer
otomobil(sehir = 'İzmir')            # bilinmeyen anahtar kelime
</pre>
            <p>
     Genel olarak, bağımsız değişken listesinin başında konuma bağlı bağımsız
     değişkenler bulunur ve anahtar kelime bağımsız değişkenler onları izler;
     anahtar kelime adları da işlevin bağımsız değişkenlerinden seçilir.
     Bağımsız değişkenin öntanımlı değerlerinin olup olmaması önemli değildir.
     Bir bağımsız değişken birden fazla değer alamaz; konuma bağlı bağımsız
     değişken isimleri aynı çağrıda anahtar kelime olarak kullanılamaz.
     İşte bundan dolayı hatalı olan bir örnek:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> def function(a):
<code class="prompt">...</code>     pass
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> function(0, a=0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: keyword parameter redefined
</pre>
            <p>
     Eğer işlev tanımındaki son bağımsız değişken <code class="literal">**isim</code>
     şeklinde ise bu bağımsız değişken adları herhangi bir bağımsız değişken
     olmayan anahtar kelime şeklindeki bağımsız değişkenlerin bulunduğu bir
     sözlük olur. Bu <code class="literal">*isim</code> (bu konu <a class="xref" href="python-tutorial_veri-yapilari.html#python-tutorial_sozlukler" title="5.4. Sözlükler (Çağrışımlı Listeler)">Sözlükler (Çağrışımlı Listeler)</a> bölümünde anlatılacaktır.)
     şeklindeki bir bağımsız değişken ile de kullanılabilir, ki bu bağımsız
     değişken listesi içinde bulunmayan konuma bağlı bağımsız değişkenleri
     içeren bir demet (daha sonra <a class="xref" href="python-tutorial_veri-yapilari.html#python-tutorial_demetler" title="5.3. Demetler (tuples)">Demetler (tuples)</a>
     bölümünde incelenecek bir veri türüdür) olur. <code class="literal">*isim</code>
     bağımsız değişkeni <code class="literal">**isim</code> bağımsız değişkeninden önce
     gelmelidir. Buna örnek işlev:
    </p>
            <pre class="screen">
def kasapdukkani(etCinsi,*argumanlar, **anahtarKelimeler):
    print "--", etCinsi, "var mi ?"
    print "-- Maalesef", etCinsi, "kalmadı."
    for arg in argumanlar:
        print arg
    print '-'*40
    anahtarlar = anahtarKelimeler.keys()
    anahtarlar.sort()
    for ak in anahtarlar:
        print ak, ':', anahtarKelimeler[ak]
</pre>
            <p>Şu şekilde çağrılabilir:</p>
            <pre class="screen">
kasapdukkani('martı eti',"Çok lezzetli.",
           "Çok satılıyor.",
           musteri = 'Martı Murat',
           kasap = 'Dev İsmail')
</pre>
            <p>ve doğal olarak şu çıktıyı verir:</p>
            <pre class="screen">
-- martı eti var mi ?
-- Maalesef martı eti kalmadı.
Çok lezzetli.
Çok satılıyor.
----------------------------------------
kasap : Dev İsmail
musteri : Martı Murat
</pre>
            <p>
     <code class="literal">anahtarKelimeler</code> isimli sözlüğün içeriği yazdırılmadan
     önce anahtar kelime isimleri listesinin <code class="literal">sort()</code>
     yönteminin çağırıldığına dikkat edin; bu yapılmaz ise bağımsız
     değişkenlerin hangi sıra ile yazılacağı tanımlanmamış olur.
    </p>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">4.7.3. Keyfî Bağımsız Değişken Listeleri</h3>
                </div>
              </div>
            </div>
            <p>
     Son olarak, en ender kullanılan seçenek de keyfî sayıdaki bağımsız
     değişken ile çağrılabilen bir işlev tanımlamaktır. Bu bağımsız
     değişkenler bir demet (değişmez liste [tuple]) içine alınır. Keyfî
     bağımsız değişken listesinden önce sıfır ya da daha fazla normal bağımsız
     değişken bulunabilir. Örnek:
    </p>
            <pre class="screen">
def fprintf(file, format, *args):
    file.write(format % args)
</pre>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">4.7.4. Lambda Biçemli İşlevler</h3>
                </div>
              </div>
            </div>
            <p>
     Yoğun istek üzerine işlevsel dillerde ve Lisp'te bulunan bazı
     özellikler Python'a eklenmiştir. <code class="literal">lambda</code> anahtar
     kelimesi ile küçük anonim işlevler yazılabilir. İşte iki
     bağımsız değişkeninin toplamını geri döndüren bir işlev:
     <code class="literal">lambda a, b: a+b</code>.
    </p>
            <p>
     Lambda işlevleri bir işlev nesnesine ihtiyaç duyulan her yerde
     kullanılabilir. Sözdizim (syntax) açısından bunlar tek bir ifade ile
     sınırlandırılmıştır. Anlambilim (semantics) açısından ise normal
     işlev tanımlamasına getirilen bir sözdizim güzelliğidir. İç içe
     tanımlanmış işlevlerde olduğu gibi lambda işlevleri de kendilerini
     kapsayan etki alanindaki değişkenlere erişebilir:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> def artirici_yap(n):
<code class="prompt">...</code>     return lambda x: x + n
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> f = artirici_yap(42)
<code class="prompt">&gt;&gt;&gt;</code> f(0)
42
<code class="prompt">&gt;&gt;&gt;</code> f(1)
43
</pre>
          </section>
          <section class="sect2">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">4.7.5. Belgelendirme Dizgeleri</h3>
                </div>
              </div>
            </div>
            <p>
     Belgelendirmede kullanılan dizgelerin şekli ve içeriği ile ilgili
     şartlar yeni yeni oluşmaktadır.
    </p>
            <p>
     İlk satır daima nesnenin amacının kısa ve öz tanımı olmalıdır. Kısa
     olması için, nesnenin adından ve türünden bahsedilmemeli; zira bunlar
     başka yollarla da öğrenilebilir. Bu satır büyük harf ile başlayıp
     nokta ile bitmelidir.
    </p>
            <p>
     Eğer belgelendirme dizgesinde birden fazla satır var ise ikinci satır
     boş olup özet ile açıklamamın devamını birbirinden ayırmalıdır. Diğer
     satırlar bir ya da daha fazla satır olabilir. Bunlarla nesnenin
     özellikleri, çağrı şekilleri, yan etkileri vs. açıklanabilir.
    </p>
            <p>
     Python çözümleyicisi (parser) çok satırlı dizgelerdeki
     girintileri yok etmez; yani belgeleri işleyen yazılımlar gerekirse
     bunları atabilir. İlk satırdan sonra gelen ve boş olmayan ilk satırdaki
     girinti miktarı belgelendirme dizgesinin devamındaki girinti miktarını
     belirler. Bu girinti miktarına ``eşdeğer'' boşluk diğer satırların
     başından atılır. Daha az girintili satırlar olmamalı; ama olursa da
     bunların önündeki boşluğun tamamı atılmalı. Boşluğun eşdeğerliği
     sekmelerin genişletilmesinden (1 sekme = 8 boşluk) sonra sınanmalıdır.
    </p>
            <p>
     İşte çok satırlı bir belgelendirme dizgesi örneği:
    </p>
            <pre class="screen">
<code class="prompt">&gt;&gt;&gt;</code> def benimFonksiyon():
<code class="prompt">...</code>     """Sadece belgeler.
<code class="prompt">...</code>
<code class="prompt">...</code>     Başka birşey yapmaz. Gerçekten !.
<code class="prompt">...</code>     """
<code class="prompt">...</code>     pass
<code class="prompt">...</code>
<code class="prompt">&gt;&gt;&gt;</code> print benimFonksiyon.__doc__
Sadece belgeler.

   Başka birşey yapmaz. Gerçekten !
</pre>
          </section>
        </section>
        <div class="footnotes">
          <br />
          <hr class="footnote-hr" />
          <div id="ftn.idm77684" class="footnote">
            <p><a href="#idm77684" class="para"><sup class="para">[68] </sup></a>
     Aslında nesne başvurusu ile çağrı daha iyi bir tanım olur, çünkü
     işleve değiştirilebilir bir nesne aktarılırsa çağıran çağrılanın o
     nesneye uyguladığı tüm değişiklikleri görür (listeye eklenen
     elemanlar gibi).
    </p>
          </div>
        </div>
      </section>
      <footer>
        <div align="center" class="footer">
          <small>Bir <a href="http://belgeler.org.tr/">Linux Kitaplığı</a> Sayfası</small>
        </div>
      </footer>
    </section>
  </body>
</html>
