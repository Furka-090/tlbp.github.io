<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr"><head><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>XSL Dönüşümleri (XSLT) Sürüm 1.0</title><link rel="stylesheet" type="text/css" href="../recs.css" /><style type="text/css">/* Belgeye özel bir CSS yoksa burası boş olabilir. */</style></head><body><div class="head"><p><a href="http://www.w3.org/"><img width="72" height="48" src="../w3c_home.png" alt="W3C" /></a></p><h1><a name="title" id="title"></a>XSL Dönüşümleri (XSLT) Sürüm 1.0</h1><h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Önergesi 16 Kasım 1999</h2><dl><dt>Bu sürüm:</dt><dd>
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116">http://www.w3.org/TR/1999/REC-xslt-19991116</a><br />
(<a href="http://www.w3.org/TR/1999/REC-xslt-19991116.xml">XML</a>
 ve <a href="http://www.w3.org/TR/1999/REC-xslt-19991116.html">HTML</a> biçimleri mevcuttur.)
</dd><dt>Son sürüm:</dt><dd>
<a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>
</dd><dt>Önceki Sürümler:</dt><dd>
<a href="http://www.w3.org/TR/1999/PR-xslt-19991008">http://www.w3.org/TR/1999/PR-xslt-19991008</a><br />
<a href="http://www.w3.org/1999/08/WD-xslt-19990813">http://www.w3.org/1999/08/WD-xslt-19990813</a><br />
<a href="http://www.w3.org/1999/07/WD-xslt-19990709">http://www.w3.org/1999/07/WD-xslt-19990709</a><br />
<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">http://www.w3.org/TR/1999/WD-xslt-19990421</a><br />
<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">http://www.w3.org/TR/1998/WD-xsl-19981216</a><br />
<a href="http://www.w3.org/TR/1998/WD-xsl-19980818">http://www.w3.org/TR/1998/WD-xsl-19980818</a>
</dd><dt>Yayına hazırlayan:</dt><dd>James Clark <a href="mailto:jjc@jclark·com">&lt;jjc@jclark.com&gt;</a></dd></dl><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 1999<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium"> W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.inria.fr/">INRIA</a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-software.html">software licensing</a> rules apply.</p><hr /><dl><dt>Bu çeviri:</dt><dd><a href="xslt.html">Tek sayfalık HTML</a>,  <a href="index.html">çok sayfalı HTML</a> ve <a href="xml">XML</a> biçimleri mevcuttur.</dd><dt class="translatorinfo">Çeviren:</dt><dd>Nilgün Belma Bugüner &lt;<span class="email">nilgun (at) belgeler.org.tr</span>&gt;, 25 Haziran 2007</dd></dl><p class="translationinfo">Bu çeviri de diğer belirtim çevirileri gibi  bilgilendirici
    mahiyettedir, hiçbir bağlamda belirleyici değildir. Bu belge anadili
    Türkçe olan Genel ağ kullanıcılarının bu belirtim hakkında fikir
    edinebilmelerini sağlamak amacıyla Türkçeye çevrilmiştir. Bu belirtimin
    belirleyici tek sürümü W3C tarafından yayımlanan  <a href="http://www.w3.org/TR/1999/REC-xslt-19991116">İngilizce sürümüdür.</a></p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Telif Hakkı</a> © 1999 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.inria.fr/">INRIA</a>, <a href="http://www.keio.ac.jp/">Keio</a>), Tüm hakları saklıdır. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">sorumluluk reddi</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">ticari marka</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents">belge kullanımı</a> ve <a href="http://www.w3.org/Consortium/Legal/copyright-software.html">yazılım lisanslama</a> kuralları uygulanır.</p></div><hr /><div><h2><a name="abstract" id="abstract"></a>Özet</h2><p>Bu belirtim, XML belgeleri başka XML belgelere dönüştürmekte kullanılan bir dil olan XSLT'nin sözdizimini ve anlamlandırmasını tanımlar.</p><p>XSLT, XML için bir biçembent (İng: stylesheet) dili olan XSL'nin bir parçası olarak kullanılmak üzere tasarlanmıştır. XSL, biçimleme belirtmek için XSLT'ye ilaveten bir XML söz varlığına sahiptir. XSL, bir XML belgenin, biçimleme söz varlığını kullanan başka bir XML belgeye nasıl dönüştürüleceğini açıklayan XSLT'yi kullanarak XML belgenin biçemini belirtir.</p><p>XSLT, ayrıca, XSL'den bağımsız olarak kullanmak için de tasarlanmışsa da bir genel amaçlı XML dönüşüm dili olarak düşünülmemiştir. Daha çok, asıl olarak XSLT XSL'nin parçası olarak kullanıldığında gereken dönüşüm çeşitleri için tasarlanmıştır.</p></div><div><h2><a name="status" id="status"></a>Belgenin Durumu</h2><p>Bu belge W3C üyeleri ve diğer ilgili taraflarca gözden geçirilmiş ve W3C Yönetimi tarafından bir W3C <a href="http://www.w3.org/Consortium/Process/#RecsW3C">Önergesi</a> olarak onaylanmıştır. Kararlı bir belge olup başka belgelerden uyulması gerekli bir kaynak olarak atıfta bulunarak veya bir başvuru malzemesi olarak kullanılabilir. W3C'nin Önergedeki rolü, belirtime dikkatleri çekmek ve geniş bir alanda kullanımını yaygınlaştırmaktır. Bu, Web'in işlevselliğini ve birlikte çalışabilirliğini arttırmaktadır.</p><p>Bu belgede tespit edilmiş hatalar <a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata">http://www.w3.org/1999/11/REC-xslt-19991116-errata</a> adresinde listelenmiştir. <b>Bunlardan 2 Kasım 2005'e (E39'a) kadar bilinen hatalarla ilgili değişiklikler çeviriye yansıtılmıştır</b>.</p><p>Bu belirtimle ilgili yorumlar <a href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</a> adresine gönderilebilir; yorum <a href="http://lists.w3.org/Archives/Public/xsl-editors">arşivleri</a> de mevcuttur. XSL'nin, XSLT'yi de içererek halka açık tartışma alanı olarak <a href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</a> eposta listesi vardır.</p><p>Bu belirtimin İngilizce sürümü uyulması gerekli tek sürümdür. Bununla birlikte bu belgenin (bilgilendirici mahiyette) <a href="http://www.w3.org/Style/XSL/translations.html">çeviriler</a>i de mevcuttur.</p><p>W3C Önergelerinin ve diğer teknik belgelerinin bir listesi <a href="http://www.w3.org/TR">http://www.w3.org/TR</a> adresinde bulunabilir.</p><p>Bu belirtim <a href="http://www.w3.org/Style/Activity">W3C Biçem etkinliği</a>nin bir parçası olarak üretilmiştir.</p></div><div class="toc"><a name="index-toc" id="index-toc"></a><h2><a name="contents" id="contents"></a>İçindekiler</h2><p class="toc">1 <a href="#intro">Giriş</a><br />2 <a href="#struct">Biçembent Yapısı</a><br />    2.1 <a href="#xslt-namespace">XSLT İsim-alanı</a><br />    2.2 <a href="#stylesheet-element">stylesheet Elemanı</a><br />    2.3 <a href="#result-element-stylesheet">Birebir Hedef Eleman olarak Biçembent</a><br />    2.4 <a href="#qname">Nitelikli Adlar</a><br />    2.5 <a href="#forwards">İleriye Uyumlu İşlem</a><br />    2.6 <a href="#idp13778448">Biçembentlerin Birleştirilmesi</a><br />          2.6.1 <a href="#include">Biçembentlerin İçerilmesi</a><br />          2.6.2 <a href="#import">Biçembent İthali</a><br />    2.7 <a href="#idp13844128">Gömülü Biçembentler</a><br />3 <a href="#data-model">Veri Modeli</a><br />    3.1 <a href="#root-node-children">Kök Düğümün Çocukları</a><br />    3.2 <a href="#base-uri">Temel Tanım-yeri</a><br />    3.3 <a href="#unparsed-entities">Çözümlenmemiş Öğeler</a><br />    3.4 <a href="#strip">Boşluk Ayıklama</a><br />    3.5 <a href="#E38">XML Sürümü</a><br />4 <a href="#expr">İfadeler</a><br />5 <a href="#rules">Örneklenim Kuralları</a><br />    5.1 <a href="#idp13956352">İşlem Modeli</a><br />    5.2 <a href="#patterns">Örüntüler</a><br />    5.3 <a href="#idp14093232">Örneklenim Kurallarının Tanımlanması</a><br />    5.4 <a href="#idp14117104">Örneklenim Kurallarının Uygulanması</a><br />    5.5 <a href="#conflict">Şablon Kuralları için Uyuşmazlıkların Çözümlenmesi</a><br />    5.6 <a href="#apply-imports">Örneklenim Kurallarının Geçerli Kılınması</a><br />    5.7 <a href="#modes">Kipler</a><br />    5.8 <a href="#built-in-rule">Yerleşik Örneklenim Kuralları</a><br />6 <a href="#named-templates">İsimli Örneklenimler</a><br />7 <a href="#rtree">Hedef Ağacın Oluşturulması</a><br />    7.1 <a href="#idp14242320">Elemanların ve Özniteliklerin Oluşturulması</a><br />          7.1.1 <a href="#literal-result-element">Birebir Hedef Elemanlar</a><br />          7.1.2 <a href="#idp14285696">Elemanların xsl:element ile Oluşturulması</a><br />          7.1.3 <a href="#creating-attributes">Özniteliklerin xsl:attribute ile Oluşturulması</a><br />          7.1.4 <a href="#attribute-sets">İsimli Öznitelik Kümeleri</a><br />    7.2 <a href="#idp14400704">Metin Oluşturma</a><br />    7.3 <a href="#idp14417616">İşlem Yönergelerinin Oluşturulması</a><br />    7.4 <a href="#idp14439200">Açıklamaların Oluşturulması</a><br />    7.5 <a href="#copying">Kopyalama</a><br />    7.6 <a href="#idp14472400">Üretilen Metnin Hesaplanması</a><br />          7.6.1 <a href="#value-of">Metnin xsl:value-of ile Üretilmesi</a><br />          7.6.2 <a href="#attribute-value-templates">Öznitelik Değeri Örneklenimleri</a><br />    7.7 <a href="#number">Numaralama</a><br />          7.7.1 <a href="#convert">Sayıdan Dizgeye Dönüşüm Öznitelikleri</a><br />8 <a href="#for-each">Yineleme</a><br />9 <a href="#condproc">Koşullu İşlem</a><br />    9.1 <a href="#idp14650928">xsl:if ile Koşullu İşlem</a><br />    9.2 <a href="#idp14660832">xsl:choose ile Koşullu İşlem</a><br />10 <a href="#sorting">Sıralama</a><br />11 <a href="#variables">Değişkenler ve Değergeçler</a><br />    11.1 <a href="#idp14760320">Hedef Ağaç Bölümleri</a><br />    11.2 <a href="#variable-values">Değişken ve Değergeçlerin Değerleri</a><br />    11.3 <a href="#copy-of">Değişken ve Değergeçlerin Değerlerinin xsl:copy-of ile Kullanımı</a><br />    11.4 <a href="#top-level-variables">Tepe-Seviyeden Değişkenler ve Değergeçler</a><br />    11.5 <a href="#local-variables">Örneklenimlerin içinde Değişkenler ve Değergeçler</a><br />    11.6 <a href="#idp14831536">Değergeçlerin Örneklenimlere Aktarılması</a><br />12 <a href="#add-func">Ek İşlevler</a><br />    12.1 <a href="#document">Çok Kaynaklı Belgeler</a><br />    12.2 <a href="#key">Anahtarlar</a><br />    12.3 <a href="#format-number">Sayı Biçimleme</a><br />    12.4 <a href="#misc-func">Çeşitli Ek İşlevler</a><br />13 <a href="#message">İletiler</a><br />14 <a href="#extension">Eklentiler</a><br />    14.1 <a href="#extension-element">Eklenti Elemanlar</a><br />    14.2 <a href="#idp15072320">Eklenti İşlevler</a><br />15 <a href="#fallback">Son Çare</a><br />16 <a href="#output">Çıktı</a><br />    16.1 <a href="#idp15168928">XML Çıktılama Yöntemi</a><br />    16.2 <a href="#idp15231760">HTML Çıktılama Yöntemi</a><br />    16.3 <a href="#idp15287264">Metin Çıktılama Yöntemi</a><br />    16.4 <a href="#disable-output-escaping">Çıktı Önceleniminin İptal Edilmesi</a><br />17 <a href="#conformance">Uyumluluk</a><br />18 <a href="#notation">Gösterim</a><br /></p><h3><a name="appendices" id="appendices"></a>Ekler</h3><p class="toc">A <a href="#bibref">Kaynakça</a><br />    A.1 <a href="#idp15334816">Uyulması Gerekenler</a><br />    A.2 <a href="#idp15361792">Diğerleri</a><br />B <a href="#element-syntax-summary">Elemanların Özet Sözdizimleri</a><br />C <a href="#dtd">XSLT Biçembentlerinde DTD Bölümü</a> (Bilgilendirici)<br />D <a href="#examples">Örnekler</a> (Bilgilendirici)<br />    D.1 <a href="#idp15423568">Belge Örneği</a><br />    D.2 <a href="#data-example">Veri Örneği</a><br />E <a href="#ack">Teşekkür</a> (Bilgilendirici)<br />F <a href="#changes">Önerge Adaylığından beri Değişenler</a> (Bilgilendirici)<br />G <a href="#future">XSLT'nin gelecek sümlerinde ele alınacak özellikler</a> (Bilgilendirici)<br /></p></div><hr /><div class="body"><div class="div1"><h2><a name="intro" id="intro"></a>1 Giriş</h2><p>Bu belirtim, XSLT dilinin sözdizimini ve anlamlandırmasını tanımlar. XSLT dilinde bir dönüşüm, XSLT tarafından tanımlanmış olsun olmasın bütün elemanları içererek, [<a href="#XMLNAMES">XML Adları</a>] veya [<a href="#XMLNAMES11">XML Adları 1.1</a>] İsim-alanları Önergesine uygun ve iyi biçimlenmiş bir [<a href="#XML">XML</a>] veya [<a href="#XML11">XML 1.1</a>] belge olarak ifadesini bulur. Kolaylık olsun diye, XML 1.0 ve XML Adları 1.0 Önergelerine atıf yapılmıştır. Bu bakımdan, tek biçimli tanım-yeri başvuruları kullanılmışsa da uluslararası tanım-yeri başvuruları da ayrıca desteklenebilir. Bazı durumlarda XML 1.0 ve XML 1.1 tanımları tamamen aynı olabilir. <a name="dt-xslt-namespace" id="dt-xslt-namespace" title="XSLT İsim-alanı"></a><span title="XSLT İsim-alanı tanımı" class="termdef">XSLT tarafından tanımlanmış elemanlar belli bir XML isim-alanına karşılık olmakla diğerlerinden ayrılırlar (bkz, <a href="#xslt-namespace"><b>XSLT İsim-alanı</b></a>); bu belirtimde bu isim-alanından <b>XSLT isim-alanı</b> olarak bahsedilecektir. Bu belirtim aynı zamanda, XSLT isim-alanı sözdiziminin ve anlamlandırmasının bir tanımıdır.</span></p><p>XSLT'de ifadesini bulan bir dönüşüm, bir kaynak ağacı bir hedef ağaca dönüştürecek kuralları açıklar. Dönüşüm, örüntüler örneklerle ilişkilendirilerek elde edilir. Bir örüntü kaynak ağacındaki elemanlarla eşleşirken, bir örnek hedef ağacın elemanlarını oluşturur. Hedef ağaç, kaynak ağaçtan ayrıdır. Hedef ağacın yapısı kaynak ağacın yapısından tamamen farklı olabilir. Hedef ağaç oluşturulurken, kaynak ağaçtaki elemanlar süzülebilir, yeni bir sırayla dizilebilir ve hatta ağaca tamamen keyfi bir yapı eklenebilir.</p><p>XSLT'de ifadesini bulan dönüşüme <b>biçembent</b> (İng: stylesheet) denir. Çünkü, XSLT'nin XSL biçimleme söz varlığına dönüştüğü durumda dönüşüm bir biçembent (biçem demeti) olarak iş görür.</p><p>Bu belge bir XSLT biçembendinin bir XML belgesi ile nasıl ilişkilendirileceğini açıklamaz. XSL işlemcilerinin [<a href="#XMLSTYLE">XML Stylesheet</a>]'te açıklanan mekanizmayı desteklemeleri önerilir. Bu veya herhangi bir başka mekanizma, bir XML belgeye aynı anda uygulanacak bir XSLT biçembent silsilesinden oluştuğunda, etkisi, silsileyi oluşturan üyeleri aynı sırayla içeren (bkz, <a href="#import"><b>Biçembent İthali</b></a>) tek bir biçembendin uygulanmasına eşit olmalıdır.</p><p>Bir biçembent, örneklenim kurallarından oluşan bir küme içerir. Bir örneklenim kuralı iki parçadan oluşur: kaynak ağacındaki düğümlere karşılık olan bir örüntü ve hedef ağacın biçimlenecek parçasının biçimleme örneğini içeren bir örneklenim (İng: template). Bu, bir biçembendin kaynak ağaç yapıları birbirine benzeyen geniş bir belge sınıfına uygulanabilmesini mümkün kılar.</p><p>Bir örneklenim, hedef ağacın bir bölümünü oluşturacak belli bir kaynak eleman için bir örneklenimdir. Bir örneklenim, hedef eleman yapısını birebir belirten elemanlar içerebileceği gibi, hedef ağaç yapısını oluşturacak yönergeler olarak XSLT isim-alanındaki elemanları da içerebilir. Bir örneklenim işleme sokulduğunda, içerdiği her yönerge yorumlanır ve oluşturacağı hedef ağaç bölümüyle değiştirilir. Yönergeler astsal kaynak elemanlarını seçebilir ve işleyebilir. Bir astsal elemanın işlenmesi, uygun örneklenim kuralının bulunması ve bu kuraldaki örneklenimin işleme sokularak hedef ağacın bir bölümünün  oluşturulması anlamına gelir. Elemanların sadece bir yönergenin yorumlanmasıyla seçildikleri takdirde işleme sokulabileceğine dikkat ediniz. Hedef ağaç, kök düğümü için hazırlanmış örneklenim kuralı bulunup onun örneklenimi işleme sokularak oluşturulur.</p><p>Uygun örneklenim kuralını bulma işleminde, birden fazla örneklenim kuralı belirtilen elemanla eşleşen örüntüye sahip olabilir. Ancak, sadece bir örneklenim kuralı uygulanacaktır. Hangi örneklenim kuralının uygulanacağına karar verme yöntemi <a href="#conflict"><b>Şablon Kuralları için Uyuşmazlıkların Çözümlenmesi</b></a> bölümünde açıklanmıştır.</p><p>Bir örneklenim tek başına oldukça güçlü sayılır: az veya çok karmaşıklıkta yapılar oluşturabilir; kaynak ağacın çeşitli yerlerindeki dizge değerlerini çekip çıkarabilir; elemanların kaynak ağaçta yer alışlarına bağlı olarak yinelenen yapılar üretebilir. Basit dönüşümler bakımından, hedef ağacın yapısı kaynak ağacın yapısından bağımsız olduğunda, bir biçembent çoğunlukla kaynak ağacın tamamı için işlem yapan tek bir örneklenimden meydana gelir. İçeriği verilerden oluşan XML belgeler üzerindeki dönüşümler çoğunlukla bu türdendir (bkz, <a href="#data-example"><b>Veri Örneği</b></a>). XSLT bu tür biçembentler için basitleştirilmiş bir sözdizimi sağlar (bkz, <a href="#result-element-stylesheet"><b>Birebir Hedef Eleman olarak Biçembent</b></a>).</p><p>Bir örneklenim işleme sokulduğunda daima bir <a name="dt-current-node" id="dt-current-node" title="Geçerli Düğüm"></a><span title="Geçerli Düğüm tanımı" class="termdef"><b>geçerli düğüm</b></span> ve bir <a name="dt-current-node-list" id="dt-current-node-list" title="Geçerli Düğüm Listesi"></a><span title="Geçerli Düğüm Listesi tanımı" class="termdef"><b>geçerli düğüm listesi</b></span> ile ilgili olarak işlem yapar. Geçerli düğüm daima geçerli düğüm listesinin bir üyesidir. XSLT'deki işlemlerin çoğu geçerli düğüme göredir. Pek az yönerge geçerli düğüm listesini veya geçerli düğümü değiştirir (bkz, <a href="#rules"><b>Örneklenim Kuralları</b></a> ve <a href="#for-each"><b>Yineleme</b></a>); bu yönergeler işlem yaptığı sırada, geçerli düğüm listesi yerini yeni düğüm listesine bırakır; yani yeni listenin her üyesi geçerli düğüm haline gelir; yönergenin işi bittiğinde geçerli düğüm listesi veya geçerli düğüm tekrar yönerge öncesinde geçerli olan düğüm listesi ve düğüm olur.</p><p>XSLT metin üretmek ve koşullu işlemler için eleman seçerken [<a href="#XPATH">XPath</a>] tarafından tanımlanmış ifade dilini kullanır.</p><p>XSLT, dili genişletmek için kullanıcı tarafından değiştirilerek kullanılmak üzere iki özellik sağlar, biri örneklenimlerde kullanılan yönerge elemanları kümesini, diğeri XPath ifadelerinde kullanılan işlev kümesini genişletir. Bu özelliklerin her ikisi de XML isim-alanlarına dayandırılmıştır. XSLT'nin bu sürümü bu özellikleri gerçeklemek için bir mekanizma tanımlamamıştır (bkz, <a href="#extension"><b>Eklentiler</b></a>).</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XSL Çalışma Grubu böyle bir mekanizmayı bu belirtimin ileriki sürümlerinde veya ayrı bir belirtimde tanımlamayı düşünmektedir.<p></p></dd></dl><p>XSLT tarafından tanımlanmış elemanların sözdizimlerini belirleyen eleman sözdizimi gösterim özeti <a href="#notation"><b>Gösterim</b></a> bölümünde açıklanmıştır.</p><p>XSLT biçembentleri için MIME ortam türleri olarak <code>text/xml</code> ve
<code>application/xml</code> [<a href="#RFC2376">RFC2376</a>] kullanılmalıdır. Özellikle XSLT biçembentleri için kayda geçirilmiş bir ortam türü olduğunda, bu ortam türü de kullanılabilir.</p></div><div class="div1"><h2><a name="struct" id="struct"></a>2 Biçembent Yapısı</h2><div class="div2"><h3><a name="xslt-namespace" id="xslt-namespace"></a>2.1 XSLT İsim-alanı</h3><p>XSLT isim-alanı tanımı <code>http://www.w3.org/1999/XSL/Transform</code>adresinde bulunmaktadır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Adresin içindeki <code>1999</code> ibaresi, bu tanım-yerinin (URI) W3C tarafından tahsis edildiği yılı belirtir. XSLT'nin kullanılmakta olan sürümünü göstermez (kullanılmakta olan XSLT sürümü özniteliklerle belirtilir (bkz, <a href="#stylesheet-element"><b>stylesheet Elemanı</b></a> ve <a href="#result-element-stylesheet"><b>Birebir Hedef Eleman olarak Biçembent</b></a>).<p></p></dd></dl><p>XSLT işlemcileri bu isim-alanındaki elemanları ve öznitelikleri tanımak için XML isim-alanları mekanizmasını [<a href="#XMLNAMES">XML Adları</a>] kullanmalıdır. XSLT isim-alanındaki elemanlar sadece biçembent içinde tanınırlar, kaynak belge içinde tanınmazlar. XSLT tarafından tanımlanmış elemanların tam  listesi <a href="#element-syntax-summary"><b>Elemanların Özet Sözdizimleri</b></a> bölümündedir. Üreticiler XSLT isim-alanını yeni elemanlar ve öznitelikler ekleyerek genişletmemelidirler. Böyle bir genişletme yapılacaksa, bu ayrı bir isim-alanında yapılmalıdır. Ek yönerge elemanları için kullanılacak bir isim-alanı <a href="#extension-element"><b>Eklenti Elemanlar</b></a> bölümünde belirtilmiş olan eleman ekleme mekanizmasına göre tanımlanmalıdır.</p><p>Bu belirtimde, XSLT isim-alanındaki elemanlara atıfta bulunmak için <tt>xsl:</tt> öneki kullanılmıştır. Ancak, XSLT biçembentleri, XSLT isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak başka bir önek kullanmakta özgürdürler.</p><p>XSLT isim-alanındaki bir eleman XSLT isim-alanında bulunmayan bir özniteliği, boş olmayan bir isim-alanı tanım-yerine sahip öznitelik <a href="../xpath#dt-expanded-name">genişletilmiş ismi</a> belirterek içerebilir. Böyle özniteliklerin varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir. Bu bakımdan, bir XSLT işlemci böyle öznitelikleri yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür özniteliklerle, örneğin, eşsiz tanıtıcılar, eniyileme ipuçları veya belgeleme içerilebilir.</p><p>XSLT isim-alanından bir eleman için, bu belgede o eleman için tanımlananlardan başka, boş isim-alanı tanım-yeri belirten genişletilmiş isimli özniteliklere sahip olmak bir hatadır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XSLT eleman, öznitelik ve işlev isimleri için kullanılmakta olan uzlaşımlar şunlardır: isimler küçük harflerden oluşur, sözcükleri ayırmak için tire imleri  ve XML veya HTML gibi alakalı bir dilin sözdiziminde yeralmak kaydıyla kısaltmalar kullanılabilir.<p></p></dd></dl><p></p></div><div class="div2"><h3><a name="stylesheet-element" id="stylesheet-element"></a>2.2 <code>stylesheet</code> Elemanı</h3><a id="element-stylesheet" name="element-stylesheet"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:stylesheet</span>
  <code>id</code> = <var>id</var>
  <code>extension-element-prefixes</code> = <var>dizgecikler</var>
  <code>exclude-result-prefixes</code> = <var>dizgecikler</var>
  <b>version</b> = <var>sayı</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-import">&lt;xsl:import&gt;</a>*, <var>tepe-seviyeden-elemanlar</var>) --&gt;
<span class="element">&lt;/xsl:stylesheet&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><a id="element-transform" name="element-transform"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:transform</span>
  <code>id</code> = <var>id</var>
  <code>extension-element-prefixes</code> = <var>dizgecikler</var>
  <code>exclude-result-prefixes</code> = <var>dizgecikler</var>
  <b>version</b> = <var>sayı</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-import">&lt;xsl:import&gt;</a>*, <var>tepe-seviyeden-elemanlar</var>) --&gt;
<span class="element">&lt;/xsl:transform&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir biçembent, bir XML belgede bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı tarafından ifade edilir. <a href="#element-transform"><span class="elemref"><tt>xsl:transform</tt></span></a> elemanı <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının yerine (eşanlamlı) kullanmak içindir.</p><p>Bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı, biçembendin gerekirdiği XSLT sürümünün belirtildiği bir <code>version</code> özniteliğine sahip olmak zorundadır ve XSLT'nin bu sürümü için değeri <code>1.0</code> olmalıdır. Değer <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <a href="#forwards"><b>İleriye Uyumlu İşlem</b></a>).</p><p><a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı şu elemanları içerebilir:</p><ul><li><a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a></li><li><a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a></li><li><a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a></li><li><a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a></li><li><a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a></li><li><a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a></li><li><a href="#element-decimal-format"><span class="elemref"><tt>xsl:decimal-format</tt></span></a></li><li><a href="#element-namespace-alias"><span class="elemref"><tt>xsl:namespace-alias</tt></span></a></li><li><a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a></li><li><a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a></li><li><a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a></li><li><a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a></li></ul><p><a name="dt-top-level" id="dt-top-level" title="Tepe-seviyeden eleman"></a><span title="Tepe-seviyeden eleman tanımı" class="termdef">Bir <code>xsl:stylesheet </code> elemanının çocuğu olan bir elemana <b>tepe-seviyeden</b> eleman denir.</span></p><p>Bu örnekte bir biçembendin yapısı gösterilmiştir. Üç nokta imleri (<code>...</code>) içeriği veya öznitelik değerini betimler. Bu örnek olası elemanların her birinden sadece bir tane içeriyorsa da biçembentler bu elemanların birden fazlasını içerebileceği gibi hiç içermeyebilir de.</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="..."/&gt;

  &lt;xsl:include href="..."/&gt;

  &lt;xsl:strip-space elements="..."/&gt;

  &lt;xsl:preserve-space elements="..."/&gt;

  &lt;xsl:output method="..."/&gt;

  &lt;xsl:key name="..." match="..." use="..."/&gt;

  &lt;xsl:decimal-format name="..."/&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/&gt;

  &lt;xsl:attribute-set name="..."&gt;
    ...
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:variable name="..."&gt;...&lt;/xsl:variable&gt;

  &lt;xsl:param name="..."&gt;...&lt;/xsl:param&gt;

  &lt;xsl:template match="..."&gt;
    ...
  &lt;/xsl:template&gt;

  &lt;xsl:template name="..."&gt;
    ...
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p><a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a>elemanının çocuklarının yer alış sırası hata takibi ve <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanları dışında önemsizdir. Kullanıcılar elemanları istedikleri sırada kullanmakta özgürdürler ve biçembent oluşturma araçları, elemanların yer alış sırası üzerinde bir denetime sahip olmamalıdır.</p><p>Bundan başka, <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı XSLT isim-alanında bulunmayan elemanlar (isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak ve bu öneki isminde içererek) içerebilir. Bu tür üst seviyeden elemanların varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir; örneğin, çelişkileri çözümlemede farklı kuralların kullanıldığı <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a>'ler belirten bu türden bir üst seviyeden elemana izin verilmemelidir. Dolayısıyla, bir XSLT işlemci bu türden üst seviyeden elemanları yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür elemanlar şunlar için gerekebilir:</p><ul><li>Ek elemanlar veya ek işlevler tarafından kullanılan bilgiler (bkz, <a href="#extension"><b>Eklentiler</b></a>),</li><li>hedef ağaçta yapılacaklarla ilgili bilgiler,</li><li>kaynak ağacın nasıl temin edileceği bilgisi,</li><li>biçembentle ilgili temel veriler,</li><li>biçembentle ilgili belgeleme.</li></ul></div><div class="div2"><h3><a name="result-element-stylesheet" id="result-element-stylesheet"></a>2.3 Birebir Hedef Eleman olarak Biçembent</h3><p>Basitleştirilmiş sözdizimi, bir biçembentin kök düğüme denk gelen tek bir örneklenimle oluşturulmasını mümkün kılar. Yani, biçembentin kendisi hedef elemandan oluşabilir (bkz, <a href="#literal-result-element"><b>Birebir Hedef Elemanlar</b></a>). Böyle bir biçembent, içeriği birebir hedef eleman olan bir örneklenim kuralını içeren <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanlı bir biçembente eşdeğerdir; örneklenim kuralı <code>/</code> örüntüsü ile eşleşir. Örneğin,</p><div class="example"><pre>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
  &lt;head&gt;
    &lt;title&gt;Harcama Raporu Hülâsası&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Toplam Miktar: &lt;xsl:value-of select="harcama-raporu/toplam"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>ile</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Harcama Raporu Hülâsası&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Toplam Miktar: &lt;xsl:value-of select="harcama-raporu/toplam"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p>eşdeğerdir.</p><p>Bir biçembendin belge elemanı olan bir birebir hedef eleman, biçembendin gerektirdiği XSLT sürümünü belirten bir <tt>xsl:version</tt> özniteliğine sahip olmak zorundadır. XSLT'nin bu sürümü için bu değer <code>1.0</code> olup değer bir <code><a href="../xpath#NT-Number">Sayı</a></code> olmalıdır. Diğer birebir hedef elemanlar ayrıca birer <tt>xsl:version</tt> özniteliğine sahip olabilir. <tt>xsl:version</tt> özniteliğinin değeri <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <a href="#forwards"><b>İleriye Uyumlu İşlem</b></a>).</p><p>Bir biçembent olarak kullanıldığında bir birebir hedef elemanın içeriği,  biçembendin içinde kullanılandakinden farklı değildir. Bu bakımdan, bir biçembent olarak kullanılmış olan bir birebir hedef eleman <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanlar içeremez.</p><p>Bazı durumlarda, sistemin bir XML belgenin bir XSLT biçembendi olarak bir XSLT işlemcisi tarafından işlenmesinin gerektiğini anlamasının tek yolu XML belgenin kendisini incelemesi olabilir. Basitleştirilmiş sözdiziminin kullanılması bu süreci daha da zorlaştıracaktır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Örneğin, başka XML dili (BXD) diye bir dilin belge elemanı üzerinde, XML belgenin bir BXD işlemcisi tarafından işlenmesi gereken bir BXD belgesi olduğunu belirten, bir <code>bxd:version</code> özniteliği kullanmış olsun. Eğer bir belge hem <code>bxd:version</code> hem de <tt>xsl:version</tt> özniteliklerine sahipse belgenin bir BXD işlemci tarafından mı yoksa bir XSLT işlemci tarafından mı işleneceği belli olmayacaktır.<p></p></dd></dl><p>Diğer taraftan, böyle bir durumda, XSLT biçembendinde basitleştirilmiş sözdiziminin kullanılmaması gerekir. Bu durum, örneğin, içeriğini işlemek için iletinin MIME ortam türüne bakan bir alıcıya, bir XSLT biçembendinin <code>text/xml</code> veya <code>application/xml</code> MIME ortam türünde bir ileti olarak aktarıldığı bir durum olarak karşımıza çıkabilir.</p></div><div class="div2"><h3><a name="qname" id="qname"></a>2.4 Nitelikli Adlar</h3><p>Bir dahili XSLT nesnesinin ismi, özellikle bir isimli örneklenim (<a href="#named-templates"><b>İsimli Örneklenimler</b></a>), bir kip (<a href="#modes"><b>Kipler</b></a>), bir öznitelik kümesi (<a href="#attribute-sets"><b>İsimli Öznitelik Kümeleri</b></a>), bir anahtar (<a href="#key"><b>Anahtarlar</b></a>), bir onluk sayı biçimi (<a href="#format-number"><b>Sayı Biçimleme</b></a>), bir değişken veya değergeç (<a href="#variables"><b>Değişkenler ve Değergeçler</b></a>) birer <code><a href="../xml-names#NT-QName">NitelAd</a></code> olarak belirtilir. Eğer nitelikli ad bir öneke sahipse, önek bir tanım-yeri başvurusuna genişletilir; bu tanım-yerine başvurusuna genişletme işlemi, ismin yer aldığı öznitelik üzerinden etkili olan isim-alan bildirimleri kullanılarak yapılır.
<a href="../xpath#dt-expanded-name">Genişletilmiş isim</a> ismin yerel kısmı ile nesne ismi olarak kullanılan ve boş olabilen bir tanım-yeri başvurusundan oluşur. Öntanımlı isim-alanı öneksiz isimler için kullanılMAZ.</p></div><div class="div2"><h3><a name="forwards" id="forwards"></a>2.5 İleriye Uyumlu İşlem</h3><p>Bir eleman ileriye uyumlu kipi kendisi, öznitelikleri, astsalları için şunlardan birinin varlığı halinde etkinleştirir:</p><ul><li>Eleman, <code>version</code> özniteliği <code>1.0</code>'dan farklı bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanıdır.</li><li>Eleman, <tt>xsl:version</tt> özniteliği <code>1.0</code>'dan farklı bir değerde olan bir birebir hedef elemandır.</li></ul><p>Değeri <code>1.0</code> olan bir <tt>xsl:version</tt> özniteliğine sahip bir birebir hedef eleman ileriye uyumlu kipi kendisi, öznitelikleri, astsalları ve astsallarının öznitelikleri için etkinleştirmeyecektir.</p><p>Eğer bir eleman ileriye uyumlu kipte işlem yapıyorsa:</p><ul><li><p>Eleman, bir <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemansa ve XSLT 1.0 böyle elemanlara tepe seviyeden elemanlar olarak izin vermiyorsa, eleman içeriğiyle birlikte yoksayılmalıdır.</p></li><li><p>Eleman bir örneklenim içindeyse ve XSLT 1.0 böyle elemanların bir örneklenim içinde bulunmasına izin vermiyorsa,  eleman işleme sokulamadığı takdirde bir hata oluşmalı, aksi takdirde XSLT, eleman için <a href="#fallback"><b>Son Çare</b></a> bölümünde belirtildiği gibi bir son çareye başvurmalıdır.</p></li><li><p>Eleman, XSLT 1.0 tarafından bir elemanın sahip olmasına izin verilmeyen bir özniteliğe sahipse ya da XSLT 1.0 tarafından bir seçimlik özniteliğin sahip olmasına izin verilmeyen bir değere sahip bir özniteliğe sahipse, öznitelik yoksayılmalıdır.</p></li></ul><p>Bu bakımlardan, bir XSLT işlemci aşağıdaki biçembenti, bu belirtimde tanımlanmamış bir XSLT isim-alanından elemanlar içerse bile hatasız işleyebilmelidir.</p><div class="example"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &gt;= 1.1"&gt;
        &lt;xsl:yeni-heyecan-verici-1.1-özelliği/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;XSLT 1.1 gerekli&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;Bu biçembent XSLT 1.1 gerektiriyor.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Eğer bir biçembent sürümü 1.0'dan sonraki bir XSLT'ye ait bir tepe seviyeden elemana son derece bağımlıysa, biçembent, XSLT'nin daha erken sürümlerini gerçekleyen XSLT işlemcilerin tepe seviyeden elemanları sessizce yoksaymayacağından emin olmak için bir <a href="#element-message"><span class="elemref"><tt>xsl:message</tt></span></a> elemanını <code>terminate="yes"</code> özniteliği ile kullanabilir (bkz, <a href="#message"><b>İletiler</b></a>). Örnek:<p></p><div class="example"><pre>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:etkili-yeni-1.1-bildirimi/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &amp;lt; 1.1"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Bu biçembent XSLT 1.1 gerektiriyor.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre></div><p></p></dd></dl><p>
Eğer bir <a title="İfade tanımı" href="#dt-expression">ifade</a> ileriye uyumlu kipte işlem yapan bir öznitelikte bulunuyorsa, XSLT işlemci ifadedeki bazı hatalar için şöyle davranmalıdır:</p><ul><li><p>Eğer ifade XPath dilbilgisine göre izin verilen sözdizimine uygun değilse, ifade gerçekten değerlendirilemedikçe bir hata üretilmemelidir.</p></li><li><p>Eğer ifade XSLT kütüphanesinin bir parçası olmayan ve ismi öneksiz olan bir işlevi çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></li><li><p>Eğer ifade  bir işlevi, XSLT tarafından izin verilmeyen sayıda argümanla veya XSLT tarafından izin verilmeyen türdeki argümanlarla çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></li></ul><p></p></div><div class="div2"><h3><a name="idp13778448" id="idp13778448"></a>2.6 Biçembentlerin Birleştirilmesi</h3><p>XSLT biçembentlerin birleştirilmesi için iki mekanizmaya sahiptir:</p><ul><li>Anlamsallıkları değişmeksizin biçembentlerin birleştirilebilmelerini mümkün kılan içerme mekanizması ve</li><li>her biçembentin diğerlerinin yukarısına gelecek şekilde birleştirilmesini mümkün kılan ithal mekanizması.</li></ul><div class="div3"><h4><a name="include" id="include"></a>2.6.1 Biçembentlerin İçerilmesi</h4><a id="element-include" name="element-include"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:include</span>
  <b>href</b> = <var>tanım-yeri-başvurusu</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanı kullanarak içerebilir. <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanı, değeri içerilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <a href="#base-uri"><b>Temel Tanım-yeri</b></a>).</p><p><a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanına sadece <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> bir eleman olarak izin verilir.</p><p>İçerme işlemi XML ağaç seviyesinde gerçekleşir. <code>href</code> özniteliğinin değeriyle yeri belirlenen kaynak bir XML belge olarak ele alınır ve  bu belgedeki <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının çocukları <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanının yerine yerleştirilirler. İçerilen örneklenim kuralları ve tanımları işlem sırasını fiilen etkilemezler.</p><p>İçerilen biçembent <a href="#result-element-stylesheet"><b>Birebir Hedef Eleman olarak Biçembent</b></a> bölümünde açıklanan basitleştirilmiş sözdizimini kullanıyor olabilir ve böyle bir durumda biçembent eşdeğer <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı ile aynı şekilde ele alınır.</p><p>Bir biçembendin doğrudan veya dolaylı kendi kendini içeriyor olması bir hatadır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Defalarca içerilen bir biçembent tanımların tekrarı sebebiyle hatalara yol açabilir. Böyle çoklu içerimler dolaylı olduklarında daha az belirgin olurlar. Örneğin, <var>B</var> ve <var>C</var> biçembendleri <var>A</var> biçembendini içeriyorsa ve <var>D</var> biçembendi de hem <var>B</var> hem de <var>C</var> biçembendini içeriyorsa, <var>A</var> biçembendi, <var>D</var> biçembendi tarafından dolaylı olarak iki kere içerilmiş olacaktır. <var>B</var>, <var>C</var> ve <var>D</var> biçembentlerinin herbiri bağımsız biçembentler olarak kullanılıyorsa, <var>B</var> biçembendindeki <var>A</var> biçembendinin içerilmesi dışındaki herşeyi bir <var>B'</var> biçembendine aktararak ve benzer bir işlemi <var>C</var> biçembendi içinde yaptıktan sonra <var>D</var> biçembendini <var>A</var>, <var>B'</var> ve <var>C'</var> biçembentlerini içerecek şekilde değiştirerek hatadan kurtulmak mümkün olabilir.<p></p></dd></dl><p></p></div><div class="div3"><h4><a name="import" id="import"></a>2.6.2 Biçembent İthali</h4><a id="element-import" name="element-import"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:import</span>
  <b>href</b> = <var>tanım-yeri-başvurusu</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanı kullanarak ithal edebilir. İthal edilen biçembentteki örneklenim kurallarının ve tanımlarının ithal eden biçembenttekilerin önüne geçmesi dışında ithal işlemi içerme işlemine (bkz, <a href="#include"><b>Biçembentlerin İçerilmesi</b></a>) benzer; işlem aşağıda daha ayrıntılı olarak açıklanmıştır. <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanı, değeri ithal edilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <a href="#base-uri"><b>Temel Tanım-yeri</b></a>).</p><p><a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanına sadece <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> bir eleman olarak izin verilir.</p><p><a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanının çocukları, bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının diğer bütün çocuklarının ve varsa <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanlarının herbirinin çocuklarının öncesine geçmelidir. <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> bir biçembendi içermek üzere kullanıldığında, içerilen belgedeki <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanları yine yukarıya ama, içeren belgedeki <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanlarının sonrasına gider. Örnek:</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p><a name="dt-import-tree" id="dt-import-tree" title="İthal Ağaç"></a><span title="İthal Ağaç tanımı" class="termdef"><a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanları içeren bir biçembentin işlenmesi sırasında karşılaşılan <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanları bir <b>ithal ağaç</b> olarak ele alınır. İthal ağaçtaki her <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı, içerdiği her
<a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanı için bir ithal çocuğa sahip olur. <a href="#element-include"><span class="elemref"><tt>xsl:include</tt></span></a> elemanları ithal ağaç oluşturulmadan önce çözümlenir. </span> <a name="dt-import-precedence" id="dt-import-precedence" title="İthal Önceliği"></a><span title="İthal Önceliği tanımı" class="termdef"> İthal ağaçtaki bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanına, ithal ağacın çocuğu olarak işleme alınacak bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a>  elemanından önce ziyaret edilmiş diğer bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanından daha düşük bir  <b>ithal önceliği</b> tanınır. (Türkçesi, bir sülaledeki bir evlatlığın öz evlatları evlatlıklarından sonra ziyaret edilir.)</span>  Her tanımın ve örneklenim kuralının ithal önceliği kendini içeren <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanına göre belirlenir.</p><p>Varsayalım,</p><ul><li><var>A</var> biçembendi sırasıyla <var>B</var> ve <var>C</var> biçembentlerini ithal etmiş olsun;</li><li><var>B</var> biçembenti <var>D</var>'yi</li><li><var>C</var> biçembendi de <var>E</var>'yi ithal etmiş olsun.</li></ul><p>İthal önceliği sırası <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var> olacaktır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd><a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanlarının herhangi bir tanım veya örneklenim kuralından önce kullanılması gerektiğinden, ithal edilen biçembentleri <a href="#element-import"><span class="elemref"><tt>xsl:import</tt></span></a> elemanına rastlandığı noktada işleme sokan bir gerçeklenim, tanımlara ve örneklenim kurallarına artan ithal önceliğiyle rastlayacaktır.<p></p></dd></dl><p>Genel olarak, daha yüksek önceliğe sahip bir tanım veya örneklenim kuralı, daha düşük ithal önceliğine sahip bir tanım veya örneklenim kuralından öncelikli olur. Bu, her tanım veya örneklenim kuralı çeşidi için ayrı ayrı tanımlanır.</p><p>Bir biçembendin doğrudan veya dolaylı kendi kendini ithal ediyor olması bir hatadır. Bundan kaçınmak için, belli bir tanım-yeri ile bir biçembendin birden fazla yerde ithal edilmesi durumunda, biçembent özel olarak ele alınmaz. <a title="İthal Ağaç tanımı" href="#dt-import-tree">İthal ağaç</a>, ithal edildiği her noktada ayrı bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a>'e sahip olur.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Eğer <a href="#element-apply-imports"><span class="elemref"><tt>xsl:apply-imports</tt></span></a> kullanılmışsa (bkz, <a href="#apply-imports"><b>Örneklenim Kurallarının Geçerli Kılınması</b></a>), davranış, biçembendin sadece en yüksek <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal öncelikli</a> yerde ithal edilmesi durumundakinden farklı olabilir.<p></p></dd></dl><p></p></div></div><div class="div2"><h3><a name="idp13844128" id="idp13844128"></a>2.7 Gömülü Biçembentler</h3><p>Normalde bir biçembent, belge elemanı <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı olan eksiksiz bir XML belgedir. Buna rağmen, bir XSLT biçembenti başka bir kaynağa da gömülebilir. İki çeşit gömülüm mümkündür:</p><ul><li>XSLT biçembendi XML olmayan bir kaynağa gömülebilir veya</li><li>XML belgenin belge elemanı <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı olmaksızın biçembent bir XML kaynağa gömülebilir.</li></ul><p>İkinci şeklini kolaylaştırmak için, <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının eşsiz bir betimleyici içeren bir ID özniteliğine sahip olması mümkün kılınmıştır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Böyle bir özniteliğin XPath <a href="../xpath#function-id"><b><code>id</code></b></a> işlevi ile kullanılabilmesi için gerçekten de ID türünden bir öznitelik olarak DTD'de bildirilmiş olması gerekir.<p></p></dd></dl><p>Aşağıdaki örnekte <code>xml-stylesheet</code> işlem yönergesinin [<a href="#XMLSTYLE">XML Stylesheet</a>] bir belgenin kendi biçembendini içermesini mümkün kılmak için nasıl kullanılabileceği gösterilmiştir. Tanım-yeri başvurusunda <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının yeri olarak bölüm betimleyicili bir göreli tanım-yeri kullanılmıştır:</p><div class="example"><pre>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;

&lt;xsl:stylesheet id="style1"
                version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir biçembent, ister uygulansın, ister içerilsin, ister ithal edilsin bir belgeye gömüldüğü takdirde yoksayılacak bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı belirtilmiş bir örneklenim kuralının varlığını gerektirir.<p></p></dd></dl><p></p></div></div><div class="div1"><h2><a name="data-model" id="data-model"></a>3 Veri Modeli</h2><p>XSLT tarafından kullanılan veri modeli, bu bölümdeki açıklananlar dışında <a href="../xpath#data-model">XPath veri modeli</a> ile aynıdır. XSLT aynı veri modelini kullanan kaynak, hedef ve biçembent belgeleri üzerinde işlem yapar. Aynı ağaca sahip herhangi iki XML belge XSLT'ye göre aynı belgedir.</p><p>Biçembentteki işlem yönergeleri ve açıklamalar yoksayılır: biçembent, ağacında ne işlem yönergesi (İng: processing instruction) ne de açıklama varmış gibi ele alınır.</p><div class="div2"><h3><a name="root-node-children" id="root-node-children"></a>3.1 Kök Düğümün Çocukları</h3><p>Kök düğümün çocukları üzerindeki normal kısıtlamalar hedef ağaç için esnetilir.  Hedef ağacın çocukları bir eleman düğümü için olası herhangi bir sırada olabilir. Özellikle, metin düğümü çocuklara sahip olabileceği gibi istenen sayıda eleman düğümü çocuğa sahip olabilir. <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> yöntemi (bkz, <a href="#output"><b>Çıktı</b></a>) XML çıktı için kullanıldığında hedef ağacın iyi biçimlenmiş bir XML belgesi olması gerekmeyebilir; yine de, çıktı daima iyi biçimlenmiş haricen çözümlenebilir bir öğe olacaktır.</p><p>Kaynak ağacı iyi biçimlenmiş bir XML belge çözümlenerek oluşturulduğunda, kaynak ağacın kök düğümü, bir metin düğümüne sahip olmamak ve tek bir çocuk elemana sahip olmak gibi normal kısıtlamaları kendiliğinden yerine getirecektir. Kaynak ağacı, DOM kullanımı gibi başka bir yöntemle oluşturulduğunda geçerli kısıtlamalar kaynak ağaç için hedef ağaçtaki kadar esnektir.</p></div><div class="div2"><h3><a name="base-uri" id="base-uri"></a>3.2 Temel Tanım-yeri</h3><p>Her düğümün kendisiyle ilişkili tanım-yerine o düğümün <b>temel tanım-yeri</b> denir ve göreli tanım-yerlerini mutlak tanım-yerleri haline getirmek için öznitelik değerlerini çözümlemekte kullanılır. Eğer bir eleman veya işlem yönergesi harici bir öğe içinde yer alıyorsa, bu elemanın veya işlem yönergesinin temel tanım-yeri harici öğenin tanım-yeri olur; aksi takdirde, temel tanım-yeri, belgenin tanım-yeridir. Belge düğümünün temel tanım-yeri belge öğesinin tanım-yeridir. Bir metin, açıklama, öznitelik veya bir isim-alanı düğümümünün temel tanım-yeri ise, ebeveyn düğümün temel tanım-yeridir.</p></div><div class="div2"><h3><a name="unparsed-entities" id="unparsed-entities"></a>3.3 Çözümlenmemiş Öğeler</h3><p>Kök düğüm, belgenin DTD'sinde bildirilmiş her çözümlenmemiş öğe için tanım-yeri veren bir eşleme sahiptir. Tanım-yeri, <a href="../xml#sec-external-ent">öğe bildiriminde</a> belirtilen <a href="../xml#dt-sysid">sistem betimleyici</a> ve <a href="../xml#dt-pubid">genel betimleyiciden</a> üretilir. XSLT işlemci, tanım-yerini üretmek için sistem betimleyicide belirtilen tanım-yerini bırakıp genel betimleyiciyi kullanabilir. Eğer XSLT işlemci tanım-yerini üretmek için genel betimleyiciyi kullanmıyorsa, sistem betimleyiciyi kullanmalıdır; eğer sistem betimleyici bir göreli tanım-yeri ise, temel tanım-yeri [<a href="#RFC2396">RFC2396</a>] olarak öğe bildirimini içeren kaynağın tanım-yerini kullanarak onu bir mutlak tanım-yeri olarak çözümlemelidir.</p></div><div class="div2"><h3><a name="strip" id="strip"></a>3.4 Boşluk Ayıklama</h3><p>Kaynak belge veya biçembent belgesi için ağaç oluşturulup, XSLT tarafından bir şekilde işleme sokulmadan önce bazı metin düğümleri ayıklanabilir. Bir metin düğümü salt boşluk karakterlerini içeriyor olmadıkça asla ayıklanamaz. Metin düğümünün ayıklanması metin düğümünü ağaçtan siler. Ayıklama işleminde boşlukları korunması gereken elemanların isimlerinden oluşan bir küme girdi olarak alınır. Ayıklama işlemi biçembentlerin ve kaynak belgelerin her ikisine de uygulanır, ancak boşlukları korunması gereken elemanlar saptanırken uygulama farklı olur.</p><p>Aşağıdakilerin herhangi biri uygulanabiliyorsa bir metin düğümü korunur:</p><ul><li><p>Metin düğümünün <a href="../xpath#axis-parent">ebeveyn</a>inin eleman ismi boşlukları korunması gereken eleman isimleri arasındadır.</p></li><li><p>Metin düğümü en azından bir tane boşluk olmayan karakter içeriyordur. XML'deki gibi, bir boşluk karakteri <code>#x20</code>, <code>#x9</code>, <code>#xD</code> veya <code>#xA</code> olabilir.</p></li><li><p>Metin düğümünün bir <a href="../xpath#axis-ancestor">üstsel</a> elemanı <code>preserve</code> değerli bir <code>xml:space</code> özniteliğine sahiptir ve üstsel elemanları arasında <code>default</code> değerli <code>xml:space</code> özniteliğine sahip eleman hiç yoktur.</p></li></ul><p>Aksi takdirde, metin düğümü ayıklanır.</p><p><code>xml:space</code> öznitelikleri ağaçtan ayıklanmaz.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Eğer bir birebir hedef elemanda bir <code>xml:space</code> özniteliği belirtilmişse, bu uygulanır ve sonuç özniteliği içerir.<p></p></dd></dl><p>Biçembentler bakımından, boşlukları korunması gereken eleman isimleri kümesi sadece <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> içerir.</p><a id="element-strip-space" name="element-strip-space"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:strip-space</span>
  <b>elements</b> = <var>dizgecikler</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><a id="element-preserve-space" name="element-preserve-space"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:preserve-space</span>
  <b>elements</b> = <var>dizgecikler</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Kaynak belgeler için, boşlukları korunması gereken eleman isimleri <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanlar olan <a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a> ve <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> ile belirtilir.
Bir eleman isminin boşlukları korunması gereken isimler arasında bulunup bulunmadığı en iyi <a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a> veya <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> elemanlarında belirtilmiş isimlerden saptanır. Bir eleman isminin boşlukları korunması gereken isimler arasında bulunması için gerek ve yeter koşul, bir <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> elemanında belirtilen isimlerden biri ile bir eşleşmenin varlığıdır. <a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a> ve <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> elemanların ikisi de değeri boşluk ayraçlı <code><a href="../xpath#NT-NameTest">AdSınaması</a></code> listesi olan birer <code>elements</code> özniteliğine sahiptir; Bir elemanın bir <a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a> veya <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> ile eşleşmesi <code><a href="../xpath#NT-NameTest">AdSınamaları</a></code>ndan biri ile eşleşmesi demektir. Bir elemanın bir <code><a href="../xpath#NT-NameTest">AdSınaması</a></code> ile eşleşmesi için gerek ve yeter koşul, <code><a href="../xpath#NT-NameTest">AdSınaması</a></code>nın bir <a href="../xpath#dt-node-test">XPath düğüm sınaması</a> olarak eleman için doğru olmasıdır. Birden fazla <a href="#element-strip-space"><span class="elemref"><tt>xsl:strip-space</tt></span></a> ve <a href="#element-preserve-space"><span class="elemref"><tt>xsl:preserve-space</tt></span></a> elemanı ile eşleşme olduğu takdirde, en iyi eşleşen eleman, en iyi eşleşen <code><a href="../xpath#NT-NameTest">AdSınaması</a></code> saptanarak bulunur. Bu saptama örneklenim kurallarındaki yöntemle aynıdır:</p><ul><li><p>Önce, diğer eşleşmeden daha düşük <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliğine</a> sahip eşleşmeler yoksayılır.</p></li><li><p>Sonra, diğer eşleşmenin <a title="Öntanımlı İşlem Önceliği tanımı" href="#dt-default-priority">öntanımlı önceliğinden</a> düşük <a title="Öntanımlı İşlem Önceliği tanımı" href="#dt-default-priority">öntanımlı öncelikli </a> eşleşmeler yoksayılır.</p></li></ul><p>Eğer bu yöntemle geriye birden fazla eşleşme kalırsa bu bir hatadır. Bir XSLT işlemci hatayı bildirebilir; eğer bildirmiyorsa, kalan eşleşmeler arasından biçembentte sona doğru yer alanını seçerek hatayı ortadan kaldırmalıdır.</p></div><div class="div2"><h3><a name="E38" id="E38"></a>3.5 XML Sürümü</h3><p>Veri modeli, bir XML 1.0 belgeyi ([<a href="#XML">XML</a>] ve [<a href="#XMLNAMES">XML Adları</a>] ile uyumlu) veya bir XML 1.1 belgeyi ([<a href="#XML11">XML 1.1</a>] ve [<a href="#XMLNAMES11">XML Adları 1.1</a>] ile uyumlu) ifade edebilecek ve ikisi arasında bir ayrım yapmayacak yetenektedir. Bu bakımdan, ilke olarak, XSLT 1.0 bu XML sürümlerinden biri ile kullanılabilir; farklılık sadece, dönüşüme özel sınırların dışında, ya veri modeli metinsel XML'den (çözümlenerek) oluşturulurken ya da metinsel XML veri modelinden üretilirken (sırayla denk düşürerek) ortaya çıkar.</p><p>Veri modelinin oluşturulması bu belirtimin kapsamı dışındadır, dolayısıyla bir XSLT işlemcinin girdiyi bir XML 1.0 veya XML 1.1 belgeden ya da her ikisinden de kabul etmesi ile ilgili bir gereksinim yer almaz. Bu belge XML 1.0 veya XML 1.1 belgeleri çıktılama yeteneğini tanımlar. Ve yine, bir XSLT işlemcinin XML sürümlerinden birini veya ikisini de desteklemesi ile ilgili bir gereksinim yer almaz.</p><p>Kaynak belge ister XML 1.0 ister XML 1.1 olsun veri modeli aynı olduğundan, XSLT işleminin anlambilgisi kaynak belgenin XML sürümüne bağlı değildir. İlke olarak, tek bir dönüşümde kullanılan tüm girdi ve çıktı belgelerinin aynı XML sürümüne uygun olmasını gerektiren bir sebep yoktur.</p></div></div><div class="div1"><h2><a name="expr" id="expr"></a>4 İfadeler</h2><p>XSLT, XPath [<a href="#XPATH">XPath</a>] tarafından tanımlanmış ifade dilini kullanır. XSLT'de ifadeler aşağıdaki amaçlar dahil çeşitli amaçlarla kullanılırlar:</p><ul><li>İşlem için düğümlerin seçimi;</li><li>bir düğümü farklı yollarla işlemek için koşulların belirtilmesi;</li><li>hedef ağaca yerleştirilecek metnin üretilmesi.</li></ul><p><a name="dt-expression" id="dt-expression" title="İfade"></a><span title="İfade tanımı" class="termdef">Bir <b>ifade</b> bir XPath <code><a href="../xpath#NT-Expr">İfade</a></code> sözdizimi ile eşleşmelidir.</span></p><p>İfadeler, XSLT tarafından tanımlanmış elemanların belirli özniteliklerinin değerlerinde ve <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimleri</a>nde kaşlı ayraçların arasında karşımıza çıkarlar.</p><p>XSLT'de bağımsız (başka bir ifadenin parçası olmayan) bir ifadenin bağlamı şöyle oluşur:</p><ul><li><p>Bağlam düğümü <a title="Geçerli Düğüm tanımı" href="#dt-current-node">geçerli düğümden</a> gelir.</p></li><li><p>Bağlam konumu, <a title="Geçerli Düğüm Listesi tanımı" href="#dt-current-node-list">geçerli düğüm listesi</a>ndeki <a title="Geçerli Düğüm tanımı" href="#dt-current-node">geçerli düğüm</a>ün konumundan gelir ve ilk konum 1'dir.</p></li><li><p>Bağlam boyu, <a title="Geçerli Düğüm Listesi tanımı" href="#dt-current-node-list">geçerli düğüm listesinin</a> boyutundan gelir.</p></li><li><p>Değişken bağıntıları, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bağıntılardır (bkz, <a href="#variables"><b>Değişkenler ve Değergeçler</b></a>).</p></li><li><p>İsim-alanı bildirimleri kümesi, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bildirimlerdir; bu, XML İsim-alanları Önergesi'nce [<a href="#XMLNAMES">XML Adları</a>] gereken <code>xml</code> önekinin örtük bildirimini de içerir; öntanımlı isim-alanı (<code>xmlns</code> tarafından bildirilmiş olarak) bu kümenin bir parçası değildir.</p></li><li><p>İşlev kütüphanesi,  <a href="../xpath#corelib">temel işlev kütüphanesi</a>ne ek olarak  <a href="#add-func"><b>Ek İşlevler</b></a> bölümünde tanımlanmış işlevler ile  <a href="#extension"><b>Eklentiler</b></a> bölümünde açıklanan ek işlevlerden oluşur; bir ifadeden bunlar dışında bir işleve çağrı bir hatadır.</p></li></ul><p></p></div><div class="div1"><h2><a name="rules" id="rules"></a>5 Örneklenim Kuralları</h2><div class="div2"><h3><a name="idp13956352" id="idp13956352"></a>5.1 İşlem Modeli</h3><p>Bir kaynak düğümleri listesi işlendiğinde hedef ağacın bir bölümü oluşturulmuş olur. Hedef ağacı oluşturmak için kök düğümü içeren ana listeyi işlemek gerekir. Bir kaynak düğümleri listesi, ana listenin her üyesi sırayla işlenerek oluşturulan hedef ağaç yapısına eklenerek işlenir. Bir düğüm ise, düğümle eşleşen örüntülere sahip tüm örneklenim kuralları bulunarak ve bunların en uygunu seçilerek işlenir; seçilen kuralın örneklenimi, kaynak düğüm <a title="Geçerli Düğüm tanımı" href="#dt-current-node">geçerli düğüm</a> olarak, kaynak düğüm listesi <a title="Geçerli Düğüm Listesi tanımı" href="#dt-current-node-list">geçerli düğüm listesi</a> olarak ele alınarak örneklenir. Bir örneklenim genelde, işlem için ek kaynak düğümü listesini seçmekte kullanılan yönergelerden oluşur. Eşleştirme, örnekleme ve seçim işlemleri işlem için seçilecek kaynak düğümü kalmayıncaya kadar ardışık olarak sürer.</p><p>Gerçeklenimler, kaynak belgeyi, bu işlem modeli kullanılarak elde edilen sonucun aynısını üretecek şekilde işleyecek yöntemi seçmekte özgürdürler.</p></div><div class="div2"><h3><a name="patterns" id="patterns"></a>5.2 Örüntüler</h3><p><a name="dt-pattern" id="dt-pattern" title="Örüntü"></a><span title="Örüntü tanımı" class="termdef">Örneklenim kuralları düğümlerle bir <b>örüntü</b> aracılığıyla özdeşleşir. Örüntüler, örneklenim kurallarından başka, numaralama (<a href="#number"><b>Numaralama</b></a>) ve anahtar bildirimi (<a href="#key"><b>Anahtarlar</b></a>) için de kullanılırlar. Bir örüntü, bir düğüme uygulanacak koşul kümesini belirtir. Bu koşulları yerine getiren bir düğüm örüntüyle eşleşir; yerine getirmiyorsa eşleşmez. Örüntü sözdizimi, ifade sözdiziminin bir alt kümesidir. Özellikle, belli şartları sağladığı takdirde bir <a href="../xpath#location-paths">konumsal yol</a> örüntü olarak kullanılabilir. Bir ifade ayrıca, daima düğüm kümesi türünde bir nesne olarak değerlendirilen bir örüntüdür. Bir düğüm, bir örüntünün belli bir bağlamla ilgili bir ifade olarak değerlendirilmesinin sonucunda elde edilen düğüm kümesinin bir üyesiyse, düğüm örüntüyle eşleşir; sözkonusu bağlam, <a href="../xpath#axis-ancestor-or-self">bu düğüm veya üstsellerinden birinin</a> eşleştiği bağlamsal düğümlerdir.</span></p><p>Bazı örüntü örnekleri:</p><ul><li><p><code>para</code> örüntüsü herhangi bir <code>para</code> elemanıyla eşleşir</p></li><li><p><code>*</code> örüntüsü herhangi bir elemanla eşleşir</p></li><li><p><code>chapter|appendix</code> örüntüsü herhangi bir <code>chapter</code> veya <code>appendix</code> elemanıyla eşleşir</p></li><li><p><code>olist/item</code> örüntüsü <a href="../xpath#axis-parent">ebeveyni</a> <code> olist</code> olan herhangi bir <code>item</code> elemanıyla eşleşir</p></li><li><p><code>appendix//para</code> örüntüsü <a href="../xpath#axis-ancestor">üstseli</a> <code> appendix</code> olan herhangi bir <code>para</code> elemanıyla ile eşleşir</p></li><li><p><code>/</code> örüntüsü sadece <a href="../xpath#root-node">kök düğümle</a> eşleşir</p></li><li><p><code>text()</code> örüntüsü herhangi bir <a href="../xpath#text-nodes"> metin düğümü</a> ile eşleşir</p></li><li><p><code>processing-instruction()</code> örüntüsü herhangi bir işlem yönergesi ile eşleşir</p></li><li><p><code>node()</code> örüntüsü bir <a href="../xpath#attr-nodes"> öznitelik düğümü</a> veya kök düğüm olmayan herhangi bir düğümle eşleşir</p></li><li><p><code>id("W11")</code> örüntüsü <a href="../xpath#unique-id">eşsiz ID</a>'si <code>W11</code> olan elemanla eşleşir</p></li><li><p><code>para[1]</code> örüntüsü ilk <code>para</code> çocukla eşleşir</p></li><li><p><code>*[position()=1 and self::para]</code> örüntüsü çocuklardan <code>para</code> türündekilerin ilkiyle eşleşir</p></li><li><p><code>para[last()=1]</code> örüntüsü sonuncu <code>para</code> çocukla eşleşir</p></li><li><p><code>items/item[position()&gt;1]</code> örüntüsü ebeveynleri <code>items</code> olan <code>item</code> elemanlarından ilki hariç hepsiyle eşleşir</p></li><li><p><code>item[position() mod 2 = 1]</code> örüntüsü çift numaralı <code>item</code> çocuklarla eşleşir</p></li><li><p><code>div[@class="appendix"]//p</code> örüntüsü <code>appendix</code> değerli bir <code>class</code> özniteliğine sahip <code>div</code> üstseli olan herhangi bir <code>p</code> elemanıyla eşleşir</p></li><li><p><code>@*</code> örüntüsü herhangi bir öznitelikle eşleşir</p></li><li><p><code>@class</code> örüntüsü herhangi bir <code>class</code> özniteliği ile eşleşir</p></li><li><p><code>*[@class]</code> örüntüsü <code>class</code> özniteliğine sahip herhangi bir elemanla eşleşir</p></li><li><p><code>code[starts-with(normalize-space(text()), 'xsl:')]</code> örüntüsü metin düğümünün <a href="../xpath#function-normalize-space">normalleştirilmiş değeri</a> <code> 'xsl:'</code> dizgesi ile başlayan herhangi bir <code>code</code> elemanıyla eşleşir (Ç.N. - Bu örüntü, bu belirtimin XML belgesini XHTML'ye dönüştürmekte <a href="../esyntax.xsl">kullanılan örneklenimlerden birinde</a> kullanılmıştır.)</p></li></ul><p>Bir örüntünün <a href="#NT-Pattern"><code>Örüntü</code></a> sözdizimi ile eşleşmesi gerekir. Bir <a href="#NT-Pattern"><code>Örüntü</code></a>, <code>|</code> imleriyle ayrılmış konumsal yol örüntülerinden oluşur.  Bir konumsal yol örüntüsü, <a href="../xpath#steps">konumlarının</a> her birinde <code>child</code> veya <code>attribute</code> dallarının kullanıldığı bir <a href="../xpath#location-paths">konumsal yol</a>dur. <code>descendant-or-self</code> dalının kullanımının gerekli olmadığı yerlerde <code>//</code> veya <code>/</code> işleci kullanılabilir. Konumsal yol örüntüleri ayrıca, bir dizgesel sabit argümana sahip <a href="../xpath#function-id"><b><code>id</code></b></a> veya <a href="#function-key"><code class="function">key</code></a> işlev çağrıları ile başlayabilir. Bir örüntüdeki dayanaklarda da bir konumsal yoldaki <a href="../xpath#predicates">dayanaklarda</a> olduğu gibi keyfî ifadeler kullanılabilir.</p><b><i><a name="idp14025584" id="idp14025584"></a>Örüntüler</i></b><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td width="5%"><a name="NT-Pattern" id="NT-Pattern"></a><tt>[1]</tt>   </td><td width="5%"><code>Örüntü</code></td><td width="5%">   ::=   </td><td width="*"><code><a href="#NT-LocationPathPattern"><code>KonumsalYolÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| <a href="#NT-Pattern"><code>Örüntü</code></a> '|' <a href="#NT-LocationPathPattern"><code>KonumsalYolÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="5%"><a name="NT-LocationPathPattern" id="NT-LocationPathPattern"></a><tt>[2]</tt>   </td><td width="5%"><code>KonumsalYolÖrüntüsü</code></td><td width="5%">   ::=   </td><td width="*"><code>'/' <a href="#NT-RelativePathPattern"><code>GöreliYolÖrüntüsü</code></a>?</code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| <a href="#NT-IdKeyPattern"><code>IdKeyÖrüntüsü</code></a> (('/' | '//') <a href="#NT-RelativePathPattern"><code>GöreliYolÖrüntüsü</code></a>)?</code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| '//'? <a href="#NT-RelativePathPattern"><code>GöreliYolÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="5%"><a name="NT-IdKeyPattern" id="NT-IdKeyPattern"></a><tt>[3]</tt>   </td><td width="5%"><code>IdKeyÖrüntüsü</code></td><td width="5%">   ::=   </td><td width="*"><code>'id' '(' <code><a href="../xpath#NT-Literal">DizgeselSabit</a></code> ')'</code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| 'key' '(' <code><a href="../xpath#NT-Literal">DizgeselSabit</a></code> ',' <code><a href="../xpath#NT-Literal">DizgeselSabit</a></code> ')'</code></td></tr><tr valign="baseline"><td width="5%"><a name="NT-RelativePathPattern" id="NT-RelativePathPattern"></a><tt>[4]</tt>   </td><td width="5%"><code>GöreliYolÖrüntüsü</code></td><td width="5%">   ::=   </td><td width="*"><code><a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| <a href="#NT-RelativePathPattern"><code>GöreliYolÖrüntüsü</code></a> '/' <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| <a href="#NT-RelativePathPattern"><code>GöreliYolÖrüntüsü</code></a> '//' <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a></code></td></tr><tr valign="baseline"><td width="5%"><a name="NT-StepPattern" id="NT-StepPattern"></a><tt>[5]</tt>   </td><td width="5%"><code>KonumÖrüntüsü</code></td><td width="5%">   ::=   </td><td width="*"><code>
  <a href="#NT-ChildOrAttributeAxisSpecifier"><code>ÇocukVeyaÖznitelikBelirteci</code></a>
  <code><a href="../xpath#NT-NodeTest">DüğümSınaması</a></code>
  <code><a href="../xpath#NT-Predicate">Dayanak</a></code>*</code></td></tr><tr valign="baseline"><td width="5%"><a name="NT-ChildOrAttributeAxisSpecifier" id="NT-ChildOrAttributeAxisSpecifier"></a><tt>[6]</tt>   </td><td width="5%"><code>ÇocukVeyaÖznitelikBelirteci</code></td><td width="5%">   ::=   </td><td width="*"><code><code><a href="../xpath#NT-AbbreviatedAxisSpecifier">KısaKonumBelirteci</a></code></code></td></tr><tr valign="baseline"><td width="%5"></td><td width="%5"></td><td width="%5"></td><td width="*"><code>| ('child' | 'attribute') '::'</code></td></tr></tbody></table><p>Bir örüntünün bir düğümle eşleşmesi için gerek ve yeter koşul, örüntünün bir ifade olarak değerlendirildiği olası bir bağlamda, düğümün bu değerlendirme sonucunda elde edilen düğüm kümesinin bir üyesi olmasıdır. Bir düğüm eşleştiği takdirde, olası bağlamlar, bu düğümün veya bir üstselinin eşleştiği bir bağlamsal düğüme ve bu bağlamsal düğümü içeren bir bağlamsal düğüm listesine sahip bağlamlar olur.</p><p>Örneğin, <code>p</code> örüntüsü herhangi bir <code>p</code> elemanı ile eşleşir; <code>p</code> ifadesi, bağlamsal düğüm olarak <code>p</code>'nin ebeveyni ile değerlendirilirse, elde edilen düğüm kümesi <code>p</code> elemanını üyesi olarak içerecektir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bu örüntü, <code>p</code> elemanı belge elemanı olsa bile elemanla eşleşir, çünkü belge elemanının ebeveyni kök düğümdür.<p></p></dd></dl><p>Örüntülerin anlambilgisi dolaylı olarak ifade değerlendirme kuralları ile belirtiliyor olsa da, bir örüntünün ne anlam geldiğini ifade değerlendirme kurallarıyla düşünmeksizin doğrudan doğruya anlamak daha kolaydır. Bir örüntüde <code>|</code> imi seçenekleri belirtir; eğer bir örüntüde bir veya daha fazla sayıda <code>|</code> imi ile ayrılmış seçenek varsa, seçeneklerden birinin eşleşmesi halinde örüntü eşleşmiş olur.</p><p><code>/</code> veya <code>//</code> ayraçları ile ayrılmış çok sayıda <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a>den oluşmuş bir örüntü sağdan sola doğru eşleşir. Örüntünün eşleşmesi için en sağdaki <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a>nün düğümle eşleşip örüntünün kalanının da uygun bir elemanla eşleşmesi yeterlidir; uygun eleman, ayraç olarak <code>//</code> kullanılmışsa düğümün üstsellerden biri, <code>/</code> kullanılmışsa düğümün ebeveyni olacaktır.</p><p>Çocuk dal kullanan bir <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a>, eğer <code><a href="../xpath#NT-NodeTest">DüğümSınaması</a></code>nın sonucu düğüm için doğruysa ve düğüm bir öznitelik düğümü ise eşleşir.</p><p>İfade <code>[]</code> içerdiği takdirde, <a href="#NT-StepPattern"><code>KonumÖrüntüsü</code></a>ndeki ilk <code><a href="../xpath#NT-PredicateExpr">Dayanakİfadesi</a></code> bağlamsal düğüm olarak düğümle ve eşleştirilecek düğüm bir öznitelik düğümü olmadıkça, <code><a href="../xpath#NT-NodeTest">DüğümSınaması</a></code> bağlamsal düğüm listesi olarak bağlamsal düğümün kardeşleri ile eşleşecek şekilde değerlendirilir; eşleştirilecek düğüm bir öznitelik düğümü olduğu takdirde, bağlamsal düğüm listesi, tamamen, eşleşen öznitelikle aynı düğümde olan özniteliklerden oluşur ve bu <code><a href="../xpath#NT-NameTest">AdSınaması</a></code> ile eşleşir.</p><p>Örneğin, bu ifadenin,</p><div class="example"><pre>appendix//ulist/item[position()=1]</pre></div><p>bir düğümle eşleşmesi için gerek ve yeter koşullar şunlardır:</p><ul><li><p><code>item</code> <code><a href="../xpath#NT-NodeTest"> DüğümSınaması</a></code> düğüm için doğru olmalı ve düğüm bir öznitelik olmamalıdır; başka bir deyişle düğüm bir <code>item</code> elemanı olmalıdır.</p></li><li><p><code>position()=1 </code><code><a href="../xpath#NT-PredicateExpr"> Dayanakİfadesi</a></code>nin bağlamsal düğüm olarak düğümle ve bağlamsal düğüm listesi olarak düğümün <code>item</code> kardeşleriyle değerlendirilmesinin  sonucu doğru olmalıdır.</p></li><li><p>düğümün <code>appendix//ulist</code> ile eşleşen bir ebeveyni olmalıdır; ebeveyn, <code>appendix</code> üstsele sahip bir <code>ulist</code> elemanı ise bu doğru olacaktır.</p></li></ul><p></p></div><div class="div2"><h3><a name="idp14093232" id="idp14093232"></a>5.3 Örneklenim Kurallarının Tanımlanması</h3><a id="element-template" name="element-template"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:template</span>
  <code>match</code> = <var>örüntü</var>
  <code>name</code> = <var>nitelikli-ad</var>
  <code>priority</code> = <var>sayı</var>
  <code>mode</code> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-param">&lt;xsl:param&gt;</a>*, <var>örneklenim</var>) --&gt;
<span class="element">&lt;/xsl:template&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir örneklenim kuralı <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanı ile belirtilir. <code>match</code> özniteliği, kuralın uygulanacağı kaynak düğüm ya da düğümleri tanımlayan bir <a href="#NT-Pattern"><code>Örüntü</code></a>dür. <code>match</code> özniteliği <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanı bir <code>name</code> özniteliğine sahip olmadıkça gereklidir (<a href="#named-templates"><b>İsimli Örneklenimler</b></a> bölümüne bakınız). <code>match</code> özniteliğinin değer olarak bir <code><a href="../xpath#NT-VariableReference">DeğişkenGönderimi</a></code> içermesi bir hatadır. <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanının içeriği, örneklenim kuralı uygulandığında nesnelleşmiş olacak olan örneklenimdir.</p><p>Örneğin bir XML belge şunu içersin:</p><div class="example"><pre>Bu &lt;emph&gt;önemli&lt;/emph&gt; bir noktadır.</pre></div><p>Aşağıdaki örneklenim kuralı <code>emph</code> elemanı ile eşleşir ve <code>font-weight</code> özniteliğinin değeri <code>bold</code> olan bir <code>fo:inline-sequence</code> biçimleme nesnesini üretir.</p><div class="example"><pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:inline-sequence font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;
</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bu belgedeki örneklerde, [<a href="#XSL">XSL</a>]'de tanımlanmış olan biçimleme nesnelerinin isim-alanı olan <code>http://www.w3.org/1999/XSL/Format</code> için <code>fo:</code> öneki kullanılmıştır.<p></p></dd></dl><p>Biraz sonra açıklanacağı gibi <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanı kaynak elemanın çocuklarını peşpeşe işleyecektir.</p></div><div class="div2"><h3><a name="idp14117104" id="idp14117104"></a>5.4 Örneklenim Kurallarının Uygulanması</h3><a id="element-apply-templates" name="element-apply-templates"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:apply-templates</span>
  <code>select</code> = <var>düğüm-kümesi-ifadesi</var>
  <code>mode</code> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-sort">&lt;xsl:sort&gt;</a> | <a href="#element-with-param">&lt;xsl:with-param&gt;</a>) --&gt;
<span class="element">&lt;/xsl:apply-templates&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bu örnek bir <code>chapter</code> elemanı için bir blok oluşturup ardından çocukları işler.</p><div class="example"><pre>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p><code>select</code> özniteliğinin yokluğunda <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> yönergesi geçerli düğümün tüm çocuklarını, metin düğümleri de dahil olmak üzere işler. Bununla birlikte, <a href="#strip"><b>Boşluk Ayıklama</b></a> bölümünde belirtildiği gibi ayıklanan metin düğümleri işlenmeyecektir. Eğer bir eleman için boşluk düğümlerinin ayıklanması etkin kılınmamışsa, eleman içeriğindeki bütün boşluk karakterleri metin olarak işlenecektir ve bu bakımdan <a href="../xpath#function-position"><b><code>position</code></b></a> işlevi tarafından döndürülen bir çocuk elemanın yakınlık derecesi saptanırken, çocuk elemanların arasındaki boşluklar da sayılacaktır.</p><p><code>select</code> özniteliğinde belirtilecek bir ifadeyle, tüm çocukların değil de sadece seçilen çocukların işlenmesi sağlanabilir. <code>select</code> özniteliğinin değeri bir <a title="İfade tanımı" href="#dt-expression">ifade</a>dir. İfade bir düğüm kümesiyle sonuçlanacak şekilde değerlendirilmelidir. Seçilen düğüm kümesi, bir sıralama (<a href="#sorting"><b>Sıralama</b></a>) belirtilmemişse  belgedeki sıraya göre işlenecektir. Aşağıdaki örnekte, <code>yazar-grubu</code>'nun tüm <code>yazar</code> çocukları işlenmektedir:</p><div class="example"><pre>&lt;xsl:template match="yazar-grubu"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="yazar"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre></div><p>Aşağıdaki örnekte ise, <code>yazar-grubu</code>'nun <code>yazar</code> çocuklarının tüm <code>verilen-ad</code>'ları işlenmektedir:</p><div class="example"><pre>&lt;xsl:template match="yazar-grubu"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="yazar/verilen-ad"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre></div><p>Bu örnekte, <code>book</code>  elemanının tüm <code>heading</code> astsalları işlenir:</p><div class="example"><pre>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p>Ayrıca, geçerli düğümün astsalı olmayan elemanları da işlemek mümkündür. Bu örnekte <code>ekip</code> çocuklara ve <code>personel</code> torunlara sahip bir <code>bölüm</code> ele alınmaktadır. Bir personelin bölümü bulunmakta ve <code>bölüm</code>'ün <code>ekip</code> çocukları işleme sokulmaktadır:</p><div class="example"><pre>&lt;xsl:template match="personel"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select="name"/&gt; ismindeki çalışanımız
    &lt;xsl:apply-templates select="ancestor::bölüm/ekip"/&gt; ekibindedir.
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p>Basit bir baştan sıralama yapmak için tek bir örüntünün içinde çok sayıda <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanı kullanılabilir. Aşağıdaki örnekte iki HTML tablosu oluşturulmaktadır. İlk tablo yurtiçi satışlarla, ikinci tablo yurtdışı satışlarla doldurulmaktadır.</p><div class="example"><pre>&lt;xsl:template match="ürün"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="satışlar/yurtiçi"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="satışlar/yurtdışı"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Biri diğerinin astsalı olan iki astsalla eşleşim mümkündür. Bu özel bir durum olarak ele alınmaz: her iki astsal normal olarak işlenir. Şöyle bir kaynak belgemiz olsun:<p></p><div class="example"><pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre></div><p>Bu kuralla,</p><div class="example"><pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre></div><p>hem dış <code>div</code> hem de iç <code>div</code> işlenecektir.</p></dd></dl><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Genellikle, <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> sadece geçerli düğümün astsal düğümlerini işlemekte kullanılır. <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a>'in böyle kullanımı bitmeyen işlem döngüleriyle sonuçlanamaz. Bununla birlikte, <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> geçerli düğümün astsalları olmayan elemanları işlemek için kullanıldığında bitmeyen döngülere yol açılması olasıdır. Örnek:<p></p><pre class="error">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre><p>Gerçeklenimler böyle döngüleri bazı durumlarda saptayabilir, fakat bir biçembentin bir gerçeklenimin saptayamadığı bitmeyen döngülere girme olasılığı mevcuttur. Bu bir hizmet reddi şeklinde bir güvenlik açığını yol açabilir.</p></dd></dl><p></p></div><div class="div2"><h3><a name="conflict" id="conflict"></a>5.5 Şablon Kuralları için Uyuşmazlıkların Çözümlenmesi</h3><p>Bir kaynak düğümün birden fazla örneklenim kuralı ile eşleşmesi olasıdır.Kullanılacak örneklenim kuralı şöyle belirlenir:</p><ol class="enumar"><li><p>Önce tüm eşleşen kurallardan düşük <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ne sahip olanlar elenir.</p></li><li><p>Sonra, kalan eşleşen kurallardan düşük işlem önceliğine sahip olanlar elenir. Bir örneklenim kuralının işlem önceliği o örneklenim kuralı üzerinde <code>priority</code> özniteliği ile belirtilir. Değeri bir gerçel sayı (pozitif veya negatif) olmalı ve isteğe bağlı bir eksi imi (<code>-</code>) ile öncelenmiş olarak <code><a href="../xpath#NT-Number">Sayı</a></code> sözdizimi ile eşleşmelidir. <a name="dt-default-priority" id="dt-default-priority" title="Öntanımlı İşlem Önceliği"></a><span title="Öntanımlı İşlem Önceliği tanımı" class="termdef"><b>Öntanımlı işlem önceliği</b> şöyle hesaplanır:</span></p><ul><li><p>Eğer bir örüntü <code>|</code> imleri le birbirlerinden ayrılmış çok sayıda seçenek içeriyorsa, bunların her birinin işlem önceliği bir diğerine denk ele alınır.</p></li><li><p>Eğer bir örüntü önüne bir <a href="#NT-ChildOrAttributeAxisSpecifier"><code>ÇocukVeyaÖznitelikBelirteci</code></a> getirilmiş bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> ya da önüne bir <a href="#NT-ChildOrAttributeAxisSpecifier"><code>ÇocukVeyaÖznitelikBelirteci</code></a> getirilmiş <code>processing-instruction(</code><code><a href="../xpath#NT-Literal">DizgeselSabit</a></code><code>)</code> biçiminde ise işlem önceliği 0'dır.</p></li><li><p>Eğer bir örüntü önüne bir <a href="#NT-ChildOrAttributeAxisSpecifier"><code>ÇocukVeyaÖznitelikBelirteci</code></a> getirilmiş bir <code><a href="../xml-names#NT-NCName">KısaAd</a></code><code>:*</code> biçiminde ise işlem önceliği -0.25'tir.</p></li><li><p>Aksi takdirde, eğer bir örüntü önüne bir <a href="#NT-ChildOrAttributeAxisSpecifier"><code>ÇocukVeyaÖznitelikBelirteci</code></a> getirilmiş bir <code><a href="../xpath#NT-NodeTest">DüğümSınaması</a></code> biçimindeyse işlem önceliği -0.5'tir.</p></li><li><p>Aksi takdirde, işlem önceliği 0.5'tir.</p></li></ul><p>Bu bakımdan, en bilinen örüntü çeşidinin (bir düğümü belli bir tür veya  genişletilmiş isimle sınayan) işlem önceliği 0'dır. Sonraki en özel örüntü çeşidinin (bir düğümü belli bir isim-alanındaki belli bir tür veya genişletilmiş isimle sınayan) işlem önceliği -0.25'tir. Bundan daha az özel (düğümleri sadece belli bir türle sınayan) örüntülerin işlem önceliği -0.5'tir. En bilinen örüntü çeşidinden daha özel örüntülerin işlem önceliği ise 0.5'tir.</p></li></ol><p>Eğer bu elemeden geriye birden fazla eşleşmiş örneklenim kuralı kalıyorsa bu bir hatadır. Bir XSLT işlemci hatayı raporlayabilir; eğer raporlamıyorsa, kalanlardan biçembentte daha sonlarda yer alan örneklenim kuralını seçerek hatadan kurtulmalıdır.</p></div><div class="div2"><h3><a name="apply-imports" id="apply-imports"></a>5.6 Örneklenim Kurallarının Geçerli Kılınması</h3><a id="element-apply-imports" name="element-apply-imports"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:apply-imports /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>İthal edilmiş bir biçembentteki bir örneklenim kuralını geçersiz kılmak için kullanılmış bir örneklenim kuralı (bkz, <a href="#conflict"><b>Şablon Kuralları için Uyuşmazlıkların Çözümlenmesi</b></a>) geçersiz kılınan örneklenim kuralını <a href="#element-apply-imports"><span class="elemref"><tt>xsl:apply-imports</tt></span></a> elemanını kullanarak çağırabilir.</p><p><a name="dt-current-template-rule" id="dt-current-template-rule" title="Geçerli Örneklenim Kuralı"></a><span title="Geçerli Örneklenim Kuralı tanımı" class="termdef">Bir biçembentin işlenmesi sırasında, herhangi bir anda tek bir <b>geçerli örneklenim kuralı</b> vardır. Bir örneklenim kuralı örüntü eşleştirerek her seçilişinde, kuralın örnekleniminin nesnelleştirilmesi için geçerli örneklenim kuralı haline gelir. Bir <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanı işleme sokulduğunda geçerli örneklenim kuralı <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanının içeriğinin nesnelleştirilmesi için tanımsız hale gelir.</span></p><p><a href="#element-apply-imports"><span class="elemref"><tt>xsl:apply-imports</tt></span></a> elemanı sadece, geçerli örneklenim kuralını içeren biçembente ithal edilmiş olan örneklenim kuralının kullanılarak geçerli düğümün işlenmesini sağlar; düğüm geçerli örneklenim kuralının kipinde işlenir. Geçerli örneklenim kuralı tanımsızken <a href="#element-apply-imports"><span class="elemref"><tt>xsl:apply-imports</tt></span></a> nesnelleştirme için kullanılmaya çalışılırsa bu bir hatadır.</p><p>Örneğin, <code>doc.xsl</code> biçembenti <code>example</code> elemanları için şöyle bir örneklenim kuralı içeriyor olsun:</p><div class="example"><pre>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</pre></div><p>Başka bir biçembent de <code>doc.xsl</code>'i ithal edip <code>example</code> elemanını şöyle ele alıyor olsun:</p><div class="example"><pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre></div><p>Dönüşümün birleşik etkisi bir <code>example</code> elemanını şu biçime getirir:</p><div class="example"><pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre></div><p></p></div><div class="div2"><h3><a name="modes" id="modes"></a>5.7 Kipler</h3><p>Kipler bir elemanın her seferinde farklı bir sonuç üretmek üzere defalarca işlenmesini mümkün kılar.</p><p><a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> ve <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanlarının ikisi de isteğe bağlı bir <code>mode</code> özniteliğine sahiptir. <code>mode</code> özniteliğinin değeri bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olup <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanır. Eğer bir <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanı bir <code>match</code> özniteliğine sahip değilse bir <code>mode</code> özniteliğine sahip olmamalıdır. Eğer bir <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanı bir <code>mode</code> özniteliğine sahipse sadece kendi <code>mode</code> özniteliğinin değeriyle aynı <code>mode</code> özniteliğine sahip <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanlarındaki örneklenim kuralları uygulanır; eğer bir <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanı bir <code>mode</code> özniteliğine sahip değilse sadece <code>mode</code> özniteliğine sahip olmayan <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanlarındaki örneklenim kuralları uygulanır.</p></div><div class="div2"><h3><a name="built-in-rule" id="built-in-rule"></a>5.8 Yerleşik Örneklenim Kuralları</h3><p>Biçembentte örtük bir örneklenim kuralıyla eşleşen başarılı bir örüntünün yokluğunda işlemlerin ardışık olarak sürmesini sağlayan bir yerleşik örneklenim kuralı vardır. Bu örneklenim kuralı hem eleman düğümlerine hem de kök düğüme uygulanır. Yerleşik örneklenim kuralının eşdeğeri şöyle birşey olurdu:</p><div class="example"><pre>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div><p>Ayrıca, her kip için de benzer şekilde, biçembentte örtük bir örneklenim kuralıyla eşleşen başarılı bir örüntünün yokluğunda işlemlerin ardışık olarak sürmesini sağlayan bir yerleşik örneklenim kuralı vardır. Bu örneklenim kuralı hem eleman düğümlerine hem de kök düğüme uygulanır. Örneğin, <var>m</var> kipi için yerleşik örneklenim kuralının eşdeğeri şöyle birşey olurdu:</p><div class="example"><pre>&lt;xsl:template match="*|/" mode="<var>m</var>"&gt;
  &lt;xsl:apply-templates mode="<var>m</var>"/&gt;
&lt;/xsl:template&gt;</pre></div><p>Ayrıca, metin ve öznitelik düğümleri için metinlerin kopyalanmasını sağlayan bir yerleşik örneklenim kuralı vardır:</p><div class="example"><pre>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre></div><p>İşlem yönergeleri ve açıklamalar için olan yerleşik örneklenim kuralı hiçbir şey yapmaz:</p><div class="example"><pre>&lt;xsl:template match="processing-instruction()|comment()"/&gt;</pre></div><p>İsim-alanı düğümleri için olan yerleşik örneklenim kuralı da hiçbir şey yapmaz. Bir isim-alanı düğümüyle eşleşen bir örüntü olmayacağı için isim-alanı düğümlerine uygulanan yegane örneklenim kuralı bu yerleşik örneklenim kuralıdır.</p><p>Yerleşik örneklenim kuralları biçembentten önce örtük olarak ithal edilmişler gibi ele alınırlar, dolayısıyla tüm diğer örneklenim kurallarından daha düşük <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ne sahip olurlar. Bu bakımdan biçembent yazarları bir yerleşik örneklenim kuralını biçimbente açıkça bir örneklenim kuralı ekleyerek geçersiz kılabilirler.</p></div></div><div class="div1"><h2><a name="named-templates" id="named-templates"></a>6 İsimli Örneklenimler</h2><a id="element-call-template" name="element-call-template"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:call-template</span>
  <b>name</b> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <a href="#element-with-param">&lt;xsl:with-param&gt;</a>* --&gt;
<span class="element">&lt;/xsl:call-template&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Örneklenimler isimleriyle çağrılabilirler. Bir <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanı bir <code>name</code> özniteliği ile birlikte bir isimli örneklenim belirtir. <code>name</code> özniteliğinin değeri bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olup <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanır. Bir <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanının <code>name</code> özniteliğine ek olarak bir de <code>match</code> özniteliği  olabilir ama bu gerekli değildir. <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> elemanı bir  örneklenimi ismiyle çağırmak için kullanılır; çağrılacak örneklenimi belirtmek için <code>name</code> özniteliğinin kullanımı zorunludur. <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanının aksine, <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> geçerli düğümü veya geçerli düğüm listesini değiştirmez.</p><p>Bir <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> elemanı tarafından çağrıldığında <code>match</code>, <code>mode</code> ve <code>priority</code> özniteliklerinin <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> üzerinde bir etkisi yoktur. Benzer şekilde, <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanı <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanı tarafından çağrıldığında <code>name</code> özniteliğinin bir önemi yoktur.</p><p>Bir biçembentin aynı <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ne sahip birden fazla aynı isimde örneklenime sahip olması bir hatadır.</p></div><div class="div1"><h2><a name="rtree" id="rtree"></a>7 Hedef Ağacın Oluşturulması</h2><p>Bu bölümde hedef ağaç üzerinde düğümleri doğrudan oluşturan yönergeler açıklanmaktadır.</p><div class="div2"><h3><a name="idp14242320" id="idp14242320"></a>7.1 Elemanların ve Özniteliklerin Oluşturulması</h3><div class="div3"><h4><a name="literal-result-element" id="literal-result-element"></a>7.1.1 Birebir Hedef Elemanlar</h4><p>Bir örneklenimde, XSLT isim-alanına ait olmadığı gibi bir ek eleman da (bkz, <a href="#extension-element"><b>Eklenti Elemanlar</b></a>) olmayan bir eleman aynı <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>le bir eleman düğümü oluşturmak üzere nesnelleştirilir. Elemanın içeriği, oluşturulan eleman düğümünün içeriğini vermek için nesnelleştiren bir örneklenimdir. Oluşturulan eleman düğümü, biçembent ağacındaki eleman düğümünde mevcut ancak isimleri XSLT isim-alanından olmayan öznitelik düğümlerine sahip olacaktır.</p><p>Oluşturulan eleman düğümü, ayrıca biçembent ağacındaki eleman düğümünde mevcut olan isim-alanı düğümlerinin bir kopyasına sahip olacaktır; kopyanın içinde, dizgesel değeri XSLT isim-alanı tanım-yeri (<code>http://www.w3.org/1999/XSL/Transform</code>), eklenti isim-alanı olarak bildirilmiş bir isim-alanı tanım-yeri (bkz, <a href="#extension-element"><b>Eklenti Elemanlar</b></a>) veya dışlanmış bir isim-alanı olarak belirtilmiş bir isim-alanı tanım-yeri olan isim-alanı düğümleri olmayacaktır. Bir isim-alanı tanım-yeri, <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının <code>exclude-result-prefixes</code> özniteliği veya birebir hedef elemanın <tt>xsl:exclude-result-prefixes</tt> özniteliği kullanılarak, dışlanmış bir isim-alanı olarak belirtilir. Bu özniteliklerin ikisinin de değeri boş karakter ayraçlı isim-alanı önekleri listesidir. Öneklerin her birine bağlı isim-alanları birer dışlanmış isim-alanı olarak belirtilmiş olur. <code>exclude-result-prefixes</code> veya <tt>xsl:exclude-result-prefixes</tt> özniteliğini taşıyan eleman üzerinde öneke bağlı bir isim-alanının olmayışı bir hatadır. Öntanımlı isim-alanı, isim-alanı önekleri listesine <code>#default</code> dizgesi dahil edilerek dışlanmış bir isim-alanı olarak belirtilebilir. Bir isim-alanının dışlanmış bir isim-alanı olarak atanması, <code>exclude-result-prefixes</code> veya <tt>xsl:exclude-result-prefixes</tt> özniteliğini taşıyan eleman biçembendin kök düğümü olmak üzere, biçembentin alt ağacı içinde etkilidir; kökü bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanı olan bir alt ağaç, <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının çocukları tarafından içerilmiş veya ithal edilmiş bir biçembent içermez.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir biçembent, bir isim-alanı bildirimini sadece kaynak ağacını adreslemek amacıyla kullandığı zaman, önekin <code>exclude-result-prefixes</code> özniteliğinde belirtilmesi hedef ağaçta gereksiz isim-alanı bildirimlerini ortadan kaldıracaktır.<p></p></dd></dl><p>Bir birebir hedef elemanın bir özniteliğinin değeri bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır: kaşlı ayraçlar (<code>{}</code>) içinde belirtilmiş ifadeler içerir.</p><p><a name="dt-literal-namespace-uri" id="dt-literal-namespace-uri" title="Birebir İsim-alanı Tanım-yeri"></a><span title="Birebir İsim-alanı Tanım-yeri tanımı" class="termdef">Biçembent ağacında, hedef ağaçta bir isim-alanı tanım-yeri belirtmek için kullanılan bir isim-alanı tanım-yerine <b>birebir isim-alanı tanım-yeri</b> denir.</span> Bu şunlara uygulanır:</p><ul><li><p>biçembentte bir birebir hedef elemanın genişletilmiş isminde bir isim-alanı tanım-yerine,</p></li><li><p>biçembentte bir birebir hedef elemanında belirtilen bir özniteliğin genişletilmiş isminde bir isim-alanı tanım-yerine,</p></li><li><p>biçembentte bir birebir hedef elemanındaki bir isim-alanı düğümünün dizgesel değerine.</p></li></ul><p></p><a id="element-namespace-alias" name="element-namespace-alias"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:namespace-alias</span>
  <b>stylesheet-prefix</b> = <var>önek</var> | "#default"
  <b>result-prefix</b> = <var>önek</var> | "#default"<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a name="dt-alias" id="dt-alias" title="Takma ad"></a><span title="Takma ad tanımı" class="termdef">Bir biçembent <a href="#element-namespace-alias"><span class="elemref"><tt>xsl:namespace-alias</tt></span></a> elemanını başka bir isim-alanı tanım-yeri için <b>takma ad</b> olan bir isim-alanı tanım yerini bildirmek için kullanabilir</span>. Bir <a title="Birebir İsim-alanı Tanım-yeri tanımı" href="#dt-literal-namespace-uri">birebir isim-alanı tanım-yeri</a> başka bir isim-alanı tanım-yeri için bir takma ad olarak bildirildiğinde, hedef ağaçtaki isim-alanı tanım-yeri, birebir isim-alanı tanım-yerinin kendisi için değil onun için bir takma ad olacağı isim-alanı tanım-yeri olacaktır. <a href="#element-namespace-alias"><span class="elemref"><tt>xsl:namespace-alias</tt></span></a> elemanı, <code>result-prefix</code> özniteliği tarafından belirtilen öneke bağlı isim-alanı tanım-yeri için bir takma ad olan <code>stylesheet-prefix</code> özniteliği tarafından belirtilen öneke bağlı isim-alanı tanım-yerini bildirir. Bu bakımdan, <code>stylesheet-prefix</code> özniteliği biçembentte görünecek isim-alanı tanım-yerini, <code>result-prefix</code> özniteliği ise hedef ağaçta görünecek diğerinin karşılığı olan isim-alanı tanım-yerini belirtir. Öntanımlı isim-alanı (<code>xmlns</code> ile bildirilen) bir önek yerine <code>#default</code> kullanılarak belirtilebilir. Eğer bir isim-alanı tanım-yeri çok sayıda isim-alanı tanım-yeri için bir takma ad olarak bildirilmişse <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a> en yüksek bildirim kullanılır. Birden fazla böyle bildirim olması bir hatadır. Bir XSLT işlemci hatayı bildirebilir; eğer bildirmiyorsa, en yüksek ithal öncelikli bildirimler arasından biçembendin sonlarına doğru yer alan birini seçerek hatadan kurtulmalıdır.</p><p>Birebir hedef elemanlar XSLT isim-alanı tanım-yerini kullanan eleman, öznitelik veya isim-alanı düğümleri oluşturmak için kullanıldıklarında, biçembendin bir takma ad kullanması gerekir. Örneğin,</p><div class="example"><pre>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>biçembendi aşağıdaki biçimdeki bir belgeden bir biçembent üretecektir:</p><div class="example"><pre>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XSLT isim-alanı tanım-yerinden başka isim-alanları için de takma adlar kullanmak gerekli olabilir. Örneğin, sayısal imzalarla iş yapılan bir isim-alanına ait olan birebir sonuç elemanlar, XSLT biçembentlerinin genel amaçlı güvenlik yazılımları tarafından kötü kullanımına sebep olabilir; isim-alanı için bir takma ad kullanımı böyle bir kötü kullanım olasılığını ortadan kaldıracaktır.<p></p></dd></dl><p></p></div><div class="div3"><h4><a name="idp14285696" id="idp14285696"></a>7.1.2 Elemanların <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> ile Oluşturulması</h4><a id="element-element" name="element-element"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:element</span>
  <b>name</b> = { <var>nitelikli-ad</var> }
  <code>namespace</code> = { <var>tanım-yeri-başvurusu</var> }
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:element&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> elemanı hesaplanmış bir isimle bir eleman oluşturmayı mümkün kılar. Oluşturulacak elemanın <a href="../xpath#dt-expanded-name">genişletilmiş ismi</a>, zorunlu olan <code>name</code> ile seçimlik olan <code>namespace</code> öznitelikleri ile belirtilir. <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> elemanının içeriği oluşturulan elemanın çocukları ve öznitelikleri için bir örneklenimdir.</p><p><code>name</code> özniteliği bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizgenin bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmaması bir hatadır.  Bir XSLT işlemci hatayı raporlayabilir; raporlamıyorsa, <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> elemanının nesnelleştirilmesinin sonucunu, baştaki öznitelik düğümleri hariç, <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> elemanının içeriğinin nesnelleştirilmesiyle oluşturulan düğüm silsilesi yaparak hatayı ortadan kaldırmalıdır. <code>namespace</code> özniteliği kullanılmamışsa, <code><a href="../xml-names#NT-QName">NitelAd</a></code>, <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> elemanı için etkili olan isim-alanı bildirimleri (öntanımlı isim-alanı bildirimi dahil) kullanılarak bir genişletilmiş isme genişletilir.</p><p>Eğer <code>namespace</code> özniteliği kullanılmışsa, o da ayrıca bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizge bir tanım-yeri başvurusu olmalıdır. Dizgenin sözdizimsel olarak geçerli bir tanım-yeri başvurusu olmaması bir hata değildir. Eğer dizge boşsa, elemanın genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahip olur. Aksi takdirde, dizge, oluşturulan elemanın genişletilmiş isminin isim-alanı tanım-yeri olarak kullanılır. <code><a href="../xml-names#NT-QName">NitelAd</a></code>'ın yerel kısmı, oluşturulan elemanın genişletilmiş isminin yerel kısmı olarak kullanılan <code>name</code> özniteliği tarafından belirtilir.</p><p>XSLT işlemciler, oluşturulan elemanın XML olarak çıktılanması için kullanılan öneki seçerken, <code>name</code> özniteliğinde belirtilen <code><a href="../xml-names#NT-QName">NitelAd</a></code>ın önekini kullanılır yapabilirler; yine de,bunun böyle olması gerekli değildir.</p></div><div class="div3"><h4><a name="creating-attributes" id="creating-attributes"></a>7.1.3 Özniteliklerin <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> ile Oluşturulması</h4><a id="element-attribute" name="element-attribute"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:attribute</span>
  <b>name</b> = { <var>nitelikli-ad</var> }
  <code>namespace</code> = { <var>tanım-yeri-başvurusu</var> }<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:attribute&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanı biçembentteki birebir hedef elemanlar veya <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> gibi yönergeler tarafından oluşturulan hedef elemanlara öznitelikler eklemek için kullanılır. Özniteliğin <a href="../xpath#dt-expanded-name">genişletilmiş ismi</a> belirtilmesi zorunlu <code>name</code> özniteliği ile seçimlik <code>namespace</code> özniteliği tarafından oluşturulur. Bir <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanının nesnelleştirilmesi, hedef eleman düğümüne bir öznitelik düğümü ekler. <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanının içeriği oluşturulan özniteliğin değeri için bir örneklenimdir.</p><p><code>name</code> özniteliği bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizgenin bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmaması veya <code>xmlns</code> dizgesi olması bir hatadır. Bir XSLT işlemci hatayı raporlayabilir; raporlamıyorsa, özniteliği hedef ağaca eklemeyerek hatayı ortadan kaldırmalıdır. <code>namespace</code> özniteliği kullanılmamışsa, <code><a href="../xml-names#NT-QName">NitelAd</a></code>, <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanı için etkili olan isim-alanı bildirimleri (öntanımlı isim-alanı bildirimi hariç) kullanılarak bir genişletilmiş isme genişletilir.</p><p>Eğer <code>namespace</code> özniteliği kullanılmışsa, o da ayrıca bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizge bir tanım-yeri başvurusu olmalıdır. Dizgenin sözdizimsel olarak geçerli bir tanım-yeri başvurusu olmaması bir hata değildir. Eğer dizge boşsa, özniteliğin genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahip olur. Aksi takdirde, dizge, oluşturulan özniteliğin genişletilmiş isminin isim-alanı tanım-yeri olarak kullanılır. <code><a href="../xml-names#NT-QName">NitelAd</a></code>'ın yerel kısmı, oluşturulan özniteliğin genişletilmiş isminin yerel kısmı olarak kullanılan <code>name</code> özniteliği tarafından belirtilir.</p><p>XSLT işlemciler, oluşturulan özniteliğin XML olarak çıktılanması için kullanılan öneki seçerken, <code>name</code> özniteliğinde belirtilen <code><a href="../xml-names#NT-QName">NitelAd</a></code>ın önekini kullanılır yapabilirler; yine de,bunun böyle olması gerekli değildir. Bu bakımdan,</p><div class="example"><pre>&lt;xsl:attribute name="xmlns:xsl" namespace="herneyse"&gt;
  http://www.w3.org/1999/XSL/Transform
&lt;/xsl:attribute&gt;</pre></div><p>hatalı olmasa da, bu işlem çıktıda bir isim-alanı bildirimi ile sonuçlanmayacaktır.</p><p>Bir özniteliğin bir elemana eklenmesi elemanın mevcut özniteliklerinden  genişletilmiş ismi aynı olanını değiştirir.</p><p>Aşağıdakilerin hepsi hata ile sonuçlanır:</p><ul><li><p>Bir elemana çocukları eklendikten sonra bir özniteliğin eklenmesi; gerçeklenimler bu hatayı bildirebilir ya da özniteliği yoksayabilirler.</p></li><li><p>Bir özniteliğin bir eleman olmayan bir düğüme eklenmesi; gerçeklenimler bu hatayı bildirebilir ya da özniteliği yoksayabilirler.</p></li><li><p><a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanının nesnelleştirilmesi sırasında metin düğümlerinden farklı düğümlerin oluşturulması; gerçeklenimler bu hatayı bildirebilir ya da hatalı düğümleri içerikleriyle birlikte yoksayabilirler.</p></li></ul><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanı satırsonu içeren bir metin düğümü içeriyorsa, XML çıktının bir karakter gönderimi içermesi gerekir. Örneğin,<p></p><div class="example"><pre>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</pre></div><p>kodu şu çıktıyı üretecektir:</p><div class="example"><pre>a="x&amp;#xA;y"</pre></div><p>(veya eşdeğeri bir karakter gönderimi ile). XML çıktı asla şöyle olamaz:</p><div class="example"><pre>a="x
y"</pre></div><p>XML 1.0'ın öznitelik değerlerindeki satırsonu karakterlerini boşluk olarak normalleştirmesi fakat satır sonu karakterlerine yapılan gönderimleri normalleştirmemesi sebebiyle bu böyledir. Veri modelindeki öznitelik değerleri normalleştirme sonrası öznitelik değerleri olarak gösterilir. Eğer bir satırsonu karakteri çıktılanan ağaçtaki bir öznitelik değerinde bir karakter gönderimi olarak değilde kendisi olarak yer alıyorsa, ağaçtaki öznitelik değeri bir satırsonu değil de bir boşluk içerecek şekilde XML'in yeniden çözümlenerek ağacın doğru olarak çıktılanması gerekir.</p></dd></dl><p></p></div><div class="div3"><h4><a name="attribute-sets" id="attribute-sets"></a>7.1.4 İsimli Öznitelik Kümeleri</h4><a id="element-attribute-set" name="element-attribute-set"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:attribute-set</span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <a href="#element-attribute">&lt;xsl:attribute&gt;</a>* --&gt;
<span class="element">&lt;/xsl:attribute-set&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanı bir isimli öznitelik kümesi tanımlar. <code>name</code> özniteliği öznitelik kümesinin ismini belirtir. <code>name</code> özniteliğinin değeri bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olup <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanır. <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanının içeriği kümedeki öznitelikleri belirten sıfır veya daha fazla sayıda <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanından oluşur.</p><p>Öznitelik kümeleri, bir <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a>, <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> (bkz, <a href="#copying"><b>Kopyalama</b></a>) veya <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanının <code>use-attribute-sets</code> özniteliğinde belirtilerek kullanılırlar. <code>use-attribute-sets</code> özniteliğinin değeri öznitelik kümesi isimlerinin boşluk ayraçlı listesidir. Belirtilen her isim, <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanan birer <code><a href="../xml-names#NT-QName">NitelAd</a></code> olarak belirtilir. Bir <code>use-attribute-sets</code> özniteliğinin belirtilmesi, özniteliğe sahip elemanın içeriğinin başlangıcında isimli öznitelik kümelerinin her birindeki özniteliklerin her biri için (<code>use-attribute-sets</code> özniteliğinde belirtilen öznitelik isimleriyle aynı sırada) bir <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanı belirtilmesine eşdeğerdir. <code>use-attribute-sets</code> özniteliklerinin <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanlarında doğrudan veya dolaylı olarak kendilerini öznitelik kümesi olarak kullanmaları bir hatadır.</p><p>Öznitelik kümeleri ayrıca bir birebir hedef elemanda da bir <tt>xsl:use-attribute-sets</tt> özniteliği belirterek kullanılabilir. <tt>xsl:use-attribute-sets</tt> özniteliğinin değeri öznitelik kümesi isimlerinin boşluk ayraçlı bir listesidir. <tt>xsl:use-attribute-sets</tt> özniteliği tarafından belirtilen <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanlarından sonra ama asıl <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanlarından önce yer alan <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanları tarafından belirtilmiş gibi ele alınan birebir hedef elemanın kendi üzerindeki öznitelikler tarafından belirtilen ek kurallarla birlikte <a href="#element-element"><span class="elemref"><tt>xsl:element</tt></span></a> üzerindeki <code>use-attribute-sets</code> özniteliği ile <tt>xsl:use-attribute-sets</tt> özniteliği aynı etkiye sahiptir. Bu bakımdan, bir birebir hedef eleman için, bir <tt>xsl:use-attribute-sets</tt> özniteliğinde isimleri bulunan öznitelik kümelerindeki öznitelikler önce (ama kümelerin listede yer alış sırasına uygun olarak) eklenecektir; ardından birebir hedef elemanda belirtilen öznitelikler eklenecek; son olarak da, <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanları tarafından belirtilen öznitelikler eklenecektir. Bir özniteliğin bir elemana eklenmesi, bu elemanın aynı isimdeki mevcut özniteliğini değiştirdiğinden, bu, öznitelik kümelerinde belirtilen öznitelikler, birebir hedef elemanın kendisinde belirtilen öznitelikler tarafından geçersiz kılınabilirler anlamına gelir.</p><p>Bir <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanınındaki  <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanlarının her birindeki örneklenimler, öznitelik kümesinin her kullanılışında yeniden nesnelleştirilir; nesnelleştirme, aynı geçerli düğüm ve geçerli düğüm listesi kullanılarak, nesnelleştirme için <code>use-attribute-sets</code> veya <tt>xsl:use-attribute-sets</tt> özniteliğini taşıyan eleman kullanılıyormuş gibi yapılır. Bununla birlikte, hangi değişken bağıntısının görünür (bkz, <a href="#variables"><b>Değişkenler ve Değergeçler</b></a>) olduğunu belirleyen <code>use-attribute-sets</code> veya <tt>xsl:use-attribute-sets</tt> özniteliğini taşıyan elemandan ziyade biçembentteki <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanının konumudur; bu bakımdan, sadece <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve
<a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanları ile bildirilen değişken ve değergeçler görünürdür.</p><p>Aşağıdaki örnekte <code>title-style</code> isimli bir öznitelik kümesi oluşturulmakta ve bir örneklenim kuralında kullanılmaktadır:</p><div class="example"><pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block quadding="start" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre></div><p>Bir özniteliğin aynı genişletilmiş isimle çok sayıda tanımı varsa bunlar birleştirilir. Yüksek <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ne sahip bir öznitelik, düşük <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ndeki bir özniteliğe göre önceliklidir. Aynı genişletilmiş isimle aynı özniteliği içeren iki öznitelik kümesinin, aynı genişletilmiş isim ve aynı öznitelikle daha yüksek <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal öncelikli</a> bir üçüncünün yokluğunda aynı ithal önceliğine sahip olması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, biçembentin sonuna doğru yer alan tanımlar arasından daha yüksek işlem önceliğine sahip olanını seçerek hatayı ortadan kaldırabilir. Bir öznitelik kümesinde belirtilen özniteliklerin yeri kümedeki öznitelikler bir birleşmeye konu olduklarında önem kazanır; öznitelik kümeleri kullanılırken bunun bir önemi yoktur. Bir <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanının <code>use-attribute-sets</code> özniteliğinde yer alan her öznitelik kümesi ismi için, aynı isimdeki bir öznitelik kümesinin bütün tanımlarının, <code>use-attribute-sets</code> özniteliği, eşdeğeri olan <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> çocuk elemanlarıyla değiştirilmeden önce birleştirilmesi gerekir. Bir <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanının <code>use-attribute-sets</code> özniteliğinin eşdeğeri olan <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> çocuk elemanlarıyla, bu <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanı, aynı genişletilmiş isimli başka bir <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a> elemanı ile birleştirilmeden önce değiştirilmesi gerekir. <a href="#element-attribute-set"><span class="elemref"><tt>xsl:attribute-set</tt></span></a>  elemanları aynı genişletilmiş isimli olanlarla birleştirildiğinde, bir <code>use-attribute-sets</code> özniteliğine değiştirilmek için eklenen her <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> çocuk elemanı, biçembentte gerçekten bir çocuk eleman olarak belirtilmiş gibi ele alınır.</p></div></div><div class="div2"><h3><a name="idp14400704" id="idp14400704"></a>7.2 Metin Oluşturma</h3><p>Bir örneklenim ayrıca metin düğümleri de içerebilir. Bir örneklenimdeki her metin düğümünün boşluk karakterleri <a href="#strip"><b>Boşluk Ayıklama</b></a> bölümünde belirtildiği gibi ayıklandıktan sonra kalan dizgeyle hedef ağaçtaki metin düğümü oluşturulur. Bitişik metin düğümleri hedef ağaçta kendiliğinden birleşir.</p><p>Metnin ağaç seviyesinde işlendiğine dikkat ediniz. Bu bakımdan, bir örneklenimdeki <code>&amp;lt;</code> imlenimi biçembent ağacında <code>&lt;</code> karakterini içeren bir metin düğümüyle gösterilecektir. Bu, hedef ağaç bir XML belge olarak çıktılandığında,  hedef ağaçta (<code>&amp;lt;</code> imlenimi -veya eşdeğeri karakter gönderimi- ile gösterilecek olan) <code>&lt;</code> karakterini içeren bir metin düğümü oluşturacaktır (<a href="#disable-output-escaping"><b>Çıktı Önceleniminin İptal Edilmesi</b></a> bölümünde belirtildiği gibi çıktı öncelenimi iptal edilmiş olmadıkça).</p><a id="element-text" name="element-text"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:text</span>
  <code>disable-output-escaping</code> = "yes" | "no"<span class="element"> &gt;</span>
  &lt;!-- İçeriği: #PCDATA --&gt;
<span class="element">&lt;/xsl:text&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Dizgesel sabit veri karakterleri bir <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> elemanında satır katlamaya konu olabilir. Satır katlama, boşluk karakterleri ayıklanarak (bkz, <a href="#strip"><b>Boşluk Ayıklama</b></a>) değiştirilebilir fakat karakterlerin XSLT işlemci tarafından sonradan nasıl elde edileceğine bir etkisi yoktur.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd><code>xml:lang</code> ve <code>xml:space</code> öznitelikleri XSLT tarafından özel olarak ele alınmaz. Özellikle,<p></p><ul><li>hedefte, <code>xml:lang</code> veya <code>xml:space</code> özniteliklerinin üretmesi gerekeni belirtmek doğrudan doğruya biçembent yazarının sorumluluğundadır;<p></p></li><li>XSLT isim-alanındaki bir elemanda <code>xml:lang</code> veya <code>xml:space</code> özniteliğinin belirtilmesi bu özniteliklerin hedefte de yer almasına sebep olmayacaktır.<p></p></li></ul><p></p></dd></dl><p></p></div><div class="div2"><h3><a name="idp14417616" id="idp14417616"></a>7.3 İşlem Yönergelerinin Oluşturulması</h3><a id="element-processing-instruction" name="element-processing-instruction"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:processing-instruction</span>
  <b>name</b> = { <var>kısa-ad</var> }<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:processing-instruction&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> elemanı, bir işlem yönergesi düğümü oluşturmak için nesnelleştirilir. <a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> elemanının içeriği işlem yönergesi düğümünün dizgesel değeri için bir örneklenimdir. <a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> elemanının, işlem yönergesi düğümünün ismini belirtmek için kullanımı zorunlu olan bir <code>name</code> özniteliği vardır. <code>name</code> özniteliğinin değeri bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır.</p><p>Örneğin, bu:</p><div class="example"><pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;
  href="book.css" type="text/css"
&lt;/xsl:processing-instruction&gt;</pre></div><p>şu işlem yönergesini oluşturacaktır:</p><div class="example"><pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre></div><p><code>name</code> özniteliğinin nesnelleştirilmesinin sonucu olan dizgenin hem bir <code><a href="../xml-names#NT-NCName">KısaAd</a></code> hem de bir <code><a href="../xml#NT-PITarget">PIHedefi</a></code> olmaması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, işlem yönergesini hedef ağaca ekleyerek hatayı ortadan kaldırabilir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bu, <a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> elemanının bir XML bildirimi çıktılamakta kullanılamaması demektir. Yerine <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı kullanılmalıdır (bkz, <a href="#output"><b>Çıktı</b></a>).<p></p></dd></dl><p><a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> içeriğinin nesnelleştirilmesinin metin düğümünden farklı bir düğüm oluşturması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, hatalı düğümleri içerikleriyle birlikte yoksayarak hatayı ortadan kaldırabilir.</p><p><a href="#element-processing-instruction"><span class="elemref"><tt>xsl:processing-instruction</tt></span></a> içeriğinin nesnelleştirilme sonucunun <code>?&gt;</code> dizgesini içermesi bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, <code>?</code> karakteri ile <code>&gt;</code> karakteri arasına bir boşluk yerleştirerek hatayı ortadan kaldırabilir.</p></div><div class="div2"><h3><a name="idp14439200" id="idp14439200"></a>7.4 Açıklamaların Oluşturulması</h3><a id="element-comment" name="element-comment"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:comment&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:comment&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-comment"><span class="elemref"><tt>xsl:comment</tt></span></a> elemanı hedef ağaçta bir açıklama oluşturmak için nesnelleştirilir. <a href="#element-comment"><span class="elemref"><tt>xsl:comment</tt></span></a> elemanının içeriği, açıklama düğümünün dizgesel değeri için bir örneklenimdir.</p><p>Örneğin, bu:</p><div class="example"><pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre></div><p>şu açıklamayı üretecektir:</p><div class="example"><pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre></div><p><a href="#element-comment"><span class="elemref"><tt>xsl:comment</tt></span></a> içeriğinin nesnelleştirilmesinin metin düğümünden farklı bir düğüm oluşturması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, hatalı düğümleri içerikleriyle birlikte yoksayarak hatayı ortadan kaldırabilir.</p><p><a href="#element-comment"><span class="elemref"><tt>xsl:comment</tt></span></a> içeriğinin nesnelleştirilme sonucunun <code>--</code> dizgesini içermesi bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, <code>-</code> karakterlerinin arasına bir boşluk yerleştirerek hatayı ortadan kaldırabilir.</p></div><div class="div2"><h3><a name="copying" id="copying"></a>7.5 Kopyalama</h3><a id="element-copy" name="element-copy"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:copy</span>
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:copy&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> elemanı, geçerli düğümün kopyalanmasını kolaylaştıran bir yol sağlar. <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> elemanının nesnelleştirilmesi, geçerli düğümün bir kopyasını oluşturur. Geçerli düğümün isim-alanı düğümleri de kendiliğinden kopyalanır, fakat öznitelikler ve düğümün çocukları kendiliklerinden kopyalanmazlar. <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> elemanının içeriği, oluşturulan düğümün öznitelikleri ve çocukları için bir örneklenimdir; içerik sadece özniteliklerin ve çocukların sahip olabileceği türdeki düğümler için nesnelleştirilir (örn, kök düğüm ve eleman düğümleri için).</p><p><a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> elemanı bir <code>use-attribute-sets</code> özniteliğine sahip olabilir (bkz, <a href="#attribute-sets"><b>İsimli Öznitelik Kümeleri</b></a>). Bu sadece eleman düğümleri kopyalanırken kullanılır.</p><p>Kök düğüm özel olarak ele alınır, çünkü hedef ağacın kök düğümü örtük olarak oluşturulur. Geçerli düğüm, kök düğüm olduğu takdirde, <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> bir kök düğüm oluşturmayacak, sadece içerik örneklenimini kullanacaktır.</p><p>Örneğin, özdeşlik dönüşümü <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> kullanılarak şöyle yazılabilir:</p><div class="example"><pre>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre></div><p>Geçerli düğüm bir öznitelik olduğunda, geçerli düğümle aynı isimde bir öznitelik oluşturmak için <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> kullanmak bir hata olsaydı, <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> kullanmak da bir hata olurdu  (bkz, <a href="#creating-attributes"><b>Özniteliklerin xsl:attribute ile Oluşturulması</b></a>).</p><p>Aşağıdaki örnekte, <code>xml:lang</code> özniteliklerinin nasıl kolayca kaynaktan hedefe kopyalanabileceği gösterilmiştir. Bir biçembent şöyle bir isimli örneklenim tanımlasaydı:</p><div class="example"><pre>&lt;xsl:template name="apply-templates-copy-lang"&gt;
 &lt;xsl:for-each select="@xml:lang"&gt;
   &lt;xsl:copy/&gt;
 &lt;/xsl:for-each&gt;
 &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div><p><code>xml:lang</code> özniteliği kopyalanmak istendiği takdirde, bunun yerine:</p><div class="example"><pre>&lt;xsl:apply-templates/&gt;</pre></div><p>bu daha basit olurdu:</p><div class="example"><pre>&lt;xsl:call-template name="apply-templates-copy-lang"/&gt;</pre></div><p>Geçerli düğüm bir isim-alanı düğümü olduğu takdirde, kopyalama işlemi, hedef ağaçta içerilen düğüme bir isim-alanı düğümü ekler. Bunun içerildiği düğümün bir eleman olmaması bir hatadır; gerçeklenimler hatayı raporlayabilir veya isim-alanı düğümünü yoksayabilir. Bir isim-alanı düğümünü bir elemana çocuklarını veya özniteliklerini eklendikten sonra eklemek bir hatadır; gerçeklenimler hatayı raporlayabilir veya isim-alanı düğümünü yoksayabilir. Bir isim-alanı düğümünü, aynı isimde bir isim-alanına zaten sahip olan bir elemana eklemek, her iki isim-alanı düğümü aynı <a href="../xpath#dt-string-value">dizgesel değer</a>e sahip olmadıkça (bu durumda yineleme yok sayılır), bir hatadır. Bir isim-alanı düğümünü bir elemana eklemek, eğer isim-alanı düğümünün ismi tanımsızsa ve eleman bir tanımsız isim-alanı tanım-yerine sahipse, bir hatadır.</p></div><div class="div2"><h3><a name="idp14472400" id="idp14472400"></a>7.6 Üretilen Metnin Hesaplanması</h3><p>Bir örneklenim içinde, <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanı üretilen metni hesaplamakta kullanılabilir; örneğin, metni kaynak ağaçtan çekip çıkarmak veya bir değişkene bir değer yerleştirmek için kullanılabilir. <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanı bunu, <code>select</code> özniteliğine değer olarak belirtilen bir <a title="İfade tanımı" href="#dt-expression">ifade</a> ile yapar. İfadeler ayrıca, birebir hedef elemanların öznitelikleri içinde kaşlı ayraçlarla (<code>{}</code>) sarmalanarak kullanılabilir.</p><div class="div3"><h4><a name="value-of" id="value-of"></a>7.6.1 Metnin <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> ile Üretilmesi</h4><a id="element-value-of" name="element-value-of"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:value-of</span>
  <b>select</b> = <var>dizgesel-ifade</var>
  <code>disable-output-escaping</code> = "yes" | "no"<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanı hedef ağaçta bir metin düğümü oluşturmak için nesnelleştirilir. Belirtilmesi zorunlu olan <code>select</code> özniteliği bir ifade olup değerlendirilmesiyle elde edilen nesne <a href="../xpath#function-string"><b><code>string</code></b></a> işlevi çağrılmış gibi bir dizgeye dönüştürülür. Bu dizge oluşturulan metin düğümünün dizgesel değerini belirtir. Dizge boşsa bir metin düğümü oluşturulmaz. Oluşturulan metin düğümü bitişik metin düğümü komşuları ile birleşir.</p><p><a href="#element-copy-of"><span class="elemref"><tt>xsl:copy-of</tt></span></a> elemanı bir düğüm kümesini bir dizgeye dönüştürmeksizin hedef ağaca kopyalamak için kullanılabilir. Daha fazla bilgi için <a href="#copy-of"><b>Değişken ve Değergeçlerin Değerlerinin xsl:copy-of ile Kullanımı</b></a> bölümüne bakınız.</p><p>Aşağıdaki örnekte, <code>adı</code> ve <code>soyadı</code> özniteliklerine sahip <code>kişi</code> elemanından bir HTML paragrafı oluşturulmaktadır. Paragraf geçerli düğümün <code>adı</code> ve <code>soyadı</code> özniteliklerinin değerleri arasında bir boşluk karakteri içerecektir.</p><div class="example"><pre>&lt;xsl:template match="kişi"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@adı"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@soyadı"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div><p>Başka bir örnek olarak aşağıda aynı paragraf <code>kişi</code> elemanının <code>adı</code> ve <code>soyadı</code> çocuk elemanlarının dizgesel değerleri ile oluşturulmaktadır.</p><div class="example"><pre>&lt;xsl:template match="kişi"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="adı"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="soyadı"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div><p>Aşağıdaki örnekte, her <code>işlem</code> elemanı için metnin başına işlemin güvenlik seviyesini belirten bir paragraf yerleştirilmektedir. Burada, işleme uygulanacak güvenlik seviyesinin <code>işlem</code> elemanının kendisindeki veya bir üstselindeki <code>güvenlik</code> özniteliğinden elde edildiği kabul edilmektedir. Eğer birden fazla <code>güvenlik</code> özniteliği belirtilmişse işleme en yakın elemanın <code>güvenlik</code> özniteliğinin değeri kullanılmaktadır.</p><div class="example"><pre>&lt;xsl:template match="işlem"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@güvenlik][1]/@güvenlik"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div><div class="div3"><h4><a name="attribute-value-templates" id="attribute-value-templates"></a>7.6.2 Öznitelik Değeri Örneklenimleri</h4><p><a name="dt-attribute-value-template" id="dt-attribute-value-template" title="Öznitelik Değeri Örneklenimi"></a><span title="Öznitelik Değeri Örneklenimi tanımı" class="termdef">Bir <b>öznitelik değeri örneklenimi</b> olarak yorumlanan bir öznitelik değerinde, örneğin, bir birebir hedef elemanın bir özniteliğinin değeri olarak, bir <a title="İfade tanımı" href="#dt-expression">ifade</a> kaşlı ayraçlar (<code>{}</code>) arasında kullanılabilir</span>. Öznitelik değeri örneklenimi, kaşlı ayraçlarla birlikte ifadenin yerine, ifadenin değerlendirilme sonucunun <a href="../xpath#function-string"><b><code>string</code></b></a> işlevi çağrılmış gibi bir dizgeye dönüştürülmesiyle elde edilen dizge yerleştirilerek nesnelleştirilir. Bir XSLT biçembendinde bir öznitelik değerindeki kaşlı ayraçların, öznitelik özellikle, bir öznitelik değeri örneklenimi olarak yorumlanan bir öznitelik olmadıkça özel bir anlamı yoktur; eleman sözdizimi özetinde, böyle özniteliklerin değeri kaşlı ayraçlarla sarmalanır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Tüm öznitelikler birer öznitelik değeri örneklenimi olarak yorumlanmaz. Değeri bir ifade veya örüntü olan öznitelikler, <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanların öznitelikleri ve isimli XSLT nesnelerine atıfta bulunan öznitelikler öznitelik değeri örneklenimi olarak yorumlanmaz. Ek olarak, <code>xmlns</code> öznitelikleri de öznitelik değeri örneklenimi olarak yorumlanmaz;  çünkü yorumlansaydı XML İsim-alanları Önergesi ile uyumluluk sağlanamazdı.<p></p></dd></dl><p>Aşağıdaki örnekte, kaynak içeriğindeki  <code>photograph</code> elemanından bir <code>img</code> hedef elemanı oluşturulmaktadır; <code>img</code> elemanının <code>src</code> özniteliğinin değeri <code>image-dir</code> değişkeninin değerinden ve <code>photograph</code> elemanının <code>href</code> çocuğunun dizgesel değerinden hesaplanmakta; <code>width</code> özniteliğinin değeri ise, <code>photograph</code> elemanının <code>size</code> çocuğunun <code>width</code> özniteliğinin değerinden hesaplanmaktadır:</p><div class="example"><pre>&lt;xsl:variable name="image-dir"&gt;/images&lt;/xsl:variable&gt;

&lt;xsl:template match="photograph"&gt;
&lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</pre></div><p>biçembendi ile</p><div class="example"><pre>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</pre></div><p>kaynak içeriğinden hedef ağaçta</p><div class="example"><pre>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</pre></div><p>düğümü elde edilmektedir.</p><p>Bir öznitelik değeri örneklenimi nesnelleştirildiğinde, ifadeyi sarmalayan kaşlı ayraçlar çifter çifter ise bunlar birer kaşlı ayraç olarak ele alınır. Bir öznitelik değeri örnekleniminin ifadesi içinde bir kapatan kaşlı ayracın yer alıp, ifadenin dışında kapatan kaşlı ayracın bulunmaması bir hatadır. Bir ifadedeki bir <code><a href="../xpath#NT-Literal">DizgeselSabit</a></code> içinde yer alan bir kapatan kaşlı ayraç ifadeyi sonlandıran kaşlı ayraç olarak ele alınmaz.</p><p>İfadelerin içindeki kaşlı ayraçlar tanınmazlar. Örneğin, buna</p><pre class="error">&lt;a href="#{id({@ref})/title}"&gt;</pre><p>izin verilmez. Yerine bunu kullanın:</p><div class="example"><pre>&lt;a href="#{id(@ref)/title}"&gt;</pre></div><p></p></div></div><div class="div2"><h3><a name="number" id="number"></a>7.7 Numaralama</h3><a id="element-number" name="element-number"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:number</span>
  <code>level</code> = "single" | "multiple" | "any"
  <code>count</code> = <var>örüntü</var>
  <code>from</code> = <var>örüntü</var>
  <code>value</code> = <var>sayısal-ifade</var>
  <code>format</code> = { <var>dizge</var> }
  <code>lang</code> = { <var>ad-dizgeciği</var> }
  <code>letter-value</code> = { "alphabetic" | "traditional" }
  <code>grouping-separator</code> = { <var>karakter</var> }
  <code>grouping-size</code> = { <var>sayı</var> }<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-number"><span class="elemref"><tt>xsl:number</tt></span></a> elemanı hedef ağaca biçimli bir numara yerleştirmek için kullanılır. Yerleştirilecek numara bir ifade tarafından belirtilir. Bu <a title="İfade tanımı" href="#dt-expression">ifade</a>yi <code>value</code> özniteliği içerir. İfadenin değerlendirilmesinin sonucu olan nesne <a href="../xpath#function-number"><b><code>number</code></b></a> işlevi çağrılmış gibi bir sayıya dönüştürülür. Sayının NaN, sonsuz veya 0.5'ten küçük olması bir hatadır; bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, sayıyı <a href="../xpath#function-string"><b><code>string</code></b></a> işlevi çağrılmış gibi dizgeye dönüştürüp hedef ağaca yerleştirerek hatayı ortadan kaldırmalıdır. Aksi takdirde, sayı bir tamsayıya yuvarlanır ve <a href="#convert"><b>Sayıdan Dizgeye Dönüşüm Öznitelikleri</b></a> bölümünde belirtilen öznitelikler kullanılarak bir dizgeye dönüştürülür; bu bağlamda, bu özniteliklerin her birinin değeri, bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Dönüşümden sonra, elde edilen dizge hedef ağaca yerleştirilir. Örneğin, aşağıda sıralı bir listenin üyeleri numaralanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre></div><p>Eğer <code>value</code> özniteliği belirtilmezse, <a href="#element-number"><span class="elemref"><tt>xsl:number</tt></span></a> elemanı geçerli düğümün kaynak ağacındaki konumuna karşılık gelen sayıyı bir numara olarak hedef ağaca yerleştirir. Aşağıdaki öznitelikler geçerli düğümün nasıl numaralanacağını denetler:</p><ul><li><p><code>level</code> özniteliğinde kaynak ağacın hangi seviyelerde ele alınacağı belirtilir; değer olarak <code>single</code>, <code>multiple</code> veya <code>any</code> belirtilebilir. <code>single</code> değeri öntanımlı değerdir.</p></li><li><p><code>count</code> özniteliğinin değeri, bu seviyelerdeki hangi düğümlerin sayılacağını belirten bir örüntüdür. <code>count</code> özniteliği belirtilmezse, geçerli düğümle aynı türdeki düğümle eşleşen örüntü öntanımlı değerdir; eğer geçerli düğüm bir genişletilmiş isme sahipse, öntanımlı örüntü geçerli düğümle aynı genişletilmiş isme sahip düğümle eşleşecektir.</p></li><li><p><code>from</code> özniteliğinin değeri, sayımın nereden başlatılacağını belirten bir örüntüdür.</p></li></ul><p>Ek olarak, <a href="#convert"><b>Sayıdan Dizgeye Dönüşüm Öznitelikleri</b></a> bölümünde belirtilen öznitelikler, <code>value</code> özniteliğinin belirtilmesi halinde sayıyı dizgeye dönüştürmek için kullanılırlar.</p><p><a href="#element-number"><span class="elemref"><tt>xsl:number</tt></span></a> elemanı önce <code>level</code>, <code>count</code> ve <code>from</code> özniteliklerini kullanarak bir liste oluşturur:</p><ul><li><p><code>level="single"</code> olduğu takdirde, <code>count</code>  örüntüsü ile eşleşen <a href="../xpath#axis-ancestor-or-self"><code>ancestor-or-self</code></a> dalındaki ilk düğüme gidilir ve <code>count</code> örüntüsü ile eşleşen üstselin büyük kardeşinin numarası artı bir değerini içeren tek üyeli bir liste oluşturulur. Eğer böyle bir üstsel yoksa, boş liste oluşur. Eğer <code>from</code> özniteliği belirtilmişse, sadece, <code>from</code> örüntüsüyle eşleşen en yakın üstselin astsalları olan üstseller araştırılır. Burada büyük kardeşlerle, <a href="../xpath#axis-preceding-sibling"><code>preceding-sibling</code></a> dalı kastedilmektedir.</p></li><li><p><code>level="multiple"</code> olduğu takdirde, geçerli düğümün, sırada kendisinin de bulunduğu, tüm üstsellerinin belge sırasına göre bir listesi oluşturulur; sonra, bu listeden <code>count</code> örüntüsü ile eşleşen düğümler seçilir; ardından, listenin her düğümüne, <code>count</code> örüntüsü ile eşleşen düğümün büyük kardeşinin numarası artı bir değeri eşlenir. Eğer <code>from</code> özniteliği belirtilmişse, sadece, <code>from</code> örüntüsüyle eşleşen en yakın üstselin astsalları olan üstseller araştırılır. Burada büyük kardeşlerle, <a href="../xpath#axis-preceding-sibling"><code>preceding-sibling</code></a> dalı kastedilmektedir.</p></li><li><p><code>level="any"</code> olduğu takdirde, geçerli düğümü içeren kümeye ait olan düğümler artı <code>count</code> örüntüsü ile eşleşen düğümler artı belgedeki sıraya göre geçerli düğümden önce yer alan her seviyeden (isim-alanı ve öznitelik düğümleri hariç) tüm düğümlerin sayısı toplamını  içeren tek üyeli bir liste oluşturulur (başka bir deyişle, <a href="../xpath#axis-preceding"><code>preceding</code></a> ve <a href="../xpath#axis-ancestor-or-self"><code>ancestor-or-self</code></a> dallarının üyelerinin hepsi). Hiç eşleşen düğüm yoksa, boş liste oluşur. <code>from</code> özniteliği belirtilmişse, sadece geçerli düğümden önceki ilk düğümden sonraki düğümlerin <code>from</code> örüntüsü ile eşleştiği varsayılır.</p></li></ul><p>Bundan sonra, numara listesi <a href="#convert"><b>Sayıdan Dizgeye Dönüşüm Öznitelikleri</b></a> bölümünde belirtilen öznitelikler kullanılarak bir dizgeye dönüştürülür; bu bağlamda, bu özniteliklerin her birinin değeri, bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır. Dönüşümden sonra, elde edilen dizge hedef ağaca yerleştirilir.</p><p>Aşağıda numaralı bir listenin üyeleri numaralanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</pre></div><p>Aşağıdaki iki kural <code>başlık</code> elemanlarını numaralayacaktır. Anabölüm ve ekbölümlerden oluşan bir belgede, anabölümlerin ve ekbölümlerin bölümlere, bu bölümlerinde altbölümlere sahip olduğu düşünülerek, anabölümler 1, 2, 3; ekbölümler A, B, C; anabölüm bölümleri 1.1, 1.2, 1.3; ve ekbölüm bölümlerinin de A.1, A.2, A.3 biçiminde numaralanacakları düşünülmüştür.</p><div class="example"><pre>&lt;xsl:template match="başlık"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="anabölüm|bölüm|altbölüm"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ekbölüm//başlık" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="ekbölüm|bölüm|altbölüm"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p>Aşağıdaki örnekte bir anabölüm içindeki notlar numaralanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="not"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="anabölüm" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p>Aşağıdaki örnekte HTML'deki <code>H4</code> elemanları üç parçalı bir madde başlığı ile numaralanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div><p></p><div class="div3"><h4><a name="convert" id="convert"></a>7.7.1 Sayıdan Dizgeye Dönüşüm Öznitelikleri</h4><p>Aşağıdaki öznitelikler bir numara listesinin dizgeye dönüşümünü denetlemekte kullanılırlar. Numaralar sıfırdan büyük tamsayılardır. Özniteliklerin hepsi isteğe bağlıdır.</p><p>Ana öznitelik <code>format</code> olup öntanımlı değeri <code>1</code>'dir. <code>format</code> özniteliği bir dizgecik dizisine bölünmüştür; buradaki her dizgecik ya olası en çok sayıda abecesayısal karakterden ya da olası en çok sayıda abecesayısal olmayan karakterden oluşur. Abecesayısal, Unicode kategorileri Nd, Nl, No, Lu, Ll, Lt, Lm veya Lo olan karakterler anlamındadır. Abecesayısal dizgecikler (biçim dizgecikleri) listedeki her numara için kullanılacak biçimi belirtirler. Eğer ilk dizgecik bir abecesayısal olmayan dizgecikse, oluşturulacak dizge bu dizgecikle başlar; eğer son dizgecik bir abecesayısal olmayan dizgecikse, oluşturulacak dizge bu dizgecikle biter. İki biçim dizgesi arasında yer alan abecesayısal olmayan dizgecikler, listedeki numaraları birbirine bağlamakta kullanılan ayraçlardır. <var>n</var>'inci biçim dizgesi listedeki <var>n</var>'inci numarayı biçimlemekte kullanılır. Eğer biçim dizgeciklerinden daha fazla numara varsa, son biçim dizgeciği kalan numaraları biçimlemekte kullanılır. Hiç biçim dizgeciği yoksa, bütün numaraları biçimlemek için biçim dizgeciği olarak <code>1</code> kullanılır. Biçim dizgeciği 1 sayısını göstermekte kullanılacak dizgeciği belirtir. İlkinden sonraki her numara, önceki numaradan ayraç dizgeciği ile ayrılır. Bir ayraç dizgeciği yoksa . (nokta) kullanılır.</p><p>Biçim dizgecikleri, HTML 4.0'daki <code>OL</code> elemanının <code>type</code> özniteliği için izin verilen değerlerin bir üstkümesidir ve şöyle yorumlanır:</p><ul><li><p>Eğer bir biçim dizgeciğinin son karakterinin onluk rakam değeri 1 (Unicode karakter varlığı veritabanında belirtildiği gibi) ise ve sondan önceki karakterlerin Unicode değeri son karakterin Unicode değerinden 1 azsa o zaman bu dizgeciğe göre biçimlenen herhangi bir sayının onluk gösterimi en az biçim dizgeciği uzunluğundadır. Bu bakımdan, <code>1</code> biçim dizgeciği <code>1 2 ... 10 11 12 ...</code> dizisini üretirken, <code>01</code> biçim dizgeciği <code>01 02 ... 09 10 11 12 ... 99 100 101</code> dizisini üretecektir.</p></li><li><p><code>A</code> biçim dizgeciği <code>A B C ... Z AA AB AC...</code> dizisini üretir.</p></li><li><p><code>a</code> biçim dizgeciği <code>a b c ... z aa ab ac...</code> dizisini üretir.</p></li><li><p><code>i</code> biçim dizgeciği <code>i ii iii iv v vi vii viii ix x ...</code> dizisini üretir.</p></li><li><p><code>I</code> biçim dizgeciği <code>I II III IV V VI VII VIII IX X ...</code> dizisini üretir.</p></li><li><p>Bunlar dışında herhangi bir biçim dizgeciği o dizgecikle başlayan bir dizi üretir. Bu numaralama dizisini desteklemeyen gerçeklenimler <code>1</code> biçim dizgeciğini kullanmalıdır.</p></li></ul><p>Bir abecesayısal dizi numaralanırken, <code>lang</code> özniteliği hangi dilin elifbasının kullanılacağını belirtir; <code>xml:lang</code> [<a href="#XML">XML</a>] ile aynı aralıktaki değerler kullanılır; hiç <code>lang</code> değeri belirtilmemişse, dil, sistem ortamından saptanır. Gerçeklenimciler hangi dili desteklediklerini belgelemelidirler.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Gerçeklenimciler belli bir dilde nasıl numaralama yapılacağına ilişkin herhangi bir kabulde bulunmamalıdırlar ve desteklemek istedikleri dilleri gerektiği gibi araştırmalıdırlar. Çoğu dilin numaralama uzlaşımları İngilizce'dekinden çok farklıdır.<p></p></dd></dl><p><code>letter-value</code> özniteliği, harflerin kullanıldığı numaralama dizileri arasındaki belirsizliği ortadan kaldırır. Çoğu dilde, harflerin kullanıldığı numaralama dizileri başlıca iki çeşittir. Birinde, harflere abecesel sıraya göre sayısal değer atanırken, diğerinde sayısal değerler dildeki geleneksel anlamlandırmaya göre atanırlar. İngilizce'de bu iki çeşide ait biçim dizgecikleri <code>a</code> ve <code>i</code>'dir. Bazı dillerde dizilerin ilk üyesi aynıdır ve dolayısıyla biçim dizgeciği tek başına belirleyici olmaz. <code>alphabetic</code> değeri abecesel sıralamayı, <code>traditional</code> değeri ise diğer sıralamayı belirtir. Eğer <code>letter-value</code> özniteliği belirtilmemişse, belirsizliğin nasıl çözümleneceği gerçeklenime bağlıdır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>İki uyumlu XSLT işlemcisinin bir sayıyı tamamen aynı dizgeye dönüştürmemesi olasıdır. Bazı XSLT işlemci bazı dilleri desteklemeyebilir. Bundan başka, belli bir dildeki biçim çeşitlemelerini gerçekleştirecek dönüşümleri belirtmek için <a href="#element-number"><span class="elemref"><tt>xsl:number</tt></span></a> öznitelikleri yeterli olmayabilir. Gerçeklenimler, bunun için <a href="#element-number"><span class="elemref"><tt>xsl:number</tt></span></a> üzerinde gerçeklenime özgü isim-alanlı öznitelikler kullanabilirler.<p></p></dd></dl><p><code>grouping-separator</code> özniteliği onluk numaralama dizilerinde gruplama ayracı (binler ayracı gibi) olarak kullanılacak bir ayraç belirtilebilmesini ve isteğe bağlı olan <code>grouping-size</code> özniteliği ise ile gruplama miktarının (normalde 3'tür) belirtilebilmesini mümkün kılar. Örneğin, <code>grouping-separator=","</code> ve <code>grouping-size="3"</code> belirtimi <code>1,000,000</code> biçiminde bir sayı üretecektir. Bu ikisinden biri tek başına kullanılırsa yoksayılır.</p><p>Bazı dönüşüm belirtimi örnekleri:</p><ul><li><p><code>format="&amp;#x30A2;"</code> Katakana numaralaması belirtir</p></li><li><p><code>format="&amp;#x30A4;"</code> Katakana numaralamasını "iroha" sıralamasıyla belirtir</p></li><li><p><code>format="&amp;#x0E51;"</code> Tay rakamlı numaralama belirtir</p></li><li><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
İbranice "geleneksel" numaralama belirtir</p></li><li><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
Gürcü tarzı numaralama belirtir</p></li><li><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
"klasik" Yunan numaralaması belirtir</p></li><li><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
eski Slav tarzı numaralama belirtir</p></li></ul><p></p></div></div></div><div class="div1"><h2><a name="for-each" id="for-each"></a>8 Yineleme</h2><a id="element-for-each" name="element-for-each"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:for-each</span>
  <b>select</b> = <var>düğüm-kümesi-ifadesi</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-sort">&lt;xsl:sort&gt;</a>*, <var>örneklenim</var>) --&gt;
<span class="element">&lt;/xsl:for-each&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Sonucun düzenli bir yapıda olacağı biliniyorsa, örneklenimde doğrudan düğümleri seçmek daha kullanışlıdır. <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> yönergesi, <code>select</code> özniteliğinde belirtilen <a title="İfade tanımı" href="#dt-expression">ifade</a>ye göre seçilen her düğümü nesnelleştiren bir örneklenim içerir. <code>select</code> özniteliğinin kullanılması zorunludur. İfadeden bir düğüm kümesi elde edilmelidir. Örneklenim seçilen düğümleri birer <a title="Geçerli Düğüm tanımı" href="#dt-current-node">geçerli düğüm</a> olarak, tamamını da bir <a title="Geçerli Düğüm Listesi tanımı" href="#dt-current-node-list">geçerli düğüm listesi</a> olarak nesnelleştirir. Bir sıralama belirtilmedikçe düğümler belgedeki sıralarına göre işlenirler (bkz, <a href="#sorting"><b>Sıralama</b></a>).</p><p>Örneğin, bir XML belge şu yapıda olsun:</p><div class="example"><pre>&lt;müşteriler&gt;
  &lt;müşteri&gt;
    &lt;isim&gt;...&lt;/isim&gt;
    &lt;sipariş&gt;...&lt;/sipariş&gt;
    &lt;sipariş&gt;...&lt;/sipariş&gt;
  &lt;/müşteri&gt;
  &lt;müşteri&gt;
    &lt;isim&gt;...&lt;/isim&gt;
    &lt;sipariş&gt;...&lt;/sipariş&gt;
    &lt;sipariş&gt;...&lt;/sipariş&gt;
  &lt;/müşteri&gt;
&lt;/customers&gt;</pre></div><p>Aşağıdaki kod her <code>müşteri</code> elemanı için bir satır bulunan bir tablo içeren bir HTML belge oluşturacaktır:</p><div class="example"><pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Müşteriler&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="müşteriler/müşteri"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="isim"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="sipariş"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div><div class="div1"><h2><a name="condproc" id="condproc"></a>9 Koşullu İşlem</h2><p>XSLT'de bir örneklenim içinde koşullu işlemi destekleyen iki yönerge vardır: <a href="#element-if"><span class="elemref"><tt>xsl:if</tt></span></a> ve <a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a>. <a href="#element-if"><span class="elemref"><tt>xsl:if</tt></span></a> yönergesi basit if-then koşullu işlemi içindir; <a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a> yönergesi ise çeşitli olasılıklardan birinin seçilebilmesini sağlar.</p><div class="div2"><h3><a name="idp14650928" id="idp14650928"></a>9.1 <a href="#element-if"><span class="elemref"><tt>xsl:if</tt></span></a> ile Koşullu İşlem</h3><a id="element-if" name="element-if"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:if</span>
  <b>test</b> = <var>mantıksal-ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:if&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-if"><span class="elemref"><tt>xsl:if</tt></span></a> elemanı <a title="İfade tanımı" href="#dt-expression">ifade</a> belirtmekte kullanılan bir <code>test</code> özniteliğine sahiptir. İfade değerlendirildikten sonra elde edilen sonuç <a href="../xpath#function-boolean"><b><code>boolean</code></b></a> işlevinin yaptığı gibi bir mantıksal değere dönüştürülür. Eğer sonuç doğruysa, elemanının içeriğindeki örneklenim nesnelleştirilir; aksi takdirde, hiçbir şey yapılmaz. Aşağıdaki örnekte, bir isim grubundaki isimler bir virgül ayraçlı liste haline getirilmektedir:</p><div class="example"><pre>&lt;xsl:template match="isimlistesi/isim"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre></div><p>Bu örnekte bir tablonun satırları birer atlayarak sarıya boyanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div><div class="div2"><h3><a name="idp14660832" id="idp14660832"></a>9.2 <a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a> ile Koşullu İşlem</h3><a id="element-choose" name="element-choose"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:choose&gt;</span>
  &lt;!-- İçeriği: (<a href="#element-when">&lt;xsl:when&gt;</a>+ | <a href="#element-otherwise">&lt;xsl:otherwise&gt;</a>?) --&gt;
<span class="element">&lt;/xsl:choose&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><a id="element-when" name="element-when"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:when</span>
  <b>test</b> = <var>mantıksal-ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:when&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><a id="element-otherwise" name="element-otherwise"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:otherwise&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:otherwise&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a> elemanı bir miktar olasılık arasından uygun olanını seçer. Bir veya daha fazla sayıda <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanı ile varlığı isteği bağlı olan <a href="#element-otherwise"><span class="elemref"><tt>xsl:otherwise</tt></span></a> elemanını içerebilir. Her <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanının bir <a title="İfade tanımı" href="#dt-expression">ifade</a> belirtmekte kullanılan tek bir <code>test</code> özniteliği vardır. <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> ve <a href="#element-otherwise"><span class="elemref"><tt>xsl:otherwise</tt></span></a> elemanlarının içerikleri birer örneklenimdir. Bir <a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a> elemanı işleme sokulduğunda, <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanlarının içerdiği ifadeler sırayla değerlendirilip elde edilen sonuçlar <a href="../xpath#function-boolean"><b><code>boolean</code></b></a> işlevinin yaptığı gibi birer mantıksal değere dönüştürülerek denenir. <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanlarından doğru sonucu veren ilkinin içeriği nesnelleştirilir, diğerlerine bakılmaz. Eğer hiçbir <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanı doğru sonuç vermemişse, <a href="#element-otherwise"><span class="elemref"><tt>xsl:otherwise</tt></span></a> elemanının içeriği nesnelleştirilir. Eğer hiçbir <a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanı doğru sonuç vermemişse ve <a href="#element-otherwise"><span class="elemref"><tt>xsl:otherwise</tt></span></a> elemanı da yoksa hiçbir nesnelleştirme yapılmaz.</p><p>Aşağıdaki örnekte, alt listeleri de olan sıralı bir listenin üyeleri, alt liste derinliğine bağlı olarak arap rakamları, harfler ve yunan rakamları kullanılarak numaralanmaktadır:</p><div class="example"><pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div></div><div class="div1"><h2><a name="sorting" id="sorting"></a>10 Sıralama</h2><a id="element-sort" name="element-sort"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:sort</span>
  <code>select</code> = <var>dizgesel-ifade</var>
  <code>lang</code> = { <var>ad-dizgeciği</var> }
  <code>data-type</code> = { "text" | "number" | <var>nitelikli-ad-ama-kısa-ad-değil</var> }
  <code>order</code> = { "ascending" | "descending" }
  <code>case-order</code> = { "upper-first" | "lower-first" }<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Sıralama, bir <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> veya <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanının çocukları olarak <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanları kullanılarak belirtilir. İlk <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> birincil sıralama anahtarını, ikincisi ikincil olanını belirtir ve bu böyle çoğaltılabilir. Bir <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> veya <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanının çocukları olarak bir veya daha fazla sayıda <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanı olduğu takdirde, seçilen düğümler belgedeki sıralarına göre değil, sıralama anahtarları ile belirtilen sıraya göre işlenirler. <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanları <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanında kullanıldıklarında, ilk çocuklar olmalıdırlar. Bir örneklenimin <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> veya <a href="#element-for-each"><span class="elemref"><tt>xsl:for-each</tt></span></a> elemanı tarafından nesnelleştirilmesi halinde, <a title="Geçerli Düğüm Listesi tanımı" href="#dt-current-node-list">geçerli düğüm listesi</a>nin düğümleri <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanları tarafından belirtilen sıraya göre sıralanırlar.</p><p><a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanının bir <a title="İfade tanımı" href="#dt-expression">ifade</a> belirtmekte kullanılan bir <code>select</code> özniteliği vardır. İşlenen her düğüm için, düğüm geçerli düğüm kabul edilerek ve işlenen bütün düğümler için, belgedeki sırasıyla  bu düğümlerin tamamı geçerli düğüm listesi kabul edilerek ifade değerlendirilir. Elde edilen nesne <a href="../xpath#function-string"><b><code>string</code></b></a> işlevinin yaptığı gibi bir dizgeye dönüştürülür; bu dizge düğüm için sıralama anahtarı olarak kullanılır. <code>select</code> özniteliğini öntanımlı değeri <code>.</code> olup, sıralama anahtarı olarak geçerli düğümün dizgesel değerinin kullanılmasına sebep olur.</p><p>Bu dizge düğüm için bir sıralama anahtarı işlevini görür. Aşağıdaki isteğe bağlı öznitelikler <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> üzerinde sıralama anahtarları listesinin nasıl sıralanacağını denetlerler; bu özniteliklerin değerleri birer <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> olarak yorumlanır.</p><ul><li><p><code>order</code> özniteliği dizgelerin artan sırada mı yaksa azalan sırada mı sıralanacaklarını belirtir; <code>ascending</code> değeri sıralamanın artan sırada olacağını belirtirken, <code>descending</code> azalan sıralamada olacağını belirtir. <code>ascending</code> değeri öntanımlı değerdir.</p></li><li><p><code>lang</code> özniteliği sıralama anahtarları için dil belirtir; değeri [<a href="#XML">XML</a>] <code>xml:lang</code> değerlerinden biri olmalıdır; <code>lang</code> özniteliği kullanılmamışsa, geçerli dil sistem ortamından elde edilmelidir.</p></li><li><p><code>data-type</code> özniteliği dizgelerin veri türünü belirtir; şu değerlere izin verilir:</p><ul><li><p><code>text</code> değeri, sıralama anahtarlarının <code>lang</code> tarafından belirtilen dil için kültürel olarak doğru sözlük sırasında olacağını belirtir.</p></li><li><p><code>number</code> değeri, sıralama anahtarları sayıya dönüştürüldükten sonra sıralamanın sayısal değerlerine göre olacağını belirtir; her sıralama anahtarı <a href="../xpath#function-number"><b><code>number</code></b></a> işlevinin yaptığı gibi birer sayıya dönüştürülür; <code>lang</code> özniteliği yoksayılır; bir NaN değeri artan sırada sayılardan önceye, azalan sırada sayılardan sonraya yerleştirilir.</p></li><li><p>Bir önekle birlikte bir <code><a href="../xml-names#NT-QName">NitelAd</a></code>, <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi bir <a href="../xpath#dt-expanded-name">genişletilmiş isme</a> genişletilir; genişletilmiş isim veri türünü belirtir; bu durumda davranışın ne olacağı bu belgede belirtilmemiştir.</p></li></ul><p>Öntanımlı değer <code>text</code>'tir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XSL Çalışma Grubu, XSLT'nin ileri sürümlerinde bu özniteliğin değerlerini tanımlamak için daha kapsamlı XML Şemaları kullanmayı planlamaktadır.<p></p></dd></dl><p></p></li><li><p><code>case-order</code> özniteliği <code>upper-first</code> veya <code>lower-first</code> değerine sahip olabilir; <code>data-type="text"</code> ve artan sıra belirtildiğinde, büyük harflerin mi yoksa küçük harflerin mi önce geleceğini belirtirler. Örneğin, <code>lang="en"</code> için <code>case-order="upper-first"</code> olduğunda sıralama <code>A a B b</code>, <code>case-order="lower-first"</code> olduğunda ise <code>a A b B</code> şeklinde olur. Azalan sıra için herşey tersine olur. Örneğin, <code>lang="en"</code> için <code>case-order="upper-first"</code> olduğunda sıralama <code>b B a A</code>, <code>case-order="lower-first"</code> olduğunda ise <code>B b A a</code> şeklinde olur. Öntanımlı değer dile bağlıdır.</p></li></ul><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>İki uyumlu XSLT işlemcinin tamamen aynı sıralamayı yapmaması olasıdır. Bazı XSLT işlemciler bazı dilleri desteklemeyebilir. Bundan başka, bazı diller için <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> öznitelikleriyle elde edilemeyecek kadar çeşitli sıralamalar olası olabilir; örneğin, Japonca'da sıralamanın Hiragana mı yoksa Katakana mı olacağı gibi. XSLT'nin ileri sürümlerinde bu olasılıklar üzerinde denetim sağlayacak ek öznitelikler sağlanabilir. Gerçeklenimler ayrıca, bunun için <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> üzerinde gerçeklenime özel isim-alanlı öznitelikler kullanabilirler.<p></p></dd></dl><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Gerçeklenimcilerin uluslararası sıralama hakkında bilgi edinmek için [<a href="#UNICODE-TR10">UNICODE TR10</a>]'u incelemeleri önerilir.<p></p></dd></dl><p>Sıralama kararlı olmalıdır: sıralı düğüm listesinde sıralama anahtarı belirtilmiş her alt listenin üyelerinin belgedeki sıraya göre eş sırada ele alınmaları gerekir.</p><p>Örneğin, şu biçimde düzenlenmiş bir çalışanlar veritabanımız olsun:</p><div class="example"><pre>&lt;çalışanlar&gt;
  &lt;çalışan&gt;
    &lt;isim&gt;
      &lt;önadı&gt;James&lt;/önadı&gt;
      &lt;soyadı&gt;Clark&lt;/soyadı&gt;
    &lt;/isim&gt;
    ...
  &lt;/çalışan&gt;
&lt;/çalışanlar&gt;
</pre></div><p>İsme göre sıralı çalışanlar listesini üretecek kod şöyle olurdu:</p><div class="example"><pre>&lt;xsl:template match="çalışanlar"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="çalışan"&gt;
      &lt;xsl:sort select="isim/soyadı"/&gt;
      &lt;xsl:sort select="isim/önadı"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="çalışan"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="isim/önadı"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="isim/soyadı"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div><div class="div1"><h2><a name="variables" id="variables"></a>11 Değişkenler ve Değergeçler</h2><a id="element-variable" name="element-variable"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:variable</span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:variable&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><a id="element-param" name="element-param"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:param</span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:param&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir değişken bir değere atanmış bir isimdir. Bir değişken atanmış bir değer ifadelerden elde edilen herhangi bir türde nesne olabilir. Değişken atamakta kullanılabilen iki eleman vardır: <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a>. Farkları, <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanının  değişkene sadece bir öntanımlı değer atamasıdır; <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanının yer aldığı örneklenim veya biçembent çağrıldığında değergeçler kullanıldıkları yerlere öntanımlı değer geçirirler.</p><p><a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarının ikisinin de değişkenin ismi olarak kullanıldığından belirtilmesi zorunlu birer <code>name</code> özniteliği vardır. <code>name</code> özniteliğinin değeri <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi bir <code><a href="../xml-names#NT-QName">NitelAd</a></code>a genişletilir.</p><p>Bu değişken atama elemanlarından herhangi biri için, içinde atamanın görünür olduğu bir biçembent ağacı bölümü mevcuttur. Bir ifadenin etki alanındaki değişken atamaları, bu ifadenin yer aldığı biçembentte değişkenin görünür olduğu yerdeki atamalardan oluşur.</p><div class="div2"><h3><a name="idp14760320" id="idp14760320"></a>11.1 Hedef Ağaç Bölümleri</h3><p>Değişkenler ifade diline yeni bir veri türü ekler.
<a name="dt-result-tree-fragment" id="dt-result-tree-fragment" title="Hedef Ağaç Bölümü"></a><span title="Hedef Ağaç Bölümü tanımı" class="termdef">Bu yeni türe <b>hedef ağaç bölümü</b> adı verilir. Bir değişken dört temel XPath türünden (dizge, sayı, mantıksal değer ve düğüm kümesi) başka bir hedef ağaç bölümü türünde de atanabilir. Bir hedef ağaç bölümü, hedef ağacın bir bölümü olarak ifade edilir ve tek bir kök düğüm içeren bir düğüm kümesine eşdeğer tarzda ele alınır</span>. Bununla birlikte, bir hedef ağaç bölümünde izin verilen işlemler bir düğüm kümesinde izin verilen işlemlerin bir altkümesidir. Böyle bir işleme sadece bir dizge üzerinde izin verilen bir işlemse izin verilir (dizge üzerindeki ilk işlem, dizgeyi bir mantıksal değere veya sayıya dönüştürme işlemi olabilir). Özellikle, hedef ağaç bölümü üzerinde <code>/</code>, <code>//</code> ve <code>[]</code> işleçlerinin kullanımına izin verilmez. Bir hedef ağaç bölümünde izin verilen işlemlerden biri her uygulanışında, eşdeğeri bir düğüm kümesinde uygulandığı gibi uygulanır.</p><p>Bir hedef ağaç bölümü hedef ağaca kopyalanırken (bkz, <a href="#copy-of"><b>Değişken ve Değergeçlerin Değerlerinin xsl:copy-of ile Kullanımı</b></a>), eşdeğer düğüm kümesinde kök düğümün çocukları olan tüm düğümler hedef ağaca aynı sırayla kopyalanırlar.</p><p>İfadeler, hedef ağaç bölümü türündeki değerleri sadece, hedef ağaç bölümü türündeki değişkenlere atıfta bulunarak veya bir hedef ağaç bölümü döndüren bir eklenti işlevini çağırarak ya da değeri bir hedef ağaç bölümü olan bir sistem gerecini getirerek döndürürler.</p></div><div class="div2"><h3><a name="variable-values" id="variable-values"></a>11.2 Değişken ve Değergeçlerin Değerleri</h3><p>Bir değişken atama elemanı bir değişken değerini üç yoldan biriyle belirtebilir.</p><ul><li><p>Değişken atama elemanı bir <code>select</code> özniteliğine sahipse, bu özniteliğin değeri, değerlendirilmesinin sonucunda değişkenin değeri haline gelecek olan bir nesnenin elde edileceği bir <a title="İfade tanımı" href="#dt-expression">ifade</a> olmalıdır. Bu durumda, değişken atama elemanının içeriği boş olmalıdır.</p></li><li><p>Değişken atama elemanı bir <code>select</code> özniteliğine sahip değilse ve eleman boş olmayan bir içeriğe sahipse (yani, değişken atama elemanı bir veya daha fazla sayıda çocuk elemana sahipse), değeri değişken atama elemanının içeriği belirler. Değişken atama elemanının içeriği, değişkenin değerini vermek üzere nesnelleştirilecek olan örneklenimdir. Değeri, çocukları örneklenimin nesnelleştirilmesiyle üretilen düğümlerden oluşan tek bir kök düğüm içeren bir düğüm kümesine eşdeğer bir hedef ağaç bölümüdür. Hedef ağaç bölümündeki düğümlerin temel tanım-yeri (URI), değişken atama elemanının temel tanım-yeridir.</p><p>Örneklenim nesnelleştirilerek elde edilen düğümlerin bir üyesinin bir öznitelik düğümü veya bir isim-alanı düğümü olması, bir kök düğüm böyle bir çocuk düğüme sahip olamayacağından, bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, öznitelik veya isim-alanı düğümünü hedef ağaca eklemeyerek hatayı ortadan kaldırabilir.</p></li><li><p>Değişken atama elemanı boş bir içeriğe sahipse ve bir <code>select</code> özniteliği de belirtilmemişse, değişkenin değeri bir boş dizge olacaktır. Bu bakımdan,</p><div class="example"><pre>&lt;xsl:variable name="x"/&gt;</pre></div><p>buna eşdeğerdir:</p><div class="example"><pre>&lt;xsl:variable name="x" select="''"/&gt;</pre></div><p></p></li></ul><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir değişken, düğümleri konumlarına göre seçmek için kullanılmışsa, aşağıdakini yapmamak konusunda dikkatli olunmalıdır:<p></p><div class="example"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre></div><p>Bu örneklenim, ilk item elemanının değerini çıktılayacaktır. Sebebi, <code>n</code> değişkeninin bir sayıya değil bir hedef ağaç bölümüne atanmış olmasıdır. Şöyle,</p><div class="example"><pre>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre></div><p>veya şöyle yapılabilirdi:</p><div class="example"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[position()=$n]"/&gt;</pre></div><p></p></dd></dl><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Boş bir düğüm kümesini bir değergeçe öntanımlı değer olarak atamanın tek uygun yolu şudur:<p></p><div class="example"><pre>&lt;xsl:param name="x" select="/.."/&gt;</pre></div><p></p></dd></dl><p></p></div><div class="div2"><h3><a name="copy-of" id="copy-of"></a>11.3 Değişken ve Değergeçlerin Değerlerinin <a href="#element-copy-of"><span class="elemref"><tt>xsl:copy-of</tt></span></a> ile Kullanımı</h3><a id="element-copy-of" name="element-copy-of"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:copy-of</span>
  <b>select</b> = <var>ifade</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-copy-of"><span class="elemref"><tt>xsl:copy-of</tt></span></a> elemanı hedef ağaca bir hedef ağaç bölümü yerleştirmekte kullanılabilir ve bunu yapmak için <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanının yaptığı gibi (bkz, <a href="#value-of"><b>Metnin xsl:value-of ile Üretilmesi</b></a>) önce bir dizgeye dönüşüm gerekmez. Bir <a title="İfade tanımı" href="#dt-expression">ifade</a> içeren bir <code>select</code> özniteliğinin belirtilmesi zorunludur. İfadenin değerlendirme sonucunun bir hedef ağaç bölümü olması durumunda, bölümün tümü hedef ağaca kopyalanır. Sonucun bir düğüm kümesi olması durumunda ise, kümenin düğümleri belgedeki sıralarına göre hedef ağaca kopyalanırlar; bir eleman düğümünün kopyalanması, elemanın kendinden başka, isim-alanı düğümlerinin, öznitelik düğümlerinin ve elemanın çocuk düğümlerinin de kopyalanmasına sebep olur; bir kök düğüm ise, çocuklarının kopyalanmasıyla kopyalanmış olur. Bir öznitelik veya isim-alanının kopyalanmasında, <a href="#element-copy"><span class="elemref"><tt>xsl:copy</tt></span></a> ile kopyalamada geçerli olan kurallar burada da aynen geçerlidir (bkz, <a href="#copying"><b>Kopyalama</b></a>). Sonucun ne bir düğüm kümesi ne de hedef ağaç bölümü olması durumunda, tıpkı <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanının yaptığı gibi, sonuç bir dizgeye dönüştürüldükten sonra hedef ağaca yerleştirilir.</p></div><div class="div2"><h3><a name="top-level-variables" id="top-level-variables"></a>11.4 Tepe-Seviyeden Değişkenler ve Değergeçler</h3><p><a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarının her ikisi de <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanlar olabilir. Bir tepe-seviyeden değişken atama elemanı, her yerde (başka bir atama tarafından geçersiz kılınmadıkça) görünür olan bir genel değişken bildirir. Bir tepe-seviyeden <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanı biçembende bir değergeç bildirir; XSLT, biçembente değergeç aktarımı ile ilgili bir mekanizma tanımlamaz. Bir biçembent aynı isme sahip birden fazla değişken ataması içeriyorsa, <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a> en yüksek atama kullanılır. Bir biçembendin aynı <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a> ile aynı isme atama yapan birden fazla değişken ataması içermesi bir hatadır. Tepe seviyede, değişken değeri belirten bir ifade veya örneklenim, kaynak belgenin kök düğümünü işlemekte kullanılan bağlama eşdeğer bir bağlamla değerlendirilir: geçerli düğüm kaynak belgenin kök düğümü olup geçerli düğüm kümesi kaynak belgenin sadece kök düğümünü içeren bir listedir. Eğer bir örneklenim veya ifade bir <var>y</var> genel değişkenine atıf yapan bir <var>x</var> genel değişkeni belirtiyorsa, <var>y</var> değişkeninin değerinin <var>x</var> değişkeninin değerinden önce hesaplanması gerekir. Tüm genel değişken tanımları açısından bunun olması olanaksızsa bu bir hatadır; başka bir deyişle, atamanın bitmeyen bir döngüye yol açabilecek şekilde hesaplanması bir hatadır.</p><p>Burada, bir öznitelik değeri örnekleniminden atıfta bulunulan <code>para-font-size</code> isimli bir genel değişken bildirilmektedir:</p><div class="example"><pre>&lt;xsl:variable name="para-font-size"&gt;12pt&lt;/xsl:variable&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div><p></p></div><div class="div2"><h3><a name="local-variables" id="local-variables"></a>11.5 Örneklenimlerin içinde Değişkenler ve Değergeçler</h3><p><a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarına tepe seviyede izin verildiği gibi örneklenimlerin içinde de izin verilir. <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> elemanına, bir örneklenimin içinde bir yönergeye izin verilen her yerde izin verilir. Bu durumda, atama, <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> yönergeleri hariç tüm küçük kardeşlerin astsallarına görünür olacaktır. Atamanın <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> elemanının kendisi için görünür olmayacağına dikkat ediniz.</p><p><a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanına bir <a href="#element-template"><span class="elemref"><tt>xsl:template</tt></span></a> elemanının başlangıcında bir çocuk olarak bulunmasına izin verilir. Bu bağlamda, atama, <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> yönergeleri hariç tüm küçük kardeşlerin astsallarına görünür olacaktır. Atamanın <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanının kendisi için görünür olmayacağına dikkat ediniz.</p><p><a name="dt-shadows" id="dt-shadows" title="Geçersizleştirme"></a><span title="Geçersizleştirme tanımı" class="termdef">Eğer bir atamanın görünür olduğu yerde başka bir atama yer alıyorsa ve bu atamalar aynı isme yapılmışsa, yeni atama o bağlamda eskisini geçersiz bırakır.</span> Aynı örneklenim içinde <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> veya <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarınca yapılmış atamaların birbirlerini <a title="Geçersizleştirme tanımı" href="#dt-shadows">geçersizleştirme</a>leri bir hatadır. Bir örneklenim içinde, <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> veya <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarınca yapılmış atamaların <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> yapılmış atamaları <a title="Geçersizleştirme tanımı" href="#dt-shadows">geçersizleştirme</a>leri hata değildir. Bu durumda, bir tepe-seviyeden atama, başka bir atamanın kendisini geçersizleştirdiği bir biçembent bölümünde görünür olmayacaktır. Bu bakımdan şu bir hatadır:</p><pre class="error">&lt;xsl:template name="foo"&gt;
  &lt;xsl:param name="x" select="1"/&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre><p>Ama, buna izin verilir:</p><div class="example"><pre>&lt;xsl:param name="x" select="1"/&gt;

&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre></div><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir örneklenim içindeki bir <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> elemanının Java dilindeki en yakın eşdeğeri, ilklendiricili bir nihai yerel değişken bildirimidir. Örneğin,<p></p><div class="example"><pre>&lt;xsl:variable name="x" select="'value'"/&gt;</pre></div><p>ile</p><div class="example"><pre>final Object x = "value";</pre></div><p>aynı anlambilgisine sahiptir. XSLT, böyle bir Java atama işlecinin bir eşdeğerini sağlamaz:</p><div class="example"><pre>x = "value";</pre></div><p>Çünkü bir belgeyi başından sonuna kadar, betik benzeri bir yöntemden başka bir yöntemle işleyen bir gerçeklenimi oluşturmak daha zor olurdu.</p></dd></dl><p></p></div><div class="div2"><h3><a name="idp14831536" id="idp14831536"></a>11.6 Değergeçlerin Örneklenimlere Aktarılması</h3><a id="element-with-param" name="element-with-param"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;xsl:with-param</span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:with-param&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Değergeçler örneklenimlere <a href="#element-with-param"><span class="elemref"><tt>xsl:with-param</tt></span></a> elemanı kullanılarak aktarılırlar. Belirtilmesi zorunlu olan <code>name</code> özniteliği değergeçin (atamanın değerini değiştirdiği değişken) ismini belirtir. <code>name</code> özniteliğinin değeri <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde belirtildiği gibi yorumlanan bir <code><a href="../xml-names#NT-QName">NitelAd</a></code>dır. <a href="#element-with-param"><span class="elemref"><tt>xsl:with-param</tt></span></a> elemanına <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> ve <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanlarının her ikisinde de izin verilir. Bir <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> veya <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanının birden fazla aynı isimli <a href="#element-with-param"><span class="elemref"><tt>xsl:with-param</tt></span></a> elemanı içermesi bir hatadır. Değergeç değeri <a href="#element-variable"><span class="elemref"><tt>xsl:variable</tt></span></a> ve <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanlarında kullanılan yöntemle belirtilir. <a href="#element-with-param"><span class="elemref"><tt>xsl:with-param</tt></span></a> ile belirtilen değerin hesaplanmasında kullanılan geçerli düğüm ve geçerli düğüm listesi, içinde kullanıldığı <a href="#element-call-template"><span class="elemref"><tt>xsl:call-template</tt></span></a> veya <a href="#element-apply-templates"><span class="elemref"><tt>xsl:apply-templates</tt></span></a> elemanlarınınkilerle aynıdır. <var>x</var> için bir <a href="#element-param"><span class="elemref"><tt>xsl:param</tt></span></a> elemanına sahip olmayan bir örneklenime bir <var>x</var> değergecini aktarmak hata değildir; değergeç basitçe yoksayılır.</p><p>Bu örnekte, sayı biçimini denetleyen bir değergeçe sahip <code>numbered-block</code> isminde bir örneklenim, değergeçine değer aktarılarak çağrılmaktadır:</p><div class="example"><pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div><p></p></div></div><div class="div1"><h2><a name="add-func" id="add-func"></a>12 Ek İşlevler</h2><p>Bu bölümde temel XPath işlev kütüphanesine ek olarak XSLT'ye özgü  işlevlere yer verilmiştir. Bu ek işlevlerin bazıları ayrıca, biçembentte <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanlar tarafından belirtilen bilgileri de kullanıma sokarlar; bu bölümde bu işlevler ayrıca açıklanacaktır.</p><div class="div2"><h3><a name="document" id="document"></a>12.1 Çok Kaynaklı Belgeler</h3><a name="function-document" id="function-document"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>düğüm-kümesi</em> <b>document</b>(<var>nesne</var>, <var>düğüm-kümesi</var>?)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-document"><code class="function">document</code></a> işlevi asıl kaynak belgeden başka XML belgelere de erişimi mümkün kılar.</p><p><a href="#function-document"><code class="function">document</code></a> işlevi tek bir argümana sahipse ve bu argüman da bir düğüm kümesi ise, sonuç, belirtilen düğüm kümesinin her düğümü için, düğümün kendi <a href="../xpath#dt-string-value">dizgesel değeri</a>nin <a href="#function-document"><code class="function">document</code></a> işlevinin ilk argümanı, düğümün üyesi olduğu düğüm kümesinin ikinci argümanı olduğu <a href="#function-document"><code class="function">document</code></a> çağrılarının sonuçlarının birleşimidir.</p><p><a href="#function-document"><code class="function">document</code></a> işlevi iki argümana sahipse ve ilk argüman bir düğüm kümesi ise, sonuç, belirtilen düğüm kümesinin her düğümü için, düğümün <a href="../xpath#dt-string-value">dizgesel değeri</a>nin <a href="#function-document"><code class="function">document</code></a> işlevinin ilk argümanı, ikinci argümanın yine ikinci argümanı olduğu <a href="#function-document"><code class="function">document</code></a> çağrılarının sonuçlarının birleşimidir.</p><p><a href="#function-document"><code class="function">document</code></a> işlevine aktarılan ilk argümanın bir düğüm kümesi olmaması halinde, ilk argüman <a href="../xpath#function-string"><b><code>string</code></b></a> işlevinin yaptığı gibi bir dizgeye dönüştürülür ve bu dizge bir tanım-yeri (URI) başvurusu olarak ele alınır; Bu tanım-yeri ile tanımlanan özkaynak alınıp getirilir. Bu algetir işleminin sonucu olan veri bir XML belge olarak çözümlenir ve veri modeline uygun ber ağaç oluşturulur (bkz, <a href="#data-model"><b>Veri Modeli</b></a>). Özkaynağın alınıp getirilmesi ile ilgili bir hata oluşmuşsa, XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Özkaynağın alınıp getirilmesi ile ilgili olası tek hata çeşidi XSLT işlemcinin tanım-yeri tarafından kullanılan tanım-yeri şemasını desteklemeyişidir. Bir XSLT işlemcinin her tanım-yeri şemasını desteklemesi gerekmez. XSLT işlemcinin belgeleri, XSLT işlemcinin hangi tanım-yeri şemalarını desteklediğini açıklamalıdır.</p><p>Eğer tanım-yeri başvurusu bir bölüm betimleyici (adresin sonunda yer alan ve # imi ile başlayan dizgecik) içermiyorsa, belgenin sadece kök düğümünü içeren bir düğüm kümesi döner. Eğer tanım-yeri başvurusu bir bölüm betimleyici içeriyorsa, tanım-yeri başvurusunun bölüm betimleyicisi tarafından betimlenen ağaçtaki düğümleri içeren bir düğüm kümesi döner. Bölüm betimleyicinin ifade ettiği anlam, tanım-yerinden alınıp getirilen özkaynağın ortam türüne bağımlıdır. Eğer bölüm betimleyicinin işlenmesi ile ilgili bir hata oluşmuşsa, XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Olası hatalar şunlar olabilir:</p><ul><li><p>Bölüm betimleyici bir XSLT düğüm kümesi tarafından ifade edilemeyecek şeyleri betimliyordur (örneğin, bir metin düğümündeki bir karakter aralığı).</p></li><li><p>XSLT işlemci tanım-yerinden alınıp getirilen özkaynağın ortam türüne özgü bölüm betimleyiciyi desteklemiyordur. Bir XSLT işlemcinin her ortam türünü desteklemesi gerekmez. XSLT işlemcinin belgeleri, XSLT işlemcinin hangi ortam türlerini desteklediğini açıklamalıdır.</p></li></ul><p>Özkaynağın alınıp getirilmesinin sonucu olan veri algetir işleminin sonucunun ortam türünden bağımsız olarak bir XML belge olarak çözümlenir; eğer tepe seviye ortam türü <code>text</code> ise, ortam türünün <code>text/xml</code> olduğu durumda uygulanan yöntemle çözümlenir; aksi takdirde, <code>application/xml</code> ortam türüne özgü yöntemle çözümlenir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Tepe-seviyeden bir <code>xml</code> ortam türü olmadığından <code>text/xml</code> veya <code>application/xml</code> ortam türünde olmayan veri yine de fiilen XML olabilir.<p></p></dd></dl><p>Tanım-yeri başvurusu göreli olabilir. İkinci argümandaki düğüm kümesinde, belgedeki sıraya göre ilk olan düğümün temel tanım-yeri (bkz, <a href="#base-uri"><b>Temel Tanım-yeri</b></a>), göreli tanım yerlerini mutlak tanım yerine dönüştürmek için temel tanım-yeri olarak kullanılır. İkinci argümanda boş düğüm kümesi ile göreli tanım-yeri belirtmek bir hatadır.  XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Eğer ikinci argüman hiç belirtilmemişse, biçembentte <a href="#function-document"><code class="function">document</code></a> işlevinin çağrıldığı ifadeyi içeren düğüm öntanımlı değerdir. Göreli tanım-yeri başvurusunun çözümlenmesini sağlaması nedeniyle, sıfır uzunluktaki bir tanım-yeri başvurusunun belgeye bir başvuru oluşuna dikkat ediniz; bu bakımdan, <code>document("")</code> ifadesi biçembendin kök düğümüne karşılıktır; biçembendin ağaç gösterimi, biçembendi kaynak belgenin başında içeren XML belgeyle tamamen aynıdır.</p><p>Eğer iki belge aynı tanım-yerine sahipse bunlar aynı belge olarak ele alınır. Karşılaştırma için kullanılan tanım-yeri, göreli tanım-yerlerini çözümlemekte kullanılan ve bir bölüm betimleyici içermeyen mutlak tanım-yeridir. Eğer ikisi de aynı belgeye aitse iki kök düğüm aynı kök düğüm olarak ele alınır. Bu bakımdan aşağıdaki ifade daima doğru sonuç verecektir:</p><div class="example"><pre>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</pre></div><p><a href="#function-document"><code class="function">document</code></a> işlevi, bir düğüm kümesinin birden fazla belgeden düğümler içermesini olasılığını arttırır.  Böyle bir düğüm kümesi ile aynı belgedeki iki düğümün göreli belge sırası XPath [<a href="#XPATH">XPath</a>] tarafından tanımlanmış normal <a href="../xpath#dt-document-order">belge sırası</a> olacaktır. İki düğümün farklı belgelerdeki göreli belge sırası, bu iki düğümü içeren belgelerin gerçeklenime bağımlı sıralamasına göre saptanır. Sürekli olarak aynı sonucu vermek dışında gerçeklenimlerin belgeleri nasıl sıralayacağıyla ilgili bir kısıtlama yoktur: Bir gerçeklenim, aynı belge kümesi için daima aynı sıralamayı yapmak zorundadır.</p></div><div class="div2"><h3><a name="key" id="key"></a>12.2 Anahtarlar</h3><p>Anahtarlar, belgelerde örtük bir çapraz başvuru yapısıyla çalışma imkanı verir. XML'deki <code>ID</code>, <code>IDREF</code> ve <code>IDREFS</code> öznitelik türleri XML belgelerin kendi çapraz başvurularını doğrudan oluşturabilmeleri için bir mekanizma sağlar. XSLT bunu XPath <a href="../xpath#function-id"><b><code>id</code></b></a> işlevi üzerinden destekler. Bununla birlikte bu mekanizmanın bazı gereklilikleri vardır:</p><ul><li><p>ID türündeki öznitelikler örneğin DTD gibi bir yerde bildirilmelidir. Eğer bir ID özniteliği bir ID türünden öznitelik olarak sadece harici bir DTD altkümesinde bildirilmişse, bu öznitelik sadece, eğer XML işlemci bu harici DTD altkümesini okursa bir ID türünde öznitelik olarak tanınacaktır. Ancak, XML Önergesi, XML işlemcilerin harici DTD altkümelerini okumasını bir zorunluluk değil, bir öneri olarak belirtir.</p></li><li><p>Bir belge eşsiz ID'lerin tek bir kümesine sahip olabilir. Ayrı ayrı bağımsız eşsiz ID kümeleri olamaz.</p></li><li><p>Bir elemanın ID'si sadece bir öznitelikte belirtilebilir; elemanın içeriğinde veya bir çocuk eleman tarafından belirtilemez.</p></li><li><p>Bir ID bir XML adı olmak zorundadır. Örneğin, boşluk içeremez.</p></li><li><p>Bir eleman en çok bir ID'ye sahip olabilir.</p></li><li><p>Belli bir ID'ye en çok bir eleman sahip olabilir.</p></li></ul><p>Bu gerekliliklerden dolayı XML belgeler, ID/IDREF/IDREFS öznitelikleriyle açıkça belirtilmese bile bir çapraz başvuru yapısına sahip olurlar.</p><p>Bir anahtar şu üçlemeye sahiptir:</p><ol class="enumar"><li><p>anahtarın sahibi olan düğüm</p></li><li><p>anahtarın ismi (bir <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>)</p></li><li><p>anahtarı değeri (bir dizge)</p></li></ol><p>Bir biçembentte her belge için anahtar kümesi <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanı kullanılarak bildirilir. Bu anahtar kümesi, <var>x</var> diye bir düğüme, <var>y</var> diye bir isme ve <var>z</var> diye bir değere sahipse, <var>x</var> düğümünün <var>z</var> değerli bir <var>y</var> anahtarı olduğundan bahsedebiliriz.</p><p>Bu bakımdan, bir anahtar, bir XML ID'sinin sınırlamalarına konu olmayan genelleştirilmiş bir ID çeşididir:</p><ul><li><p>Anahtarlar bir biçembentte <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanları kullanılarak bildirilirler.</p></li><li><p>Bir anahtarın değerinden başka bir de ismi vardır; her anahtar ismi betimleyici uzayından bağımsız, ayrı bir isim olarak düşünülebilir.</p></li><li><p>Bir isimli anahtar değeri bir eleman için, uygun herhangi bir yerde belirtilebilir; örneğin bir öznitelikte, bir çocuk elemanda veya içerikte belirtilebilir. Belli bir isimli anahtar için bulunacak değerin yerini belirtmek için bir XPath ifadesi kullanılır.</p></li><li><p>Bir anahtarın değeri keyfi bir dizge olabilir; bir XML adı olmak zorunda değildir.</p></li><li><p>Bir belgede aynı düğümün farklı anahtar değerleri için aynı isimde çok sayıda anahtarı olabilir.</p></li><li><p>Bir belgede aynı anahtar ismine ve aynı anahtar değerine sahip çok sayıda farklı düğüm olabilir.</p></li></ul><p></p><a id="element-key" name="element-key"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:key</span>
  <b>name</b> = <var>nitelikli-ad</var>
  <b>match</b> = <var>örüntü</var>
  <b>use</b> = <var>ifade</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanı anahtarları bildirmek için kullanılır. <code>name</code> özniteliği ile anahtarın ismi belirtilir. <code>name</code> özniteliğinin değeri, <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanan bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmalıdır. <code>match</code> özniteliği bir <a href="#NT-Pattern"><code>Örüntü</code></a> olup, bir <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanı, belirtilen bu örüntüyle eşleşen düğümlerin anahtarları hakkında bilgi verir. <code>use</code> özniteliği anahtarın değerini belirten bir <a title="İfade tanımı" href="#dt-expression">ifade</a> olup, örüntüyle eşleşen her düğüm için bir kere değerlendirilir. Eğer sonuç bir düğüm kümesi ise, düğüm kümesindeki her düğümün belirtilen isimde, değeri düğümün dizgesel değeri olan bir anahtarı olur; aksi takdirde, sonuç bir dizgeye dönüştürülür ve örüntüyle eşleşen düğümün belirtilen isimde değeri bu dizge olan bir anahtarı olur. Bu bakımdan, bir <var>x</var> düğümünün <var>y</var> isminde ve <var>z</var> değerinde bir anahtara sahip olması için bir <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanının sağlaması gerek ve yeter koşullar şunlardır:</p><ul><li><p><var>x</var> düğümü, <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanının <code>match</code> özniteliğinde belirtilen örüntüyle eşleşir;</p></li><li><p><a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanının <code>name</code> özniteliğinin değeri <var>y</var>'ye eşit olup,</p></li><li><p><a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanının <code>use</code> özniteliğinde belirtilen ifade, bir <var>u</var> nesnesinden elde edilen bir geçerli düğüm listesindeki geçerli düğüm olarak <var>x</var> düğümüyle değerlendirildiğinde, <var>z</var>, ya <var>u</var>'nun <a href="../xpath#function-string"><b><code>string</code></b></a> işlevinin yaptığı gibi bir dizgeye dönüştürülmesinin sonucuna eşittir ya da <var>u</var> bir düğüm kümesi olup, <var>z</var> değeri de <var>u</var>'daki düğümlerin bir veya daha fazlasının dizgesel değerine eşittir.</p></li></ul><p>Ayrıca, belli bir düğümle eşleşen birden fazla <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanı olabileceğini de aklınızdan çıkarmayın; böyle <a href="#element-key"><span class="elemref"><tt>xsl:key</tt></span></a> elemanlarının hepsi aynı <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a>ne sahip olmasalar bile kullanılırlar.</p><p><code>use</code> veya <code>match</code> özniteliğinin değer olarak bir <code><a href="../xpath#NT-VariableReference">DeğişkenGönderimi</a></code> veya bir <a href="#function-key"><code class="function">key</code></a> işlev çağrısı içermesi bir hatadır.</p><a name="function-key" id="function-key"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>düğüm-kümesi</em> <b>key</b>(<var>dizge</var>, <var>nesne</var>)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-key"><code class="function">key</code></a> işlevi ID'ler için <a href="../xpath#function-id"><b><code>id</code></b></a> işlevinin yaptığını anahtarlar için yapar. İlk argüman anahtarın ismini belirtir. Argümanın değeri <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanan bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmalıdır. İkinci argüman bir düğüm kümesi olduğunda, sonuç, bu düğüm kümesindeki her düğümün <a href="../xpath#dt-string-value">dizgesel değer</a>ine <a href="#function-key"><code class="function">key</code></a> işlevinin uygulanmasından elde edilen sonuçlarının birleşimi olacaktır. İkinci argüman herhangi bir başka türde bir değer içerdiğinde, argüman <a href="../xpath#function-string"><b><code>string</code></b></a> işlevinin yaptığı gibi bir dizgeye dönüştürülür; bu durumda, işlevden dönen sonuç, değeri bu dizgeye eşit bir isimli anahtara sahip bağlamsal düğümle aynı belgedeki düğümleri içeren bir düğüm kümesi olur.</p><a name="idp14924016" id="idp14924016"></a><dl class="example"><dt><b>Örnek: </b></dt><dd>Örneğin, şöyle bir bildirim olsun:<p></p><pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre><p><code>key('idkey', @ref)</code> ifadesi, <code>id(@ref)</code> ifadesinin sonucu olan düğüm kümesi ile döner; XML kaynak belgesinde özniteliğin ID türünde şöyle bildirilmiş olduğu,</p><pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre><p>ve geçerli düğümün <code>ref</code> özniteliğinin herhangi bir boşluk karakteri içermediği varsayımıyla.</p></dd></dl><a name="idp14928512" id="idp14928512"></a><dl class="example"><dt><b>Örnek: </b></dt><dd>Bir işlev kütüphanesini açıklayan bir belgemiz olduğunu ve işlevleri tanımlamak için bir <code>prototype</code> elemanı kullanıldığını varsayalım.<p></p><pre>&lt;prototype name="key" return-type="düğüm-kümesi"&gt;
&lt;arg type="dizge"/&gt;
&lt;arg type="nesne"/&gt;
&lt;/prototype&gt;</pre><p>İşlev isimlerinden bu tanıma atıfta bulunmak için de <code>function</code> elemanı kullanılıyor olsun.</p><pre>&lt;function&gt;key&lt;/function&gt;</pre><p>Buradan hareketle biçembent gönderimlerle tanımlar arasındaki hiper bağları şöyle üretecektir:</p><pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre><p></p></dd></dl><a name="idp14933376" id="idp14933376"></a><dl class="example"><dt><b>Örnek: (çevirmenden)</b></dt><dd><p>Bu anahtarlar konusu bu işin en zor anlaşılan kısmıdır. Yukarıdakine benzer ama yukarıdakinden her bakımdan daha yararlı olacağını umduğum bir örneği vermek istiyorum.</p><p>Bir belirtim belgemiz olsun. Belgede bahsedilen sabitlerden bazılarının tanımları varken bazıları sadece birer dizgesel sabit olsun. Tanımları olanların isimleri belgede geçtikçe (<code>&lt;literal&gt;sabit&lt;/literal&gt;</code> gibi) bu isimler bu tanımlara aynı zamanda birer hiper bağ olsun, tanımları olmayanların da birer sabit oldukları belli olsun, istiyoruz. </p><pre>&lt;xsl:template match="literal"&gt;
  &lt;xsl:variable name="idx" select="concat('value-def-', text())"/&gt;
  &lt;xsl:variable name="targets" select="key('ids', $idx)"/&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="count($targets) &gt; 0"&gt;
      &lt;a href="#{$idx}"&gt;
        &lt;code&gt;&lt;xsl:apply-templates/&gt;&lt;/code&gt;
      &lt;/a&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;tt&gt;&lt;xsl:apply-templates/&gt;&lt;/tt&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;</pre><p>Örneklenimin ilk yönergesinde bir değişken ataması yapılıyor. <code>$idx</code> değişkenine, <code>literal</code> elemanının içeriğinden bir ID değeri oluşturup bunu atıyoruz. İkinci yönergedeki değişken atamasında ise <code>$idx</code> değişkenine atadığımız ID değerini içeren düğümleri <code>$ids</code> değişkeninin değerinden alıp <code>$targets</code> değişkenine atıyoruz. Tabii bunu yapabilmek için biçembentin başlarında şöyle bir yönergemiz olması gerek (bu anahtar, belgede birer <code>id</code> özniteliğine sahip bütün elemanları toplayıp <code>$ids</code> değişkenine atar):</p><pre>&lt;xsl:key name="ids" match="*" use="@id"/&gt;</pre><p><a href="#element-when"><span class="elemref"><tt>xsl:when</tt></span></a> elemanında aradığımız ID'ye sahip eleman var mı acaba diye bir sınama yapıyoruz. Varsa, XML belgedeki  <code>&lt;literal&gt;sabit&lt;/literal&gt;</code> yerine XHTML belgeye sabitin tanımını işaret eden bir hiper bağ yerleştiriyoruz (bu bağ için gereken ID değerini bildiğimiz için bir önceki örnekte olduğu gibi bir ID üretmemiz gerekmiyor). Yoksa, içeriğini bir dizgesel sabit olduğunu vurgulayacak bir imlenimin (<code>tt</code>) içine alıyoruz.</p></dd></dl><p><a href="#function-key"><code class="function">key</code></a> işlevi daima geçerli düğümle aynı belgede yer alan düğümleri döndürür; bir anahtarı başka bir belgeden almak için önce geçerli düğümün değiştirilmesi gerekir.</p><a name="idp14946000" id="idp14946000"></a><dl class="example"><dt><b>Örnek: </b></dt><dd>Bir belgenin <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code> biçiminde kaynakça girdilerine atıfta bulunduğunu ve bu kaynakçanın da <code>bib.xml</code> adlı ayrı bir XML belgede girdilerinin şöyle bir veri modeliyle tutulduğunu varsayalım:<p></p><pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre><p>Bu durumda biçembent <code>bibref</code> elemanlarını dönüştürmek için şu kodları içerebilirdi:</p><pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:for-each select="document('bib.xml')"&gt;
    &lt;xsl:apply-templates select="key('bib',$name)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre><p></p></dd></dl></div><div class="div2"><h3><a name="format-number" id="format-number"></a>12.3 Sayı Biçimleme</h3><a name="function-format-number" id="function-format-number"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>dizge</em> <b>format-number</b>(<var>sayı</var>, <var>dizge</var>, <var>dizge</var>?)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-format-number"><code class="function">format-number</code></a> işlevi birinci argümanında belirtilen sayıyı ikinci argümanında belirtilen biçim örüntüsü dizgesini kullanarak bir dizgeye dönüştürür. Üçüncü argümanda onluk sayı biçimi belirtilir, üçüncü argümanın yokluğunda öntanımlı onluk sayı biçimi kullanılır. Biçim örüntüsü dizgesi JDK 1.1 <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html">DecimalFormat</a> sınıfı tarafından belirtilen sözdizimine sahiptir. Biçim örüntüsü dizgesinin gösterimi yerelleştirilebilir: onluk biçim örüntüdeki karakterlerin hangilerinin ne anlama geldiğini belirler (yerelleştirilmeyen tırnak karakteri hariç). Biçim örüntüsü sent imini (#x00A4) içeremez; Bu özellik için destek JDK 1.1'e ilk sürümünden sonra eklenmiştir. Onluk biçim ismi <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanan bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmalıdır. Biçembendin onluk biçimin  <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>li bir bildirimini içermemesi bir hatadır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Gerçeklenimlerin ne JDK 1.1 kullanması ne de Java dilinde geliştirme yapmaları gereklidir.<p></p></dd></dl><p></p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Biçembentler yuvarlamayı denetim altına almak için XPath'daki diğer oluşumları kullanabilirler.<p></p></dd></dl><p></p><a id="element-decimal-format" name="element-decimal-format"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:decimal-format</span>
  <code>name</code> = <var>nitelikli-ad</var>
  <code>decimal-separator</code> = <var>karakter</var>
  <code>grouping-separator</code> = <var>karakter</var>
  <code>infinity</code> = <var>dizge</var>
  <code>minus-sign</code> = <var>karakter</var>
  <code>NaN</code> = <var>dizge</var>
  <code>percent</code> = <var>karakter</var>
  <code>per-mille</code> = <var>karakter</var>
  <code>zero-digit</code> = <var>karakter</var>
  <code>digit</code> = <var>karakter</var>
  <code>pattern-separator</code> = <var>karakter</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-decimal-format"><span class="elemref"><tt>xsl:decimal-format</tt></span></a> elemanı, <a href="#function-format-number"><code class="function">format-number</code></a> işlevi tarafından kullanılan bir biçim örüntüsünün yorumlanışını denetleyen bir onluk biçim bildirir. <code>name</code> özniteliği belirtilmişse, eleman isimli bir onluk biçim belirtir. <code>name</code> özniteliğinin değeri <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi yorumlanan bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmalıdır. Öntanımlı onluk biçim bildirimi yapmak veya tüm öznitelikler (öntanımlılar dahil) için aynı değerle bildirilmiş olmadıkça aynı isimde birden fazla onluk biçim bildirimi yapmak (<a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal öncelikleri</a> farklı olsa bile) bir hatadır. Eğer bir biçembent bir öntanımlı onluk biçim bildirimi içermiyorsa, özniteliksiz <a href="#element-decimal-format"><span class="elemref"><tt>xsl:decimal-format</tt></span></a> elemanına eşdeğer bir bildirim uygulanır.</p><p><a href="#element-decimal-format"><span class="elemref"><tt>xsl:decimal-format</tt></span></a> elemanının diğer öznitelikleri JDK 1.1 <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</a> sınıfındaki yöntemlere karşılıktır. Her <code>get</code>/<code>set</code> çiftine karşılık <a href="#element-decimal-format"><span class="elemref"><tt>xsl:decimal-format</tt></span></a> elemanı için tanımlanmış bir öznitelik vardır.</p><p>Aşağıdaki öznitelikler hem biçim örüntüsündeki karakterlerin yorumlanışını denetler hem de sayının biçimlenmesi sonucu elde edilebilen karakterleri belirtirler:</p><ul><li><p><code>decimal-separator</code> özniteliği ondalık ayraç olarak kullanılacak karakteri (Türkçe için virgüldür) belirtir; öntanımlı değer nokta (<code>.</code>) karakteridir.</p></li><li><p><code>grouping-separator</code> özniteliği bölükleme için kullanılan (Türkçe için noktadır) karakteri belirtir (binler bölükleri gibi); öntanımlı değer virgül (<code>,</code>) karakteridir.</p></li><li><p><code>percent</code> özniteliği yüzde imi olarak kullanılacak karakteri (Türkçe için de % karakteridir ama sayının ardına değil önüne konur) belirtir;  öntanımlı değer yüzde (<code>%</code>) karakteridir.</p></li><li><p><code>per-mille</code> özniteliği her-milde-bir karakteri olarak kullanılacak karakteri;  öntanımlı değer Unicode her-milde-bir (<code>#x2030</code>) karakteridir.</p></li><li><p><code>zero-digit</code> özniteliği sıfır ratamı olarak kullanılacak karakteri belirtir; öntanımlı değer sıfır (<code>0</code>) rakamıdır.</p></li></ul><p>Aşağıdaki öznitelikler biçim örüntüsündeki karakterlerin yorumlanışını denetlerler:</p><ul><li><p><code>digit</code> özniteliğinde biçim örüntüsünde rakam ifade eden karakter belirtilir; öntanımlı değer diyez (<code>#</code>) karakteridir.</p></li><li><p><code>pattern-separator</code> özniteliğinde pozitif ve negatif alt örüntüleri ayırmakta kullanılan karakter belirtilir; öntanımlı değer noktalı virgül (<code>;</code>) karakteridir.</p></li></ul><p>Aşağıdaki öznitelikler biçimlenmiş sayıda yer alan karakterleri veya dizgeleri belirtmekte kullanılır:</p><ul><li><p><code>infinity</code> özniteliğinde sonsuzluğu belirtmekte kullanılan dizge belirtilir;  öntanımlı değer <code>Infinity</code> dizgesidir.</p></li><li><p><code>NaN</code> özniteliğinde NaN (Not-a-Number: bir-Sayı-Değil) değerini belirtmekte kullanılan dizge belirtilir;  öntanımlı değer <code>NaN</code> dizgesidir.</p></li><li><p><code>minus-sign</code> özniteliğinde eksi imi olarak kullanılacak karakter belirtilir; öntanımlı değer tire (<code>-</code>, #x2D) karakteridir.</p></li></ul><p></p></div><div class="div2"><h3><a name="misc-func" id="misc-func"></a>12.4 Çeşitli Ek İşlevler</h3><a name="function-current" id="function-current"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>düğüm-kümesi</em> <b>current</b>()</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-current"><code class="function">current</code></a> işlevi, tek üyesi <a title="Geçerli Düğüm tanımı" href="#dt-current-node">geçerli düğüm</a> olan bir düğüm kümesi ile döner. Son tahlilde (başka bir ifadenin içinde yer almayan bir ifadede), geçerli düğüm daima bağlamsal düğümle aynıdır. Bu bakımdan,</p><div class="example"><pre>&lt;xsl:value-of select="current()"/&gt;</pre></div><p>ile</p><div class="example"><pre>&lt;xsl:value-of select="."/&gt;</pre></div><p>aynı anlama gelir. Bununla birlikte, köşeli ayraçlar içindeki geçerli düğüm bağlamsal düğümden farklı bir düğüm olacaktır. Örneğin,</p><div class="example"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</pre></div><p>ebeveynleri <code>glossary</code> elemanları olup, değerleri geçerli düğümün <code>ref</code> özniteliğinin değerine eşit olan birer <code>name</code> özniteliğine sahip  tüm <code>item</code> elemanlarını işleyecektir. Aşağıdaki yönerge bunu yapmaz:</p><div class="example"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</pre></div><p>yönergesi</p><div class="example"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</pre></div><p>ile aynı anlama gelir. Bunlar, ebeveynleri <code>glossary</code> elemanları olup, <code>name</code> ve <code>ref</code> özniteliklerinin değerleri aynı olan tüm <code>item</code> elemanlarını işleyecektir.</p><p><a href="#function-current"><code class="function">current</code></a> işlevini bir <a title="Örüntü tanımı" href="#dt-pattern">Örüntü</a> içinde kullanmak bir hatadır.</p><dl class="note"><dt class="prefix"><b>Çevirmenin notu: </b></dt><dd>Geçerli düğümü bir değişkene atayıp işlevin yerine bu değişkeni köşeli ayraçlar içinde kullanmak da istenen sonucu verecektir.</dd></dl><a name="function-unparsed-entity-uri" id="function-unparsed-entity-uri"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>dizge</em> <b>unparsed-entity-uri</b>(<var>dizge</var>)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-unparsed-entity-uri"><code class="function">unparsed-entity-uri</code></a> işlevi, bağlamsal düğümle aynı belgede ismiyle belirtilmiş bir çözümlenmemiş öğenin tanım-yerini döndürür  (bkz, <a href="#unparsed-entities"><b>Çözümlenmemiş Öğeler</b></a>). Böyle bir öğe yoksa boş dizgeyle döner.</p><a name="function-generate-id" id="function-generate-id"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>dizge</em> <b>generate-id</b>(<var>düğüm-kümesi</var>?)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p><a href="#function-generate-id"><code class="function">generate-id</code></a> işlevi argümanında belirtilen düğüm kümesinin belgedeki sıraya göre ilk rastlanılan düğümünü eşsiz olarak betimleyen bir dizge ile döner. Eşsiz betimleyici bir ASCII harf ile başlamalı ve ASCII abecesayısal karakterlerinden oluşmalıdır. Bir gerçeklenim, aynı düğüm için daima aynı betimleyiciyi ve farklı düğümler için farklı betimleyicileri üretecek herhangi bir yöntemi seçmekte özgürdür. Bir gerçeklenim her dönüşümde aynı betimleyicileri üretmek zorunda değildir. Üretilmiş bir eşsiz betimleyicinin belgedeki mevcut (bu üretimin sonucu olmayan) eşsiz betimleyicilerden farklı olmak zorunda değildir. Eğer işleve belirtilen düğüm kümesi boşsa işlev boş dizge döndürür. Hiç argüman belirtilmemişse, bağlamsal düğüm öntanımlıdır.</p><a name="function-system-property" id="function-system-property"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>nesne</em> <b>system-property</b>(<var>dizge</var>)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p>Argüman bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olarak değerlendirilecek bir dizge olmalıdır. Bu <code><a href="../xml-names#NT-QName">NitelAd</a></code> ifadenin  etki alanındaki isim-alanı bildirimleri kullanılarak bir isme genişletilir. <a href="#function-system-property"><code class="function">system-property</code></a> işlevi bu isim tarafından betimlenen sistem gerecinin değeri olan nesne ile döner.  Böyle bir sistem gereci yoksa boş dizge döner.</p><p>Gerçeklenimlerin aşağıdaki sistem gereçlerini hepsi XSLT isim-alanında yer alacak şekilde sağlamalıdırlar:</p><ul><li><tt>xsl:version</tt>, işlemci tarafından gerçeklenmiş XSLT sürümünü belirten bir sayı; bu sayı bu belirtimin gerçeklenimi için 1.0 olmalıdır.</li><li><tt>xsl:vendor</tt>, XSLT işlemcinin üreticisini tanıtan bir dizge.</li><li><tt>xsl:vendor-url</tt>, XSLT işlemcinin üreticisinin adresini içeren bir dizge; genellikle üreticinin ev sayfasının adresidir.</li></ul><p>Üreticilerin XSLT isim-alanında başka sistem gereci tanımlamaması gerekir.</p></div></div><div class="div1"><h2><a name="message" id="message"></a>13 İletiler</h2><a id="element-message" name="element-message"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:message</span>
  <code>terminate</code> = "yes" | "no"<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:message&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p><a href="#element-message"><span class="elemref"><tt>xsl:message</tt></span></a> yönergesi XSLT işlemcisine özgü bir yöntemle bir ileti gönderir. <a href="#element-message"><span class="elemref"><tt>xsl:message</tt></span></a> yönergesinin içeriği bir örneklenimdir. <a href="#element-message"><span class="elemref"><tt>xsl:message</tt></span></a>, bir XML bölümünü oluşturacak içerik nesnelleştirilerek nesnelleştirilir. Bu XML bölümü iletinin içeriğidir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir XSLT işlemci <a href="#element-message"><span class="elemref"><tt>xsl:message</tt></span></a>  yönergesini bir uyarı kutusu  ortaya çıkararak veya bir günlük dosyasına yazarak (ya da bir konsol çıktısı olarak) gerçekleştirebilir.<p></p></dd></dl><p>Eğer <code>terminate</code> özniteliği <code>yes</code> diye bir değere sahipse, XSLT işlemcinin iletiyi gönderdikten sonra işlemi sonlandırması gerekir. Özniteliğin öntanımlı değeri <code>no</code>'dur.</p><p>Yerelleştirmenin uygun tek yolu, yerelleştirilmiş bilgiyi (ileti metni, vs.) bir XML belgeye koymaktır (biçembente ek bir girdi dosyası haline gelmek üzere).</p><a name="idp15049680" id="idp15049680"></a><dl class="example"><dt><b>Örnek: </b></dt><dd>Bir XML belgedeki Türkçe iletilerin <code>resources/tr.xml</code> dosyasında şu biçimde tutulduğunu varsayalım:<p></p><pre>&lt;messages&gt;
  &lt;message name="problem"&gt;Bir cisim yaklaşıyor.&lt;/message&gt;
  &lt;message name="error"&gt;Bir sorun saptandı.&lt;/message&gt;
&lt;/messages&gt;
</pre><p>Bu veri modelinden hareketle bir biçembentte aşağıdaki gibi bir yerelleştirme yaklaşımında bulunulabilir:</p><pre>&lt;xsl:param name="lang" select="'tr'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"/&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre><p></p></dd></dl></div><div class="div1"><h2><a name="extension" id="extension"></a>14 Eklentiler</h2><p>XSLT iki çeşit eklentiye izin verir: eklenti elemanlar ve eklenti işlevler.</p><p>XSLT'nin bu sürümü eklentilerin gerçeklenimlerini tanımlayan bir mekanizma sağlamaz. Bu yüzden, bir XSLT biçembendinin XSLT işlemciler arasında taşınabilir olması gerekiyorsa, böyle eklentileri kullanmaması gerekir. XSLT, bir XSLT biçembendinin, bir XSLT işlemcinin belli bir eklentiye desteği olup olmadığını saptamasını, eğer yoksa ne olacağını belirtilmesini sağlayacak mekanizmaları sağlar. Eğer bir XSLT biçembendi bu mekanizmaları kullanmakta dikkatliyse, eklentilerin getirilerinden yararlanması mümkün olacak ve herhangi bir XSLT gerçeklenimi ile hala çalışabilecektir.</p><div class="div2"><h3><a name="extension-element" id="extension-element"></a>14.1 Eklenti Elemanlar</h3><p><a name="dt-extension-namespace" id="dt-extension-namespace" title="Eklenti İsim-alanı"></a><span title="Eklenti İsim-alanı tanımı" class="termdef">Eleman eklenti mekanizması isim-alanlarının <b>eklenti isim-alanları</b> olarak tasarlanmasını mümkün kılar. Bir isim-alanı bir eklenti isim-alanı olarak tasarlanmışsa ve bu isim-alanından bir eleman bir örneklenimde yer alıyorsa, bu eleman bir birebir hedef eleman olmaktan ziyade bir yönerge olarak ele alınır.</span> İsim-alanı yönergenin anlambilgisini belirler.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının çocuğu olmayan bir eleman bir örneklenimde yer almayacağından XSLT-dışı <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> elemanlar burada tanımlanan eklenti elemanlarından sayılmazlar ve bu bölümdeki hiçbir şey onlara uygulanmaz.<p></p></dd></dl><p>Bir isim-alanı, bir eklenti isim-alanı olarak <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının <tt>extension-element-prefixes</tt> özniteliği veya bir birebir hedef elemanın <tt>xsl:extension-element-prefixes</tt> özniteliği ya da eklenti elemanı kullanılarak belirtilebilir. Bu özniteliklerin ikisi de önekleri boşluk ayraçlı bir liste olarak kabul ederler. Bu öneklerin herbiri bir eklenti isim-alanı olarak atanır. <code>extension-element-prefixes</code> veya <tt>xsl:extension-element-prefixes</tt> özniteliğinde belirtilmiş bir önek için bir isim-alanı bildiriminin olmaması bir hatadır. Öntanımlı isim-alanı (<code>xmlns</code> ile bildirilen) önek listesinde <code>#default</code> ismiyle bir eklenti isim-alanı olarak belirtilebilir. Bir isim-alanının eklente isim-alanı olarak atanması <code>extension-element-prefixes</code> veya <tt>xsl:extension-element-prefixes</tt> özniteliğinin kullanıldığı elemanın kökü olduğu alt ağaçta etkilidir; bir <a href="#element-stylesheet"><span class="elemref"><tt>xsl:stylesheet</tt></span></a> elemanının kökü olduğu bir alt ağaç ithal edilmiş veya içerilmiş bir biçembent içermez.</p><p>Eğer bir XSLT işlemci belli bir eklenti elemanının gerçeklenimine sahip değilse, <a href="#function-element-available"><code class="function">element-available</code></a> işlevi bu eleman ismi için olumsuz sonuç döndürmelidir. Böyle bir eklenti elemanı nesnelleştirildiğinde XSLT işlemci <a href="#fallback"><b>Son Çare</b></a> bölümünde bahsedildiği gibi bir son çareye başvurmalıdır. Bir XSLT işlemci bir örneklenim gerçeklenmemiş bir eklenti elemanı içermekte olduğundan böyle bir durumda sadece bir hata rapor etmekle kalmamalıdır.</p><p>Eğer bir XSLT işlemci belli bir eklenti elemanının gerçeklenimine sahipse, <a href="#function-element-available"><code class="function">element-available</code></a> işlevi bu eleman ismi için olumlu sonuç döndürmelidir.</p></div><div class="div2"><h3><a name="idp15072320" id="idp15072320"></a>14.2 Eklenti İşlevler</h3><p>Eğer bir <code><a href="../xpath#NT-FunctionCall">İşlevÇağrısı</a></code> ifadesindeki bir <code><a href="../xpath#NT-FunctionName">İşlevAdı</a></code> bir <code><a href="../xml-names#NT-NCName">KısaAd</a></code> değilse (yani, bir ikinokta imi içeriyorsa), bir eklenti işlev çağrısı olarak ele alınır. <code><a href="../xpath#NT-FunctionName">İşlevAdı</a></code> değerlendirme bağlamındaki isim-alanı bildirimi killanılarık bir isme genişletilir.</p><p>Eğer bir XSLT işlemci belli bir eklenti işlevinin gerçeklenimine sahip değilse, <a href="#function-function-available"><code class="function">function-available</code></a> işlevi bu eleman ismi için olumsuz sonuç döndürmelidir. Böyle bir eklenti işliv bir ifade içinde kullanılmış ve bu işlev çağrılmışsa, XSLT işlemci bunu bir hata olarak bildirmelidir. Bir XSLT işlemci bir ifade gerçeklenmemiş bir eklenti işlev içermekte olduğundan böyle bir durumda sadece bir hata rapor etmekle kalmamalıdır.</p><p>Eğer bir XSLT işlemci belli bir eklenti işlevinin gerçeklenimine sahipse, <a href="#function-function-available"><code class="function">function-available</code></a> işlevi bu eleman ismi için olumlu sonuç döndürmelidir. Böyle bir eklenti çağrılmışsa, XSLT işlemci işlevi argümanlarıyla birlikte gerçeklenime aktarmalı ve ve gerçekleniminin döndürdüğü sonucu işlev çağrısının sonucu olarak döndürmelidir.</p></div></div><div class="div1"><h2><a name="fallback" id="fallback"></a>15 Son Çare</h2><a id="element-fallback" name="element-fallback"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;xsl:fallback&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:fallback&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Normalde, bir <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> elemanı nesnelleştirmesi hiçbir şey yapmaz. Ancak, bir XSLT işlemci bir yönerge elemanı için bir son çareye başvurma durumunda kalırsa ve o yönerge elemanının bir veya daha fazla sayıda <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> çocuğu varsa, bu <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> çocuklarının her birinin sırayla nesnelleştirilmesi gerekir; aksi takdirde, bir hata bildirimi yapılmalıdır. <a href="#element-fallback"><span class="elemref"><tt>xsl:fallback</tt></span></a> elemanının içeriği bir örneklenimdir.</p><p>Eğer belli bir işlev veya eleman kullanılabilir değilse bir biçembentin nasıl davranacağını denetlemek için aşağıdaki işlevler <a href="#element-choose"><span class="elemref"><tt>xsl:choose</tt></span></a> ve <a href="#element-if"><span class="elemref"><tt>xsl:if</tt></span></a> yönergeleriyle kullanılabilir.</p><a name="function-element-available" id="function-element-available"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>mantıksal-değer</em> <b>element-available</b>(<var>dizge</var>)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p>Argüman bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olarak değerlendirilmeli ve ifade etki alanındaki isim-alanı bildirimi kullanılarak bir <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>e genişletilmeidir.  Eğer etki alanında bir öntanımlı isim-alanı varsa, <code><a href="../xml-names#NT-QName">NitelAd</a></code>ın öneksiz bir isim olarak yorumlanmasında kullanılır. <a href="#function-element-available"><code class="function">element-available</code></a> işlevinin doğru sonucunu döndürmesi için gerek ve yeter koşul genişletilmiş ismin bir yönerge ismi olmasıdır. Eğer genişletilmiş ismin isim-alanı tanım-yeri, XSLT'ninkiyle aynıysa bu isim XSLT tarafından tanımlanmış bir elemana ait demektir. Aksi takdirde, bir eklenti elemandır. Eğer genişletilmiş ismin isim-alanı tanım-yeri tanımsızsa, <a href="#function-element-available"><code class="function">element-available</code></a> işlevi olumsuz sonuç döndürecektir.</p><a name="function-function-available" id="function-function-available"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><em>mantıksal-değer</em> <b>function-available</b>(<var>dizge</var>)</pre></td><td align="right" valign="top" style="font-variant: small-caps;">İşlev</td></tr></table><p>Argüman bir <code><a href="../xml-names#NT-QName">NitelAd</a></code> olarak değerlendirilmeli ve ifade etki alanındaki isim-alanı bildirimi kullanılarak bir <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>e genişletilmeidir. <a href="#function-function-available"><code class="function">function-available</code></a> işlevinin doğru sonucunu döndürmesi için gerek ve yeter koşul genişletilmiş ismin işlev kütüphanesindeki bir işlevin ismi olmasıdır. Eğer genişletilmiş isim tanımlı bir isim-alanına sahipse, isim bir eklenti işleve ati demektir, aksi takdirde XPath vya XSLT tarafından tanımlanmış bir işleve aittir.</p></div><div class="div1"><h2><a name="output" id="output"></a>16 Çıktı</h2><a id="element-output" name="element-output"></a><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;xsl:output</span>
  <code>method</code> = "xml" | "html" | "text" | <var>nitelikli-ad-ama-kısa-ad-değil</var>
  <code>version</code> = <var>ad-dizgeciği</var>
  <code>encoding</code> = <var>dizge</var>
  <code>omit-xml-declaration</code> = "yes" | "no"
  <code>standalone</code> = "yes" | "no"
  <code>doctype-public</code> = <var>dizge</var>
  <code>doctype-system</code> = <var>dizge</var>
  <code>cdata-section-elements</code> = <var>nitelikli-adlar</var>
  <code>indent</code> = "yes" | "no"
  <code>media-type</code> = <var>dizge</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><p>Bir XSLT işlemci hedef ağacı bir bayt dizisi olarak çıktılayabilir (böyle olması gerekmese bile; <a href="#conformance"><b>Uyumluluk</b></a> bölümüne bakınız). <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı biçembent yazarına hedef ağacın nasıl çıktılanmasını istediğini belirtebilme imkanı verir. Eğer bir XSLT işlemci hedef ağacı çıktılıyorsa, bu, <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı tarafından belirtilmiş demektir; ancak bunun böyle olması gerekli değildir.</p><p><a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanına sadece bir <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> eleman olarak izin verilir.</p><p>The <code>method</code> özniteliğinde hedef ağacın çıktılanma yöntemi belirtilir. Değer bir  <code><a href="../xml-names#NT-QName">NitelAd</a></code> olmalıdır. Eğer bu  <code><a href="../xml-names#NT-QName">NitelAd</a></code> bir önek içermiyorsa, bu belgede belirtilmiş yöntemlerden biri olarak ele alınır ve <code>xml</code>, <code>html</code> veya <code>text</code> değerlerinden biri olmalıdır. Eğer bu  <code><a href="../xml-names#NT-QName">NitelAd</a></code> bir önek içeriyorsa, <a href="#qname"><b>Nitelikli Adlar</b></a> bölümünde açıklandığı gibi bir <a href="../xpath#dt-expanded-name">genişletilmiş isim</a>e genişletilir; genişletilmiş isim çıktılama yöhtemini belirtir; bu durumdaki davranışın ne olacağı bu belgede belirtilmemiştir.</p><p><code>method</code> özniteliği için öntanımlı davranış şöyle seçilir. Eğer,</p><ul><li><p>hedef ağacın kök düğümünün çocuğu varsa,</p></li><li><p>hedef ağacın kök düğümünün (yani, belge elemanının) ilk çocuğunun genişletilmiş isminin yerel kısmı <code>html</code> (büyük/küçük harflerin herhangi bir birleşimi olarak) ise ve isim-alanı tanım-yeri tanımsızsa ve</p></li><li><p>hedef ağacın kök düğümünün ilk çocuğunu önceleyen metin düğümleri sadece boşluk karakterlerinden oluşuyorsa,</p></li></ul><p>öntanımlı çıktılama yöntemi <code>html</code> olacaktır; aksi takdirde <code>xml</code>'dir.  Öntanımlı çıktılama yöntemi eğer bir <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı belirtilmemişse veya <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı <code>method</code> özniteliksiz belirtilmişse kullanılmalıdır.</p><p><a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanının diğer öznitelikleri çıktılama yönteminin parametreleridir. Şu özniteliklere izin verilir:</p><ul><li><p><code>version</code> çıktılama yönteminin sürümünü belirtir.</p></li><li><p><code>indent</code> XSLT işlemcinin hedef ağacı çıktılarken, boşluk karakterleri ekleyebileceğini belirtir; değer, ekleyebilecekse <code>yes</code> aksi takdirde <code>no</code> olmalıdır.</p></li><li><p><code>encoding</code>, XSLT işlemci karakter dizilerini bayt dizileri olarak çıktılarken kullanacağı karakter kodlaması için tercihi belirtirken kullanılır; değerin harf büyüklüğünün bir önemi yoktur; değer sadece [#x21-#x7E] aralığındaki karakterleri (yani basılabilir ASCII karakterleri) içerebilir; değer ya Genel Ağ Atanmış numaralar Yetkilisi [<a href="#IANA">IANA</a>] tarafından kayda geçirilmiş karakter kümelerinden biri olmalı yoksa <code>X-</code> ile başlamalıdır.</p></li><li><p><code>media-type</code> ile hedef ağacın çıktılanmasının sonucu olan verinin ortam türü (MIME türü) belirtilir; karakter kümesi parametresi doğrudan belirtilmemeli; bunun yerin, tepe-seviyeden ortam türü <code>text</code> olduğu takdirde, çıktılama yöntemi tarafından kullanılan asıl kodlamaya ait olan karakter kümesi parametresi eklenmelidir.</p></li><li><p><code>doctype-system</code> ile belge türü bildiriminde (DTD) kullanılan sistem betimleyici belirtilir.</p></li><li><p><code>doctype-public</code> ile belge türü bildiriminde (DTD) kullanılan genel betimleyici belirtilir.</p></li><li><p><code>omit-xml-declaration</code> ile XSLT işlemcinin bir XML bildirimi çıktılayıp çıktılamayacağı belirtilir; XML bildiriminin çıktılanması isteniyorsa değer <code>yes</code>, aksi takdirde <code>no</code> olmalıdır.</p></li><li><p><code>standalone</code> ile XSLT işlemcinin bir tekbaşına belge bildirimi çıktılayıp çıktılamayacağı belirtilir; tekbaşına belge bildiriminin çıktılanması isteniyorsa değer <code>yes</code>, aksi takdirde <code>no</code> olmalıdır.</p></li><li><p><code>cdata-section-elements</code> özniteliği, CDATA bölümleri halinde çıktılanacak metin düğümü çocukları olan elemanların isimlerini liste halinde belirtmek için kullanılır.</p></li></ul><p>Her özniteliğin her çıktılama yöntemi için anlamı ayrı ayrı çıktılama yöntemlerinin açıklamalarında açıklanacaktır.  Çıktılama yöntemi açıklamalarında yer verilmemiş öznitelikler o çıktılama yöntemi için uygulanabilir değillerdir.</p><p>Bir biçembent çık sayıda <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı içerebileceği gibi, ithal ettiği veya içerdiği biçembentlerin her birinde de çok sayıda <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı olabilir. Bir biçembentte yer alan tüm <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanları tek bir etkin <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı olarak birleştirilir. <code>cdata-section-elements</code> özniteliği için etkili değer belirtilmiş değerlerin birleşimidir. Diğer öznitelikler için etkili değer, en yüksek <a title="İthal Önceliği tanımı" href="#dt-import-precedence">ithal önceliği</a> ile belirtilmiş olan değerdir. Bir öznitelik için böyle birden fazla değerin varlığı bir hatadır. Bir XSKLT işlemci hatalı raporlayabilir, raporlamıyorsa, biçembentte son yer alan değeri kullanarak hatadan kurtulmalıdır. Özniteliklerin öntanımlı değerleri <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanları birleştirildikten sonra saptanır; farklı çıktılama yöntemleri için bazı özniteliklerin öntanımlı değerleri farklı olabilir.</p><div class="div2"><h3><a name="idp15168928" id="idp15168928"></a>16.1 XML Çıktılama Yöntemi</h3><p><code>xml</code> çıktılama yöntemi, hedef ağacı bir iyi biçimli XML harici genel çözümlü öğe olarak çıktılar. Eğer hedef ağcın kök düğümü tek bir çocuk elemana sahipse ve hiç metin düğümü çocuğu yoksa, öğenin ayrıca iyi biçimli XML belge öğesi olması gerekir. Şunun gibi sıradan bir XML belge sarmalayıcı içindeki bir öğeye atıfta bulunurken,</p><div class="example"><pre>&lt;?xml version="<var>xml-sürümü</var>"?&gt;
&lt;!DOCTYPE doc [
&lt;!ENTITY e SYSTEM "<var>öğenin-yeri</var>"&gt;
]&gt;
&lt;doc&gt;&amp;e;&lt;/doc&gt;</pre></div><p><var>öğenin-yeri</var> ile öğenin dosya sistemindeki yeri, <var>xml-sürümü</var> ile de öğenin XML sürümü belirtiliyorsa, atıfta bulunulan elemanın bir bütün olarak [<a href="#XMLNAMES">XML Adları</a>] veya [<a href="#XMLNAMES11">XML Adları 1.1</a>] ile uyumlu bir iyi biçimli XML belge olması gerekir. Ek olarak, yeni ağaç, öğenin <a href="#data-model"><b>Veri Modeli</b></a> bölümünde belirtildiği gibi bir XML belge olarak çözümlenmesiyle oluşmuşsa, belge elemanı kaldırıldıktan sonra, onun çocuklarını kök düğümün çocukları yaparak oluşturulan yeni ağaç aşağıdaki olasılıkların dışında hedef ağaçla aynı olacaktır:</p><ul><li><p>Öznitelik ve isim-alanı düğümlerinin sırası iki ağaçta farklı olabilir.</p></li><li><p>yeni ağaç, hedef ağaçta mevcut olmayan isim-alanı düğümleri içerebilir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Bir XSLT işlemci hedef ağacın XML olarak çıktılanması durumunda isim-alanı bildirimlerini eklemek ihtiyacı duyabilir.<p></p></dd></dl><p></p></li><li><p>Düğümlerin temel tanım-yerleri iki ağaçta farklı olabilir.</p></li></ul><p>Eğer XSLT işlemci, <code>doctype-system</code> özniteliği sebebiyle bir belge türü bildirimli veya <code>standalone</code> özniteliği sebebiyle tekbaşına belge bildirimli çıktılama yapıyorsa, çıktının bir iyi biçimli XML belge olması ve yukarıdaki gereksinimlerin, herhangi bir sarmalayıcı olmaksızın, DTD'yi işleme sokmayan bir XML işlemci kullanılarak belgenin doğrudan çözümlenmesiyle oluşturulan ağaca uygulanması gerekir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>DTD'nin işlenmesi, öznitelik öntanımlaması sebebiyle, ağaçta ek özniteliklerin yer almasına sebep olabilir.<p></p></dd></dl><p><code>version</code> özniteliği hedef ağacı çıktılarken kullanılacak XML sürümünü belirtmek için kullanılır. Eğer XSLT işlemci bu XML sürümünü desteklemiyorsa, desteklediği XMl sürümünü kullanmalıdır.  Eğer çıktı xML bildirimini içerecekse, bu bildirimde XSLT işlemcinin desteklediği sürüm numarasına karşı düşen çıktılama yapılmalıdır. Öntanımlı değer 1.0'dır. Eğer değer 1.1 ise ve XSLT işlemci XML 1.1 ve XML 1.1 için İsim-alanlarını destekliyorsa, çıktıya aşağıdaki kısıtlamalar uygulanır:</p><ul><li><p>Bildirimsiz önekler yer almamalıdır</p></li><li><p>Unicode normalleştirmesi yer almamalıdır.</p></li></ul><p><code>encoding</code> özniteliğiyle hedef ağacı çıktılamakta kullanılacak karakter kodlaması tercihi belirtilir. XSLT işlemcilerinin <code>UTF-8</code> ve <code>UTF-16</code> değerlerini kabul etmeleri gerekir. Diğer değerler için, eğer XSLT işlemci bunları desteklemiyorsa bunu hata olarak raporlayabiyir, raporlamıyorsa, <code>UTF-8</code> veya <code>UTF-16</code> kodlanmış çıktılama yapmalıdır. XSLT işlemci, [<a href="#XML">XML</a>] ve [<a href="#XML11">XML 1.1</a>] önergelerinin <code><a href="../xml#NT-EncName">KodlamaAdı</a></code> sözdizimi ile eşleşmeyen kodlama isimlerini kullanmaması gerekir. <code>encoding</code> özniteliği kullanılmamışsa, XSLT işlemcinin <code>UTF-8</code> veya <code>UTF-16</code> kodlanmış çıktılama yapması gerekir.</p><p>Hedef ağacın, XSLT işlemcinin çıktılama için kullandığı kodlamada bulunmayan bir karakteri içermesi olasıdır. Bu durumda, eğer karakter XML'in karakter gönderimlerini tanıdığı bir bağlamda yer alıyorsa (örn, bir öznitelik değerinde veya bir metin düğümünde),  karakterin bir karakter gönderimi olarak çıktılanması gerekir; aksi takdirde (örn, karakter bir eleman isminde yer alıyorsa), XSLT işlemci hatayı raporlamalıdır.</p><p>Eğer <code>indent</code> özniteliği <code>yes</code> değeri ile kullanılmışsa, <code>xml</code> çıktılama yöntemi, sonucun göze hoş görünecek şekilde girintilenmesi için hedef ağaçta mevcut boşluk karakterlerine ek olarak (muhtemelen biçembent ve kaynak belgedeki boşluk ayıklamaya uygun olarak), ek boşluklar çıktılayabilir; eğer özniteliğin değeri olarak <code>no</code> belirtilmişse, ilave bir boşluk çıktılanmayacaktır. Öntanımlı değer <code>no</code>'dur. <code>xml</code> çıktılama yöntemi ek boşlukları çıktılamak için bir algoritma kullanmalıdır; bu algoritma,
boşluklar çıktıdan ayıklanırken, sadece <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> elemanlarından oluşan boşlukları korunacak elemanlar listesiyle <a href="#strip"><b>Boşluk Ayıklama</b></a> bölümünde açıklandığı gibi ayıklanıyorsa, ek boşlukların çıktılanması ile çıktılanmaması arasında bir fark olmayacak şekilde çıktılamayı sağlamalıdır.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>Karışık içerikli eleman türleri içeren belge türleri için <code>indent="yes"</code> kullanmak iyi sonuç vermeyecektir.<p></p></dd></dl><p><code>cdata-section-elements</code> özniteliği boşluk ayraçlı olarak <code><a href="../xml-names#NT-QName">NitelAd</a></code>lardan oluşan bir liste içerebilir. Her <code><a href="../xml-names#NT-QName">NitelAd</a></code> yer aldığı <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanında etkili olan isim-alanı bildirimleri kullanılarak bir genişletilmiş isme genişletilir; eğer bir öntanımlı isim-alanı varsa, öneksiz <code><a href="../xml-names#NT-QName">NitelAd</a></code>lar kullanılır. Genişletme işlemi çok sayıda <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a> elemanı tek bir <a href="#element-output"><span class="elemref"><tt>xsl:output</tt></span></a>  elemanı olarak birleştirilmeden önce yapılır. Eğer bir metin düğümünün ebeveyninin genişletilmiş ismi bu listenin bir üyesiyse, metin düğümü bir CDATA bölümü olarak çıktılanacaktır. Örneğin,</p><div class="example"><pre>&lt;xsl:output cdata-section-elements="example"/&gt;</pre></div><p>yönergesi, biçembentte</p><div class="example"><pre>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</pre></div><p>veya</p><div class="example"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div><p>olarak yer alan bir birebir hedef elemanının şöyle çıktılanmasına sebep olacaktır:</p><div class="example"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div><p>Eğer metin düğümü <code>]]&gt;</code> dizgesini içeriyorsa, açık olan CDATA bölümü <code>]]</code> karakterlerinden sonra kapanır ve <code>&gt;</code> karakterinden önce yenisi açılır. Örneğin, bir birebir hedef elemanı biçembentte şöyle yer alıyor olsun:</p><div class="example"><pre>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</pre></div><p>Bunun çıktısı şöyle olurdu:</p><div class="example"><pre>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</pre></div><p>Eğer metin düğümü hedef ağacı çıktılamakta kullanılan karakter kodlaması ile gösterilemeyecek bir karakter içeriyorsa, açık olan CDATA bölümü bu karakterden önce kapatılmalı, karakter bir karakter veya öğe gönderimi olarak çıktılandıktan sonra metnin kalanı için yeni bir CDATA bölümü açılmalıdır.</p><p>CDATA bölümleri, <code>cdata-section-elements</code> özniteliğinde açıkça CDATA bölümü olarak çıktılanmak üzere belirtilmiş olan metin düğümleri haricinde kullanılmamalıdır.</p><p><code>xml</code> çıktılama yönteminin, <code>omit-xml-declaration</code> özniteliği <code>yes</code> değeri ile kullanılmış olmadıkça bir XML bildirimi çıktılaması gereklidir. XML bildirimi hem hem sürüm bilgisi hem de karakter kodlaması belirtimini içermelidir. Eğer <code>standalone</code> özniteliği belirtilmişse, bir tekbaşına belge bildiriminin de <code>standalone</code> özniteliğinde belirtilen değerle XML bildiriminde yer alması gerekir. Aksi takdirde, XML bildirimi bir tekbaşına belge bildirimi içermemelidir. Bu kural, hem XML bildirimine (bir belge öğesinin başında bulunur) hem de metin bildirimine (bir harici genel çözümlü öğenin başında bulunur) uygulanır.</p><p>Eğer <code>doctype-system</code> özniteliği belirtilmişse, <code>xml</code> çıktılama yöntemi, ilk elemandan hemen önce bir belge türü bildirimi çıktılayacaktır. <code>&lt;!DOCTYPE</code>'i takibeden isim ilk elemanın ismiyle aynı olmak zorundudır. Bir de <code>doctype-public</code> özniteliği belirtilmişse, <code>xml</code> çıktılama yöntemi, bir <code>PUBLIC</code> ile bunu izleyen bir genel betimleyici ve bir sistem betimleyicisi çıktılayacaktır; aksi takdirde, bir <code>SYSTEM</code> ile bunu izleyen bir sistem betimleyicisi çıktılayacaktır. Dahili altküme boş olmalıdır. <code>doctype-system</code> özniteliği belirtilmiş olmadığı takdirde, <code>doctype-public</code> özniteliği yok sayılmalıdır.</p><p><code>media-type</code> özniteliği <code>xml</code> çıktılama yöntemi için uygulanabilir olup öntanımlı değeri <code>text/xml</code>'dir.</p></div><div class="div2"><h3><a name="idp15231760" id="idp15231760"></a>16.2 HTML Çıktılama Yöntemi</h3><p><code>html</code> çıktılama yöntemi hedef ağacı HTML olarak çıktılar; örnek:</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

...

&lt;/xsl:stylesheet&gt;</pre></div><p><code>version</code> özniteliği ile HTML sürümü belirtilir ve öntanımlı değeri <code>4.0</code> olup, çıktının HTML 4.0 [<a href="#HTML">HTML</a>] önergesi ile uyumlu olacağını belirtir.</p><p><code>html</code> çıktılama yöntemi, genişletilmiş ismi tanımsız bir isim-alanı tanım-yerine sahip olmadıkça bir elemanı <code>xml</code>  çıktılama yönteminden farklı bir biçimde çıktılamamalıdır; genişletilmiş ismi tanımlı bir isim-alanı tanım-yerine sahip bir eleman XML olarak çıktılanmalıdır. Eğer bir elemanın genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahipse, ancak genişletilmiş ismin yerel kısmı bir HTML eleman olarak tanınmıyorsa, <code>span</code> gibi bir satıriçi eleman olarak boş olmayacak şekilde çıktılanmalıdır.</p><p><code>html</code> çıktılama yöntemi, boş elemanlar için bir bitiş etiketi çıktılamamalıdır. HTML 4.0 için boş elemanlar,
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> ve
<code>param</code> elemanlarıdır. Örneğin bir eleman biçembette <code>&lt;br/&gt;</code> veya <code>&lt;br&gt;&lt;/br&gt;</code>  biçiminde yazılmışsa, çıktı <code>&lt;br&gt;</code> olacaktır.</p><p><code>html</code> çıktılama yöntemi, HTML elemanlarının isimlerini harf büyüklüğüne duyarsız biçimde algılamalıdır. Örneğin, <code>br</code>, <code>BR</code> veya <code>Br</code> HTML için <code>br</code> elemanı olup bitiş elemanı olmaksızın çıktılanmalıdır.</p><p><code>html</code> çıktılama yöntemi, <code>script</code> ve <code>style</code> elemanlarının içeriği için önceleme uygulamamalıdır. Örneğen bir biçembentte bir birebir hedef eleman şöyle yer alıyor olsun:</p><div class="example"><pre>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</pre></div><p>veya</p><div class="example"><pre>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</pre></div><p>için çıktı şöyle olacaktır:</p><div class="example"><pre>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</pre></div><p><code>html</code> çıktılama yöntemi, öznitelik değerlerinde yer alan <code>&lt;</code> karakterlerini öncelememelidir.</p><p>Eğer <code>indent</code> özniteliğini değeri <code>yes</code> ise, <code>html</code> çıktılama yöntemi, HTML tarayıcısının çıktıyı oluşturma yöntemini değiştirmediği sürece hedef ağaca çıktılanan boşluk karakterlerine ekleme yapabileceği gibi bunları silebilir de.</p><p><code>html</code> çıktılama yöntemi, HTML 4.0 Önergesinin <a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">B 2.1</a> ek bölümünde önerilen yöntemi kullanarak tanım-yeri (URI) öznitelik değerlerindeki ASCII olmayan karakterleri öncelemelidir.</p><p><code>html</code> çıktılama yöntemi, bir karakteri, eğer çıktılama yönteminde kullanılan HTML sürümünde tanımlıysa, bir karakter öğesi gönderimi kullanarak çıktılayabilir.</p><p><code>html</code> çıktılama yöntemi, işlem yönergelerini <code>?&gt;</code> ile değil, <code>&gt;</code> ile sonlandırmalıdır.</p><p><code>html</code> çıktılama yöntemi, mantıksal değerli öznitelikleri (değerleri olarak kendi isimleri verilmiş öznitelikler) kısaltılmış biçimde çıktılamalıdır. Örneğin başlangıç etiketi,</p><div class="example"><pre>&lt;OPTION selected="selected"&gt;</pre></div><p>biçiminde yazılmışsa, bunun çıktısı şöyle olurdu:</p><div class="example"><pre>&lt;OPTION selected&gt;</pre></div><p><code>html</code> çıktılama yöntemi, bir öznitelik değerinde <code>{</code> karakterinin önünde bir <code>&amp;</code> karakteri yer alıyorsa bu karakteri öncelememelidir (HTML 4.0 Önergesinin <a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">B 7.1.1</a> ek bölümüne bakınız). Örneğin bir biçembentte bir başlangıç etiketi şöyle yer alıyor olsun:</p><div class="example"><pre>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</pre></div><p>Bu örneklenim şöyle çıktılanmalıdır:</p><div class="example"><pre>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</pre></div><p><code>encoding</code> özniteliği ile tercih edilen karakter kodlaması belirtilir. Bir <code>HEAD</code> elemanı varsa <code>html</code> çıktılama yöntemi bu elemanın başlangıç etiketinin hemen ardına kullanılan karakter kodlamasının belirtildiği bir <code>META</code> elemanını eklemesi gerekir. Örnek:</p><div class="example"><pre>&lt;HEAD&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</pre></div><p>Hedef ağacın, XSLT işlemcinin çıktılama için kullandığı karakter kodlamasında bulunmayan bir karakteri içermesi olasıdır. Eğer bu karakter, HTML'nin karakter gönderimlerini tanıdığı bir bağlamda yer alıyorsa, karakter bir karakter öğesi gönderimi olarak veya onluk sayılı karakter gönderimi olarak çıktılanmalıdır; aksi takdirde (örneğin, bir <code>script</code> veya <code>style</code> elemanında veya bir açıklamada), XSLT işlemci durumu hata olarak bildirmelidir.</p><p>Eğer <code>doctype-public</code> veya <code>doctype-system</code> öznitelikleri belirtilmişse, <code>html</code> çıktılama yönteminin ilk elemandan hemen önce bir belge türü bildirimi çıktılaması gerekir. Bu bildirimde, <code>&lt;!DOCTYPE</code> dizgesinden sonra gelen isim <code>HTML</code> veya <code>html</code> olmalıdır. <code>doctype-public</code> özniteliği belirtilmişse, öznitelik değerini (genel betimleyici) <code>PUBLIC</code> ibaresinden sonra eklemelidir; <code>doctype-system</code> özniteliği de ayrıca belirtilmişse, bunun değerinin (sistem betimleyici) de genel betimleyicinin ardından çıktılanması gerekir. Eğer <code>doctype-system</code> özniteliği, <code>doctype-public</code> olmaksızın tek başına belirtilmişse, çıktılama yöntemi bu değeri <code>SYSTEM</code> ibaresinin ardına ekleyerek çıktılamalıdır.</p><p><code>media-type</code> özniteliği de <code>html</code> çıktılama yönteminde uygulanabilir olup öntanımlı değeri <code>text/html</code>'dir.</p></div><div class="div2"><h3><a name="idp15287264" id="idp15287264"></a>16.3 Metin Çıktılama Yöntemi</h3><p><code>text</code> çıktılama yöntemi, hedef ağacı çıktıda, hedef ağaçtaki her metin düğümünün değerini  belgedeki sıraya uygun olarak ve buna herhangi bir önceleme uygulamaksızın çıktılamak suretiyle oluşturur.</p><p><code>media-type</code> özniteliği <code>text</code> çıktılama yönteminde uygulanabilir olup öntanımlı değeri <code>text/plain</code>'dir..</p><p><code>encoding</code> özniteliği ile <code>text</code> çıktılama yönteminin karakter dizilerini bayt dizilerine dönüştürürken kullanacağı karakter kodlaması belirtilir. Öntanımlı değer sisteme bağlıdır. Eğer hedef ağaç, XSLT işlemcinin çıktılama için kullandığı karakter kodlamasıyla ifade edilemeyen bir karakter içeriyorsa, XSLT işlemcinin bunu bir haka olarak bildirmesi gerekir.</p></div><div class="div2"><h3><a name="disable-output-escaping" id="disable-output-escaping"></a>16.4 Çıktı Önceleniminin İptal Edilmesi</h3><p>Normalde, <code>xml</code> çıktılama yöntemi &amp; ve &lt; karakterlerini (ve olası diğer karakterleri) metin düğümlerini çıktılarken önceler. Bu, çıktının iyi biçimli XML olması için gereklidir. Bununla birlikte, bazan çıktının iyi biçimli XML olarak çıktılanmaması daha uygun olabilir; örneğin, çıktı, sonradan XML'e duyarlı olmayan bir süreç tarafından iyi biçimli XML'e dönüştürüleceği düşünülen yetersiz biçimlenmiş bölümler içerebilir. Bu amaca uygun olarak, XSLT, çıktı önceleniminin iptalini mümkün kılan bir mekanizma sağlar. <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> ve <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> elemanlarının <code>disable-output-escaping</code> diye, <code>no</code> öntanımlı olmak üzere değer olarak sadece <code>yes</code> veya <code>no</code> kabul eden bir öznitelikleri olabilir; eğer değer <code>yes</code> ise, <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> veya <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> ile üretilen metin düğümü herhangi bir öncelenim uygulanmaksızın çıktılanacaktır. Örnek:</p><div class="example"><pre>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</pre></div><p>yönergesi tek bir <code>&lt;</code> karakteri üretecektir.</p><p>Bir kök düğüm, öncelenim, kök düğümünün astsalları için iptal edilmiş durumda bir <a href="#element-copy-of"><span class="elemref"><tt>xsl:copy-of</tt></span></a> elemanı kullanılarak kopyalanırken (bkz <a href="#copy-of"><b>Değişken ve Değergeçlerin Değerlerinin xsl:copy-of ile Kullanımı</b></a>), öncelenim, metin düğümünün çıktılanan kopyası için ayrıca iptal edilmiş olmalıdır. Örnek:</p><div class="example"><pre>&lt;xsl:variable name="x"&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
&lt;/xsl:variable&gt;
&lt;xsl:copy-of select="$x"/&gt;</pre></div><p>Bu örneklenim &amp;lt; değil &lt; çıktılayacaktır.</p><p>Bir metin düğümü için çıktı önceleniminin iptal edilmiş oluşunun hedef ağaçta metin düğümünün çıktılanması amacının dışında kullanılması bir hatadır. Bu bakımdan, bir açıklama, işlem yönergesi veya bir öznitelik düğümünü üretmek için bir <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> veya <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> elemanını, çıktı öncelenimini iptal ederek kullanmak bir hatadır; ayrıca, eğer hedef ağaç bölümü öncelenimin iptal edildiği bir metin düğümü içeriyorsa, bir <a title="Hedef Ağaç Bölümü tanımı" href="#dt-result-tree-fragment">hedef ağaç bölümünü</a> bir sayı veya dizgeye dönüştürmek de bir hatadır. Her iki durumda da, bir XSLT işlemci htayı raporlayabilir, raporlamıyorsa, <code>disable-output-escaping</code> özniteliğini yoksayarak hatadan kurtulmalıdır.</p><p><code>disable-output-escaping</code> özniteliği <code>xml</code> çıktılama yönteminden başka <code>html</code> çıktılama yönteminde de kullanılabilir. <code>text</code> çıktılama yönteminde herhangi bir çıktı öncelenimi zaten yapılmadığından, <code>disable-output-escaping</code> özniteliği yoksayılır.</p><p>Bir XSLT işlemcinin çıktı öncelenimini iptal edebileceği tek durum, hedef ağacın nasıl çıktılanacağını denetleyebildiği durumdur. Yine de, bu hep böyle olmayabilir. Örneğin, hedef ağaç çıktılanmak yerine başka bir hedef ağacın çıktılanmasına kaynaklık edebilir. Bu durumda XSLT işlemcinin çıktı önceleniminin iptal edilmesini desteklemesi gerekmez. Eğer bir <a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> veya <a href="#element-text"><span class="elemref"><tt>xsl:text</tt></span></a> elemanı çıktı öncelenimi iptal edilerek kullanılmışsa ve XSLT işlemci de bunu desteklemiyorsa, XSLT işlemci durumu hata olarak raporlayabilir, raporlamıyorsa, çıktı öncelenimini iptal etmeyerek hatadan kurtulmalıdır.</p><p>Eğer çıktı öncelenimin iptali, XSLT işlemcinin çıktılama için kullandığı kodlama tarafından desteklenmeyen bir karakter için kullanılmışsa, XSLT işlemci durumu bir hata olarak raporlayabilir, raporlamıyorsa, çıktı öncelenimini iptal etmeyerek hatadan kurtulmalıdır.</p><p>Çıktı önceleniminin iptali bütün XSLT işlemcilerle çalışmayabileceğinden ve XML için çıktı iyi biçimli olmayabileceğinden sadece başka çare yoksa kullanılmalıdır.</p></div></div><div class="div1"><h2><a name="conformance" id="conformance"></a>17 Uyumluluk</h2><p>Bir uyumlu XSLT işlemci, bir biçembendi bir kaynak ağacı bir hedef ağaca bu belirtimde belirtildiği gibi dönüştürmek için kullanabilen işlemcidir. Bir uyumlu XSLT işlemciden beklenen, sonucu XML veya bir başka biçimde çıktılayabiliyor olması değildir.</p><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XSLT işlemci üreticilerine, işlemcilerinin hedef ağacı XML olarak çıktılarken uyumlu davranmakta olduğunu doğrulayacak bir yöntem sunmaları   veya hedef ağaca DOM veya SAX gibi bir standart yazılım geliştirme arayüzü üzerinden erişmeye imkan sağlamaları önemle tavsiye edilir.<p></p></dd></dl><p>Bir uyumlu XSLT işlemci, bu belgede özellikle bir XSLT işlemci tarafından bildirilmemesinin istendiği durumlar haricindeki bütün hataları bildirmesi gerekir. Bir uyumlu XSLT işlemciden beklenen, bildirdiği hatalı durumdan  kurtarabilmesi değildir, ama kurtarabilirse iyi olur.</p><p>Bir uyumlu XSLT işlemci, bir biçembendin işlenmesi için gereken sistem kaynaklarının sınırları konusunda belirleyici olmayabilir.</p></div><div class="div1"><h2><a name="notation" id="notation"></a>18 Gösterim</h2><p>Her XSLT tanımlı eleman türünün belirtiminde önce o eleman türünden elemanlar için bir model teşkil edecek şekilde bir sözdizimi özeti verilmiştir. Bu özet sözdizimi gösterimine anlam yükleme işlemi şöyle yapılmıştır:</p><ul><li><p>Kullanımı zorunlu bir öznitelik kalın yazıyla belirtilmiştir.</p></li><li><p>Bir öznitelik değeri olarak görünen dizge, özniteliğin izin verilen değerlerini belirtir. Eğer bir değer, kaşlı ayraçlar arasına alınmışsa, öznitelik değeri bir <a title="Öznitelik Değeri Örneklenimi tanımı" href="#dt-attribute-value-template">öznitelik değeri örneklenimi</a> (bazı hata iletilerinde AVT şeklinde bir kısaltma olarak karşınıza çıkabilir) olarak ele alınır ve kaşlı ayraçlar arasında yer alan dizge, öznitelik değeri örnekleniminden elde edilen sonucun izin verilen değerlerini belirtir. Birden fazla olası değer aralarına <code>|</code> karakteri konarak belirtilir. Tırnak içinde belirtilen dizgeler öznitelik için sadece bu değerlere eşit değerlere izin verildiğini gösterir. Tırnak içine alınmamış ve eğik yazıyla belirtilmiş isimler belli bir değer türünü belirtir.</p></li><li><p>Eğer bir elemanın içeriği özellikle boş değilse, izin verilen içerik bir XML açıklaması olarak belirtilmiştir; açıklama içeriğinde XML'deki eleman türü bildirimide kullanılan yöntem kullanılmıştır; bu içerikten olarak <var>örneklenim</var>, metin düğümlerinin, birebir hedef elemanların, eklenti elemanların ve <tt>yönerge</tt> grubundaki XSLT elemanlarının bir karışımını ifade eder; <tt>tepe-seviyeden-eleman</tt> ise <a title="Tepe-seviyeden eleman tanımı" href="#dt-top-level">tepe-seviyeden</a> eleman grubuna giren XSLT elemanlarına izin verildiği anlamındadır.</p></li><li><p>Eleman isminden önceki açıklama satırı elemanın hangi eleman grubunda kullanılabildiğini belirtir; ya <tt>yönerge</tt> ya <tt>tepe-seviyeden-eleman</tt> ya da her ikisi birden olabilir. Eleman grubu, elemanın içerikte bir örneklenim olarak mı yoksa bir tepe-seviyeden bir eleman olarak mı yer alabileceğini belirtir.</p></li></ul><p></p></div></div><div class="back"><div class="div1"><h2><a name="bibref" id="bibref"></a>A Kaynakça</h2><div class="div2"><h3><a name="idp15334816" id="idp15334816"></a>A.1 Uyulması Gerekenler</h3><dl><dt class="label"><a name="XML" id="XML"></a>XML</dt><dd>World Wide Web Consortium, <a href="../xml">Genişletilebilir İmlenim Dili (XML) 1.0</a>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <a href="http://www.w3.org/TR/xml">http://www.w3.org/TR/xml</a> adresindedir.</dd><dt class="label"><a name="XMLNAMES" id="XMLNAMES"></a>XML Adları</dt><dd>World Wide Web
Consortium, <a href="../xml-names">XML 1.0'da İsim-alanları</a>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <a href="http://www.w3.org/TR/xml-names">http://www.w3.org/TR/xml-names</a> adresindedir.</dd><dt class="label"><a name="XML11" id="XML11"></a>XML 1.1</dt><dd>World Wide Web Consortium, <a href="../xml11">Genişletilebilir İmlenim Dili (XML) 1.1</a>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü  <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a> adresindedir.</dd><dt class="label"><a name="XMLNAMES11" id="XMLNAMES11"></a>XML Adları 1.1</dt><dd>World Wide Web Consortium, <a href="../xml-names11">XML 1.1'de İsim-alanları</a>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a> adresindedir.</dd><dt class="label"><a name="XPATH" id="XPATH"></a>XPath</dt><dd>World Wide Web Consortium, <a href="../xpath">XML Adresleme Dili</a>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a> adresindedir.</dd></dl></div><div class="div2"><h3><a name="idp15361792" id="idp15361792"></a>A.2 Diğerleri</h3><dl><dt class="label"><a name="CSS2" id="CSS2"></a>CSS2</dt><dd>World Wide Web Consortium.  <a href="http://www.w3.org/TR/CSS2/">Basamaklı Biçembentler, 2. seviye (CSS2)</a>.  W3C Önergesi.</dd><dt class="label"><a name="DSSSL" id="DSSSL"></a>DSSSL</dt><dd>Uluslararası Standartlaşım Örgütü, Uluslararası Elektroteknik Komisyonu. <cite>ISO/IEC 10179:1996.  Belge Biçem Anlambilimi ve Belirtim Dili (DSSSL)</cite>.  Uluslararası Standart.</dd><dt class="label"><a name="HTML" id="HTML"></a>HTML</dt><dd>World Wide Web Consortium. <a href="http://www.w3.org/TR/html40/">HTML 4.0 Belirtimi</a>. W3C Önergesi.</dd><dt class="label"><a name="IANA" id="IANA"></a>IANA</dt><dd>Internet Assigned Numbers Authority. <a href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">Karakter Kümeleri</a>.</dd><dt class="label"><a name="RFC2278" id="RFC2278"></a>RFC2278</dt><dd>N. Freed, J. Postel.  <a href="http://www.ietf.org/rfc/rfc2278.txt">IANA Karakter Kümesi Sicil kaydı İşlemleri</a>.  IETF RFC 2278.</dd><dt class="label"><a name="RFC2376" id="RFC2376"></a>RFC2376</dt><dd>E. Whitehead, M. Murata.  <a href="http://www.ietf.org/rfc/rfc2376.txt">XML Ortam Türleri</a>. IETF RFC 2376. </dd><dt class="label"><a name="RFC2396" id="RFC2396"></a>RFC2396</dt><dd>T. Berners-Lee, R. Fielding ve L. Masinter.  <a href="http://www.ietf.org/rfc/rfc2396.txt">TekBiçimli Özkaynak Betimleyiciler (URI): Soysal Sözdizimi</a>. IETF RFC 2396.</dd><dt class="label"><a name="UNICODE-TR10" id="UNICODE-TR10"></a>UNICODE TR10</dt><dd>Unicode Consortium. <a href="http://www.unicode.org/unicode/reports/tr10/index.html">Unicode Teknik Rapor #10. Unicode Collation
Algorithm</a>.  Unicode Technical Report.</dd><dt class="label"><a name="XHTML" id="XHTML"></a>XHTML</dt><dd>World Wide Web Consortium. <a href="http://www.w3.org/TR/xhtml1/">XHTML 1.0: Genişletilebilir HiperMetin İmlenim Dili.</a> W3C Önergesi.</dd><dt class="label"><a name="XPTR" id="XPTR"></a>XPointer</dt><dd>World Wide Web
Consortium. <a href="http://www.w3.org/TR/xptr/">XML Gösterici Dili (XPointer).</a> W3C Çalışma
Taslağı.</dd><dt class="label"><a name="XMLSTYLE" id="XMLSTYLE"></a>XML Stylesheet</dt><dd>World Wide Web Consortium. <a href="../xml-stylesheet/">Biçembentlerin XML Belgelerle İlişkilendirilmesi</a> W3C Önergesi, Uyulması zorunlu İngilizce sürümü <a href="http://www.w3.org/TR/xml-stylesheet">http://www.w3.org/TR/xml-stylesheet</a> adresindedir.</dd><dt class="label"><a name="XSL" id="XSL"></a>XSL</dt><dd>World Wide Web Consortium.  <a href="http://www.w3.org/TR/xsl/">Genişletilebilir Biçembent Dili (XSL).</a>  W3C Önergesi.</dd></dl></div></div><div class="div1"><h2><a name="element-syntax-summary" id="element-syntax-summary"></a>B Elemanların Özet Sözdizimleri</h2><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-apply-imports">xsl:apply-imports</a> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-apply-templates">xsl:apply-templates</a></span>
  <code>select</code> = <var>düğüm-kümesi-ifadesi</var>
  <code>mode</code> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-sort">&lt;xsl:sort&gt;</a> | <a href="#element-with-param">&lt;xsl:with-param&gt;</a>) --&gt;
<span class="element">&lt;/xsl:apply-templates&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-attribute">xsl:attribute</a></span>
  <b>name</b> = { <var>nitelikli-ad</var> }
  <code>namespace</code> = { <var>tanım-yeri-başvurusu</var> }<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:attribute&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-attribute-set">xsl:attribute-set</a></span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <a href="#element-attribute">&lt;xsl:attribute&gt;</a>* --&gt;
<span class="element">&lt;/xsl:attribute-set&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-call-template">xsl:call-template</a></span>
  <b>name</b> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <a href="#element-with-param">&lt;xsl:with-param&gt;</a>* --&gt;
<span class="element">&lt;/xsl:call-template&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-choose">xsl:choose</a>&gt;</span>
  &lt;!-- İçeriği: (<a href="#element-when">&lt;xsl:when&gt;</a>+ | <a href="#element-otherwise">&lt;xsl:otherwise&gt;</a>?) --&gt;
<span class="element">&lt;/xsl:choose&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-comment">xsl:comment</a>&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:comment&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-copy">xsl:copy</a></span>
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:copy&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-copy-of">xsl:copy-of</a></span>
  <b>select</b> = <var>ifade</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-decimal-format">xsl:decimal-format</a></span>
  <code>name</code> = <var>nitelikli-ad</var>
  <code>decimal-separator</code> = <var>karakter</var>
  <code>grouping-separator</code> = <var>karakter</var>
  <code>infinity</code> = <var>dizge</var>
  <code>minus-sign</code> = <var>karakter</var>
  <code>NaN</code> = <var>dizge</var>
  <code>percent</code> = <var>karakter</var>
  <code>per-mille</code> = <var>karakter</var>
  <code>zero-digit</code> = <var>karakter</var>
  <code>digit</code> = <var>karakter</var>
  <code>pattern-separator</code> = <var>karakter</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-element">xsl:element</a></span>
  <b>name</b> = { <var>nitelikli-ad</var> }
  <code>namespace</code> = { <var>tanım-yeri-başvurusu</var> }
  <code>use-attribute-sets</code> = <var>nitelikli-adlar</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:element&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-fallback">xsl:fallback</a>&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:fallback&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-for-each">xsl:for-each</a></span>
  <b>select</b> = <var>düğüm-kümesi-ifadesi</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-sort">&lt;xsl:sort&gt;</a>*, <var>örneklenim</var>) --&gt;
<span class="element">&lt;/xsl:for-each&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-if">xsl:if</a></span>
  <b>test</b> = <var>mantıksal-ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:if&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-import">xsl:import</a></span>
  <b>href</b> = <var>tanım-yeri-başvurusu</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-include">xsl:include</a></span>
  <b>href</b> = <var>tanım-yeri-başvurusu</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-key">xsl:key</a></span>
  <b>name</b> = <var>nitelikli-ad</var>
  <b>match</b> = <var>örüntü</var>
  <b>use</b> = <var>ifade</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-message">xsl:message</a></span>
  <code>terminate</code> = "yes" | "no"<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:message&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-namespace-alias">xsl:namespace-alias</a></span>
  <b>stylesheet-prefix</b> = <var>önek</var> | "#default"
  <b>result-prefix</b> = <var>önek</var> | "#default"<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-number">xsl:number</a></span>
  <code>level</code> = "single" | "multiple" | "any"
  <code>count</code> = <var>örüntü</var>
  <code>from</code> = <var>örüntü</var>
  <code>value</code> = <var>sayısal-ifade</var>
  <code>format</code> = { <var>dizge</var> }
  <code>lang</code> = { <var>ad-dizgeciği</var> }
  <code>letter-value</code> = { "alphabetic" | "traditional" }
  <code>grouping-separator</code> = { <var>karakter</var> }
  <code>grouping-size</code> = { <var>sayı</var> }<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-otherwise">xsl:otherwise</a>&gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:otherwise&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-output">xsl:output</a></span>
  <code>method</code> = "xml" | "html" | "text" | <var>nitelikli-ad-ama-kısa-ad-değil</var>
  <code>version</code> = <var>ad-dizgeciği</var>
  <code>encoding</code> = <var>dizge</var>
  <code>omit-xml-declaration</code> = "yes" | "no"
  <code>standalone</code> = "yes" | "no"
  <code>doctype-public</code> = <var>dizge</var>
  <code>doctype-system</code> = <var>dizge</var>
  <code>cdata-section-elements</code> = <var>nitelikli-adlar</var>
  <code>indent</code> = "yes" | "no"
  <code>media-type</code> = <var>dizge</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-param">xsl:param</a></span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:param&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-preserve-space">xsl:preserve-space</a></span>
  <b>elements</b> = <var>dizgecikler</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-processing-instruction">xsl:processing-instruction</a></span>
  <b>name</b> = { <var>kısa-ad</var> }<span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:processing-instruction&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-sort">xsl:sort</a></span>
  <code>select</code> = <var>dizgesel-ifade</var>
  <code>lang</code> = { <var>ad-dizgeciği</var> }
  <code>data-type</code> = { "text" | "number" | <var>nitelikli-ad-ama-kısa-ad-değil</var> }
  <code>order</code> = { "ascending" | "descending" }
  <code>case-order</code> = { "upper-first" | "lower-first" }<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-strip-space">xsl:strip-space</a></span>
  <b>elements</b> = <var>dizgecikler</var><span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-stylesheet">xsl:stylesheet</a></span>
  <code>id</code> = <var>id</var>
  <code>extension-element-prefixes</code> = <var>dizgecikler</var>
  <code>exclude-result-prefixes</code> = <var>dizgecikler</var>
  <b>version</b> = <var>sayı</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-import">&lt;xsl:import&gt;</a>*, <var>tepe-seviyeden-elemanlar</var>) --&gt;
<span class="element">&lt;/xsl:stylesheet&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
<span class="element">&lt;<a href="#element-template">xsl:template</a></span>
  <code>match</code> = <var>örüntü</var>
  <code>name</code> = <var>nitelikli-ad</var>
  <code>priority</code> = <var>sayı</var>
  <code>mode</code> = <var>nitelikli-ad</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-param">&lt;xsl:param&gt;</a>*, <var>örneklenim</var>) --&gt;
<span class="element">&lt;/xsl:template&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-text">xsl:text</a></span>
  <code>disable-output-escaping</code> = "yes" | "no"<span class="element"> &gt;</span>
  &lt;!-- İçeriği: #PCDATA --&gt;
<span class="element">&lt;/xsl:text&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-transform">xsl:transform</a></span>
  <code>id</code> = <var>id</var>
  <code>extension-element-prefixes</code> = <var>dizgecikler</var>
  <code>exclude-result-prefixes</code> = <var>dizgecikler</var>
  <b>version</b> = <var>sayı</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: (<a href="#element-import">&lt;xsl:import&gt;</a>*, <var>tepe-seviyeden-elemanlar</var>) --&gt;
<span class="element">&lt;/xsl:transform&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-value-of">xsl:value-of</a></span>
  <b>select</b> = <var>dizgesel-ifade</var>
  <code>disable-output-escaping</code> = "yes" | "no"<span class="element"> /&gt;</span>
</pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto">&lt;!-- Grubu: tepe-seviyeden-eleman --&gt;
&lt;!-- Grubu: yönerge --&gt;
<span class="element">&lt;<a href="#element-variable">xsl:variable</a></span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:variable&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-when">xsl:when</a></span>
  <b>test</b> = <var>mantıksal-ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:when&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table><table class="proto" width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td><pre class="proto"><span class="element">&lt;<a href="#element-with-param">xsl:with-param</a></span>
  <b>name</b> = <var>nitelikli-ad</var>
  <code>select</code> = <var>ifade</var><span class="element"> &gt;</span>
  &lt;!-- İçeriği: <var>örneklenim</var> --&gt;
<span class="element">&lt;/xsl:with-param&gt;
</span></pre></td><td align="right" valign="top" style="font-variant: small-caps;">eleman</td></tr></table></div><div class="div1"><h2><a name="dtd" id="dtd"></a>C XSLT Biçembentlerinde DTD Bölümü (Bilgilendirici)</h2><dl class="note"><dt class="prefix"><b>Not:</b></dt><dd>XML 1.0 DTD'leri XML isim-alanlarını desteklemediğinden bu DTD Bölümü bilgilendirici niteliktedir ve bu bakımdan bir XSLT biçembendinde izin verilen yapıyı gerektiği gibi açıklayamaz.<p></p></dd></dl><p>Aşağıdaki öğe, belli bir hedef DTD'sinin nesnel sonucunu oluşturacak XSLT biçembentleri için bir DTD oluşturmakta kullanılabilir. Öğeye atıfta bulunmadan önce, biçembent DTD'si izin verilen hedef eleman türlerini listeleyen bir <code>result-elements</code> değergeç öğesi tanımlamalıdır. Örnek:</p><div class="example"><pre>&lt;!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
"&gt;</pre></div><p>Böyle hedef elemanları <tt>xsl:use-attribute-sets</tt> ve <tt>xsl:extension-element-prefixes</tt> özniteliklerine sahip olarak bildirilmelidir. Aşağıdaki öğe, <code>result-element-atts</code> değergecini bu amaçla bildirmektedir. XSLT'nin hedef elemanlar için izin verdiği içerik,  <code>%template;</code> içerik modeliyle aşağıda öğede bildirilen XSLT elemanları için izin verilenlerle aynıdır.  DTD, hedef DTD'nin kısıtlamalarına uygun olarak <code>%template;</code>'den daha kısıtlayıcı içerik modelleri kullanabilir.</p><p>XSLT isim-alanından farklı isim-alanlarındaki tepe-seviyeden elemanlara da izin vermek için DTD <code>non-xsl-top-level</code> diye bir değergeç öğesi tanımlayabilir.</p><p>Bu DTD'deki <tt>xsl:</tt> öneki kullanımı XSLT biçembentlerinin bu öneki kullanmaları zorunludur anlamında ele alınmamalıdır. Bu DTD'de bildirilmiş herhangi bir eleman, bu DTD'de bildirilmiş özniteliklere ek olarak isimleri <code>xmlns</code>'e eşit veya <code>xmlns:</code> ile başlayan özniteliklere sahip olabilir.</p><div class="example"><pre>&lt;!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
"&gt;

&lt;!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
"&gt;

&lt;!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
"&gt;

&lt;!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
"&gt;

&lt;!-- Değeri bir tanım-yeri başvurusu olan
     bir öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % URI "CDATA"&gt;

&lt;!-- Değeri bir örüntü olan bir öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % pattern "CDATA"&gt;

&lt;!-- Değeri bir öznitelik değeri örneklenimi
     olan bir öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % avt "CDATA"&gt;

&lt;!-- Değeri bir NitelAd olan bir öznitelik türü için kullanılır;
     önek, XSLT işlemcinin yorumladığı bir önek olacaktır. --&gt;
&lt;!ENTITY % qname "NMTOKEN"&gt;

&lt;!-- %qname; gibi ama bu onların boşluk ayraçlı bir listesi. --&gt;
&lt;!ENTITY % qnames "NMTOKENS"&gt;

&lt;!-- Değeri bir ifade olan bir öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % expr "CDATA"&gt;

&lt;!-- Değeri tek bir karakterden oluşan
     bir öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % char "CDATA"&gt;

&lt;!-- Değeri bir öncelik belirten bir
     öznitelik türü için kullanılır. --&gt;
&lt;!ENTITY % priority "NMTOKEN"&gt;

&lt;!ENTITY % space-att "xml:space (default|preserve) #IMPLIED"&gt;

&lt;!-- Bu tepe-seviyede izin verilmiş eleman listesini
     genişleten bir özelleştirme olabilir. --&gt;
&lt;!ENTITY % non-xsl-top-level ""&gt;

&lt;!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
"&gt;

&lt;!ENTITY % top-level-atts '
  extension-element-prefixes CDATA   #IMPLIED
  exclude-result-prefixes    CDATA   #IMPLIED
  id                         ID      #IMPLIED
  version                    NMTOKEN #REQUIRED
  xmlns:xsl                  CDATA   #FIXED    "http://www.w3.org/1999/XSL/Transform"
  %space-att;
'&gt;

&lt;!-- Bu öğe hedef elemanların ATTLIST bildirimlerinde
     kullanmak için tanımlanmıştır. --&gt;

&lt;!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA    #IMPLIED
  xsl:exclude-result-prefixes    CDATA    #IMPLIED
  xsl:use-attribute-sets         %qnames; #IMPLIED
  xsl:version                    NMTOKEN  #IMPLIED
'&gt;

&lt;!ELEMENT xsl:stylesheet %top-level;&gt;
&lt;!ATTLIST xsl:stylesheet %top-level-atts;&gt;

&lt;!ELEMENT xsl:transform %top-level;&gt;
&lt;!ATTLIST xsl:transform %top-level-atts;&gt;

&lt;!ELEMENT xsl:import EMPTY&gt;
&lt;!ATTLIST xsl:import href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:include EMPTY&gt;
&lt;!ATTLIST xsl:include href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:strip-space EMPTY&gt;
&lt;!ATTLIST xsl:strip-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:preserve-space EMPTY&gt;
&lt;!ATTLIST xsl:preserve-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:output EMPTY&gt;
&lt;!ATTLIST xsl:output
  method                 %qname;  #IMPLIED
  version                NMTOKEN  #IMPLIED
  encoding               CDATA    #IMPLIED
  omit-xml-declaration  (yes|no)  #IMPLIED
  standalone            (yes|no)  #IMPLIED
  doctype-public         CDATA    #IMPLIED
  doctype-system         CDATA    #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent                (yes|no)  #IMPLIED
  media-type             CDATA    #IMPLIED
&gt;

&lt;!ELEMENT xsl:key EMPTY&gt;
&lt;!ATTLIST xsl:key
  name    %qname;   #REQUIRED
  match   %pattern; #REQUIRED
  use     %expr;    #REQUIRED
&gt;

&lt;!ELEMENT xsl:decimal-format EMPTY&gt;
&lt;!ATTLIST xsl:decimal-format
  name               %qname; #IMPLIED
  decimal-separator  %char;  "."
  grouping-separator %char;  ","
  infinity           CDATA   "Infinity"
  minus-sign         %char;  "-"
  NaN                CDATA   "NaN"
  percent            %char;  "%"
  per-mille          %char;  "&amp;#x2030;"
  zero-digit         %char;  "0"
  digit              %char;  "#"
  pattern-separator  %char;  ";"
&gt;

&lt;!ELEMENT xsl:namespace-alias EMPTY&gt;
&lt;!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix     CDATA #REQUIRED
&gt;

&lt;!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
&gt;

&lt;!ATTLIST xsl:template
  match    %pattern;  #IMPLIED
  name     %qname;    #IMPLIED
  priority %priority; #IMPLIED
  mode     %qname;    #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:value-of EMPTY&gt;
&lt;!ATTLIST xsl:value-of
  select                  %expr;   #REQUIRED
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:copy-of EMPTY&gt;
&lt;!ATTLIST xsl:copy-of select %expr; #REQUIRED&gt;

&lt;!ELEMENT xsl:number EMPTY&gt;
&lt;!ATTLIST xsl:number
   level  (single|multiple|any) "single"
   count  %pattern; #IMPLIED
   from   %pattern; #IMPLIED
   value  %expr;    #IMPLIED
   format %avt;     '1'
   lang   %avt;     #IMPLIED
   letter-value       %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size      %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*&gt;
&lt;!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-imports EMPTY&gt;

&lt;!-- xsl:sort, bir boşluk olmayan karakterden
     veya bir imlenimden sonra yer alamaz. --&gt;

&lt;!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
&gt;

&lt;!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:sort EMPTY&gt;
&lt;!ATTLIST xsl:sort
  select     %expr; "."
  lang       %avt;  #IMPLIED
  data-type  %avt;  "text"
  order      %avt;  "ascending"
  case-order %avt;  #IMPLIED
&gt;

&lt;!ELEMENT xsl:if %template;&gt;
&lt;!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)&gt;
&lt;!ATTLIST xsl:choose %space-att;&gt;

&lt;!ELEMENT xsl:when %template;&gt;
&lt;!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:otherwise %template;&gt;
&lt;!ATTLIST xsl:otherwise %space-att;&gt;

&lt;!ELEMENT xsl:attribute-set (xsl:attribute)*&gt;
&lt;!ATTLIST xsl:attribute-set
  name               %qname;  #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:call-template (xsl:with-param)*&gt;
&lt;!ATTLIST xsl:call-template
  name %qname; #REQUIRED
&gt;

&lt;!ELEMENT xsl:with-param %template;&gt;
&lt;!ATTLIST xsl:with-param
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
&gt;

&lt;!ELEMENT xsl:variable %template;&gt;
&lt;!ATTLIST xsl:variable
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
&gt;

&lt;!ELEMENT xsl:param %template;&gt;
&lt;!ATTLIST xsl:param
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
&gt;

&lt;!ELEMENT xsl:text (#PCDATA)&gt;
&lt;!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:processing-instruction %char-template;&gt;
&lt;!ATTLIST xsl:processing-instruction
  name %avt; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:element %template;&gt;
&lt;!ATTLIST xsl:element
  name               %avt;    #REQUIRED
  namespace          %avt;    #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:attribute %char-template;&gt;
&lt;!ATTLIST xsl:attribute
  name      %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:comment %char-template;&gt;
&lt;!ATTLIST xsl:comment %space-att;&gt;

&lt;!ELEMENT xsl:copy %template;&gt;
&lt;!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:message %template;&gt;
&lt;!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:fallback %template;&gt;
&lt;!ATTLIST xsl:fallback %space-att;&gt;</pre></div><p></p></div><div class="div1"><h2><a name="examples" id="examples"></a>D Örnekler (Bilgilendirici)</h2><div class="div2"><h3><a name="idp15423568" id="idp15423568"></a>D.1 Belge Örneği</h3><p>Bu örnekte, basit bir DTD ile uyumlu belgeleri XHTML'ye [<a href="#XHTML">XHTML</a>] dönüştürmek için bir biçembent kullanımı gösterilmiştir. DTD şöyledir:</p><div class="example"><pre>&lt;!ELEMENT doc     (title, chapter*)&gt;
&lt;!ELEMENT chapter (title, (para|note)*, section*)&gt;
&lt;!ELEMENT section (title, (para|note)*)&gt;
&lt;!ELEMENT title   (#PCDATA|emph)*&gt;
&lt;!ELEMENT para    (#PCDATA|emph)*&gt;
&lt;!ELEMENT note    (#PCDATA|emph)*&gt;
&lt;!ELEMENT emph    (#PCDATA|emph)*&gt;</pre></div><p>Biçembent böyle:</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;

&lt;xsl:strip-space elements="doc chapter section"/&gt;
&lt;xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-9"
/&gt;

&lt;xsl:template match="doc"&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;title&gt;
       &lt;xsl:value-of select="title"/&gt;
     &lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;xsl:apply-templates/&gt;
   &lt;/body&gt;
 &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="doc/title"&gt;
  &lt;h1&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter/title"&gt;
  &lt;h2&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="section/title"&gt;
  &lt;h3&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h3&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="note"&gt;
  &lt;p class="note"&gt;
    &lt;b&gt;BİLGİ: &lt;/b&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>Kaynak belgemiz böyle olsaydı:</p><div class="example"><pre>&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;title&gt;Belge Başlığı&lt;/title&gt;
&lt;chapter&gt;
&lt;title&gt;Fasıl Başlığı&lt;/title&gt;
&lt;section&gt;
&lt;title&gt;Bölüm Başlığı&lt;/title&gt;
&lt;para&gt;Bu bir denemedir.&lt;/para&gt;
&lt;note&gt;Bu bir ek bilgidir.&lt;/note&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;title&gt;Başka Bir Bölüm Başlığı&lt;/title&gt;
&lt;para&gt;Bu da &lt;emph&gt;başka&lt;/emph&gt; bir DNMdir.&lt;/para&gt;
&lt;note&gt;Bu bir ek malumattır.&lt;/note&gt;
&lt;/section&gt;
&lt;/chapter&gt;
&lt;/doc&gt;</pre></div><p>Üretilecek hedef belgemiz böyle olurdu:</p><div class="example"><pre>&lt;?xml version="1.0" encoding="iso-8859-9"?&gt;
&lt;html xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;head&gt;
&lt;title&gt;Belge Başlığı&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Belge Başlığı&lt;/h1&gt;
&lt;h2&gt;Fasıl Başlığı&lt;/h2&gt;
&lt;h3&gt;Bölüm Başlığı&lt;/h3&gt;
&lt;p&gt;Bu bir denemedir.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;BİLGİ: &lt;/b&gt;Bu bir ek bilgidir.&lt;/p&gt;
&lt;h3&gt;Başka Bir Bölüm Başlığı&lt;/h3&gt;
&lt;p&gt;Bu da &lt;em&gt;başka&lt;/em&gt; bir DNMdir.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;BİLGİ: &lt;/b&gt;Bu ilaveten diğer bir malumattır.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p></p></div><div class="div2"><h3><a name="data-example" id="data-example"></a>D.2 Veri Örneği</h3><p>Bu örnekte, bir XML belge olarak tutulan veriden üç farklı biçembent kullanarak verinin üç farklı gösterimi (HTML, SVG ve VRML) elde edilmektedir.</p><p>Veri girdimiz:</p><div class="example"><pre>&lt;satışlar&gt;

        &lt;bölge id="Kuzey"&gt;
                &lt;gelir&gt;10&lt;/gelir&gt;
                &lt;artış&gt;9&lt;/artış&gt;
                &lt;ikram&gt;7&lt;/ikram&gt;
        &lt;/bölge&gt;

        &lt;bölge id="Güney"&gt;
                &lt;gelir&gt;4&lt;/gelir&gt;
                &lt;artış&gt;3&lt;/artış&gt;
                &lt;ikram&gt;4&lt;/ikram&gt;
        &lt;/bölge&gt;

        &lt;bölge id="Batı"&gt;
                &lt;gelir&gt;6&lt;/gelir&gt;
                &lt;artış&gt;-1.5&lt;/artış&gt;
                &lt;ikram&gt;2&lt;/ikram&gt;
        &lt;/bölge&gt;

&lt;/sales&gt;</pre></div><p>Aşağıdaki biçembent, <a href="#result-element-stylesheet"><b>Birebir Hedef Eleman olarak Biçembent</b></a> bölümünde açıklanan basitleştirilmiş sözdizimini kullanarak veriyi HTML'ye dönüştürmek içindir:</p><div class="example"><pre>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      lang="tr"&gt;
    &lt;head&gt;
	&lt;title&gt;Bölgelere göre Satış Sonuçları&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
	&lt;table border="1"&gt;
	    &lt;tr&gt;
		&lt;th&gt;Bölge&lt;/th&gt;
		&lt;th&gt;Gelir&lt;/th&gt;
		&lt;th&gt;Büyüme&lt;/th&gt;
		&lt;th&gt;İkramiye&lt;/th&gt;
	    &lt;/tr&gt;
	    &lt;xsl:for-each select="satışlar/bölge"&gt;
		&lt;!-- sonuçları gelire göre sırala --&gt;
		&lt;xsl:sort select="gelir"
			  data-type="number"
			  order="descending"/&gt;
		&lt;tr&gt;
		    &lt;td&gt;
			&lt;em&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/em&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;xsl:value-of select="gelir"/&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;!-- büyüme aslında küçülmeyse kırmızı göster --&gt;
			&lt;xsl:if test="artış &amp;lt; 0"&gt;
			     &lt;xsl:attribute name="style"&gt;
				 &lt;xsl:text&gt;color:red&lt;/xsl:text&gt;
			     &lt;/xsl:attribute&gt;
			&lt;/xsl:if&gt;
			&lt;xsl:value-of select="artış"/&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;xsl:value-of select="ikram"/&gt;
		    &lt;/td&gt;
		&lt;/tr&gt;
	    &lt;/xsl:for-each&gt;
	&lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The HTML output is:</p><div class="example"><pre>&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-9"&gt;
&lt;title&gt;Bölgelere göre Satış Sonuçları&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;th&gt;Bölge&lt;/th&gt;&lt;th&gt;Gelir&lt;/th&gt;&lt;th&gt;Büyüme&lt;/th&gt;&lt;th&gt;İkramiye&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;Kuzey&lt;/em&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;Batı&lt;/em&gt;&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td style="color:red"&gt;-1.5&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;Güney&lt;/em&gt;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Bu biçembent veriyi SCG'ye dönüştürmek içinder:</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd"&gt;

&lt;xsl:output method="xml" indent="yes" media-type="image/svg"/&gt;

&lt;xsl:template match="/"&gt;

&lt;svg width = "3in" height="3in"&gt;
    &lt;g style = "stroke: #000000"&gt;
        &lt;!-- eksenlere çiz --&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Gelir&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Bölüm&lt;/text&gt;
        &lt;xsl:for-each select="satışlar/bölüm"&gt;
	    &lt;!-- bazı yararlı değişkenleri tanımlayalım --&gt;

	    &lt;!-- çubuğun x konumu --&gt;
	    &lt;xsl:variable name="pos"
	                  select="(position()*40)-30"/&gt;

	    &lt;!-- çubuğun yüksekliği --&gt;
	    &lt;xsl:variable name="height"
	                  select="gelir*10"/&gt;

	    &lt;!-- dikdörtgen --&gt;
	    &lt;rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/&gt;

	    &lt;!-- metinsel yafta --&gt;
	    &lt;text x="{$pos}" y="165"&gt;
	        &lt;xsl:value-of select="@id"/&gt;
	    &lt;/text&gt;

	    &lt;!-- çubuk değeri --&gt;
	    &lt;text x="{$pos}" y="{145-$height}"&gt;
	        &lt;xsl:value-of select="gelir"/&gt;
	    &lt;/text&gt;
        &lt;/xsl:for-each&gt;
    &lt;/g&gt;
&lt;/svg&gt;

&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p>SVG çıktısı:</p><div class="example"><pre>&lt;svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd"&gt;
    &lt;g style="stroke: #000000"&gt;
	&lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
	&lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
	&lt;text x="0" y="10"&gt;Gelir&lt;/text&gt;
	&lt;text x="150" y="165"&gt;Bölüm&lt;/text&gt;
	&lt;rect x="10" y="50" width="20" height="100"/&gt;
	&lt;text x="10" y="165"&gt;Kuzey&lt;/text&gt;
	&lt;text x="10" y="45"&gt;10&lt;/text&gt;
	&lt;rect x="50" y="110" width="20" height="40"/&gt;
	&lt;text x="50" y="165"&gt;Güney&lt;/text&gt;
	&lt;text x="50" y="105"&gt;4&lt;/text&gt;
	&lt;rect x="90" y="90" width="20" height="60"/&gt;
	&lt;text x="90" y="165"&gt;Batı&lt;/text&gt;
	&lt;text x="90" y="85"&gt;6&lt;/text&gt;
    &lt;/g&gt;
&lt;/svg&gt;</pre></div><p>Aşağıdaki biçembent veriyi VRML'ye dönüştürmek içindir:</p><div class="example"><pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- metni, öntanımlı karakter kümesini kullanarak
     model/vrmlmime türünde üretelim --&gt;
&lt;xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/&gt;

        &lt;xsl:template match="/"&gt;#VRML V2.0 utf8

# tek bir bar elemanının externproto tanımı
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# taşıyıcı çizge eksenlerini satıriçine alalım
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }

                &lt;xsl:for-each select="satışlar/bölüm"&gt;
bar {
        x &lt;xsl:value-of select="gelir"/&gt;
        y &lt;xsl:value-of select="artış"/&gt;
        z &lt;xsl:value-of select="ikram"/&gt;
        name "&lt;xsl:value-of select="@id"/&gt;"
        }
                &lt;/xsl:for-each&gt;

        &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>VRML çıktısı:</p><div class="example"><pre>#VRML V2.0 utf8

# tek bir bar elemanının externproto tanımı
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# taşıyıcı çizge eksenlerini satıriçine alalım
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }


bar {
        x 10
        y 9
        z 7
        name "Kuzey"
        }

bar {
        x 4
        y 3
        z 4
        name "Güney"
        }

bar {
        x 6
        y -1.5
        z 2
        name "Batı"
        }</pre></div><p></p></div></div><div class="div1"><h2><a name="ack" id="ack"></a>E Teşekkür (Bilgilendirici)</h2><p>Bu taslağın yazımına katkıda bulunanlar:</p><ul><li>Daniel Lipkin, Saba</li><li>Jonathan Marsh, Microsoft</li><li>Henry Thompson, University of Edinburgh</li><li>Norman Walsh, Arbortext</li><li>Steve Zilles, Adobe</li></ul><p>Bu belirtim W3C XSL Çalışma Grubu (ÇG) tarafından geliştirildi ve yayımı için onaylandı. Bu belirtimin ÇG onayı tüm ÇG üyülerinin onaylarını oylarıyla belirtmelerini gerektirmez. XSL ÇG'nin şu an ki üyeleri:</p><ul><li>Sharon Adler, IBM (<i>Co-Chair</i>) </li><li>Anders Berglund, IBM</li><li>Perin Blanchard, Novell</li><li>Scott Boag, Lotus</li><li>Larry Cable, Sun</li><li>Jeff Caruso, Bitstream</li><li>James Clark</li><li>Peter Danielsen, Bell Labs</li><li>Don Day, IBM</li><li>Stephen Deach, Adobe</li><li>Dwayne Dicks, SoftQuad</li><li>Andrew Greene, Bitstream</li><li>Paul Grosso, Arbortext</li><li>Eduardo Gutentag, Sun</li><li>Juliane Harbarth, Software AG</li><li>Mickey Kimchi, Enigma</li><li>Chris Lilley, W3C</li><li>Chris Maden, Exemplary Technologies</li><li>Jonathan Marsh, Microsoft</li><li>Alex Milowski, Lexica</li><li>Boris Moore, RivCom</li><li>Steve Muench, Oracle</li><li>Scott Parnell, Xerox</li><li>Vincent Quint, W3C</li><li>Dan Rapp, Novell</li><li>Gregg Reynolds, Datalogics</li><li>Jonathan Robie, Software AG</li><li>Mark Scardina, Oracle</li><li>Henry Thompson, University of Edinburgh</li><li>Philip Wadler, Bell Labs</li><li>Norman Walsh, Arbortext</li><li>Sanjiva Weerawarana, IBM</li><li>Steve Zilles, Adobe (<i>Co-Chair</i>) </li></ul></div><div class="div1"><h2><a name="changes" id="changes"></a>F Önerge Adaylığından beri Değişenler (Bilgilendirici)</h2><p>Önerge Adaylığından sonra şu değişiklikler oldu:</p><ul><li><p><tt>xsl:version</tt> özniteliği, bir biçembent olarak kullanımda bir birebir hedef elemanda gereklidir (bkz, <a href="#result-element-stylesheet"><b>Birebir Hedef Eleman olarak Biçembent</b></a>).</p></li><li><p><a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a> elemanındaki <code>data-type</code> özniteliği, XSLT tarafından tanımlanmamış bir veri türünü belirten bir önekli ismi kullanılabilir (bkz, <a href="#sorting"><b>Sıralama</b></a>).</p></li></ul><p></p></div><div class="div1"><h2><a name="future" id="future"></a>G XSLT'nin gelecek sümlerinde ele alınacak özellikler (Bilgilendirici)</h2><p>XSLT'nin XSLT 1.0'dan sonraki sürümlerinde ele alınması düşünülen özellikler şunlardır:</p><ul><li>bir koşullu ifade;</li><li>XML Şema veri ve örnek türleri için destek;</li><li>özgün XSL sunumunda yer alan biçem kurallarının benzerleri için destek;</li><li>XSLT özniteliklerinde yer alan isimler için öntanımlı isim-alanını denetleyecek bir öznitelik;</li><li>öğe gönderimlerine destek;</li><li>veri modelindeki DTD'ler için destek;</li><li>veri modelindeki gösterimler için destek;</li><li>bir elemandan ona atıfta bulunan elemanlara ulaşmak için bir yol (IDREF özniteliklerinin yaptığı gibi);</li><li>başka bir belgedeki bir id veya anahtarı almanın kolay bir yolu;</li><li>eleman türü isimleri, öznitelik isimleri, öznitelik değerleri ve metin düğümlerinin tümünü veya bir kısmını aralarında eşlemek için düzenli ifade desteği;</li><li>harf büyüklüğüne duyarsız karşılaştırmalar;</li><li>karşılaştırma öncesi dizge normalleştirmesi, örneğin uyumluluk karakterleri için;</li><li>düğümün temel tanım-yerini kullanarak, bir mutlak tanım-yerine dönüştürmek üzere bir göreli tanım yerini değer olarak alan, <var>dizge </var><code>resolve(</code><var>düğüm-kümesi</var><code>)</code> gibi bir işlev;</li><li>çok sayıda hedef belge;</li><li><a href="#element-value-of"><span class="elemref"><tt>xsl:value-of</tt></span></a> elemanının <code>select</code> özniteliği için geçerli düğümün öntanımlı olması;</li><li>bir öznitelik değerinin nasıl normalleştirileceğinin belirtilebileceği bir özniteliğin <a href="#element-attribute"><span class="elemref"><tt>xsl:attribute</tt></span></a> elemanına atanması;</li><li>sıralama üzerinde daha fazla denetim (göreli sıralama yapmak gibi) sağlamak için <a href="#element-sort"><span class="elemref"><tt>xsl:sort</tt></span></a>'a yeni özniteliklerin eklenmesi;</li><li>bir hedef ağaca bir tanım-yeri tarafından tanımlanmış bir özkaynağın metnini koymanın bir yolu;</li><li>konumları birarada belirtebilmek (<code>foo/(bar|baz)</code> gibi);</li><li>düğüm kümeleri için mümkün olan tüm işlemlerin hedef ağaç bölümlerinde de mümkün olması;</li><li>altelemanların ve özniteliklerin çoğullanmasına yol açan ardışık düğümleri gruplamanın bir yolu;</li><li>HTML <code>style</code> özniteliğinin elde edilişine daha uygun bir yol.</li></ul></div></div></body></html>