<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>1.3.2.3. Koşullu Olarak Güvenilir Özellikler</title>
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="/style/belgeler.css" />
    <link rel="stylesheet" type="text/css" href="/style/nav.css" />
    <link rel="icon" type="image/png" href="/images/belgeler-logo.png" />
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Unsafe-Features.html')">Önceki</button>
          <div class="dropdown-content">1.3.2.2. Güvenilmez Özellikler</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc.html')">Ana Başlık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc-POSIX.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Other-Safety-Remarks.html')">Sonraki</button>
          <div class="dropdown-content">1.3.2.4. Güvenilirlikle ilgili Diğer Açıklamalar</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="sect2" id="glibc-Conditionally-Safe-Features">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">1.3.2.3. Koşullu Olarak Güvenilir Özellikler</h3>
            </div>
          </div>
        </div>
        <span id="glibc-cp-consafe" class="indexterm"></span>
        <p>
     Belirli bağlamlarda işlevlerin çağrılmasını güvensiz kılan bazı özellikler için, işlevi çağırmaktan tamamen kaçınmak dışında güvenlik sorununu ortadan kaldıracak bazı yollar vardır. Aşağıdaki anahtar sözcükler bu tür özelliklere atıfta bulunur ve bunların tanımlarının her biri, anahtar sözcük tarafından belirtilen güvenilirlik sorununu ortadan kaldırmak için tüm yazılımın nasıl sınırlandırılması gerektiğini gösterir. Yalnız ve yalnız, bir işlevi güvensiz kılan tüm nedenler gözlemlenip belgelenmiş kısıtlamalar uygulanarak ele alındığında işlevin o bağlamda çağrılması güvenilir hale gelir.
    </p>
        <div class="glosslist">
          <dl>
            <dt>
              <span class="glossterm">
                <code class="code">init</code>
              </span>
              <span id="glibc-safety-init" class="indexterm"></span>
            </dt>
            <dd class="glossdef">
              <p>
        <code class="code">MT-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevler, ilk çağrıldıklarında <code class="code">MT-Unsafe</code> ilklendirme yapar.
       </p>
              <p>
        Böyle bir işlevi tek evreli kipte en az bir kez çağırmak, işlevin <code class="code">MT-Unsafe</code> olarak değerlendirilmesine sebep olan bu özel nedeni ortadan kaldırır. Bunun için başka bir neden kalmadıysa, diğer evreler başlatıldıktan sonra işlev güvenli bir şekilde çağrılabilir.
       </p>
              <p>
        <code class="code">AS-Unsafe</code> veya <code class="code">AC-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevler, dahili veri yapılarını ilklendirmek için dahili <code class="code">libc_once</code> mekanizmasını veya benzerini kullanır.
       </p>
              <p>
        Bir sinyal işleyici böyle bir ilklendiriciyi kesintiye uğratır ve üstüne <code class="code">libc_once</code> ilklendirmesini uygulayacak bir işlevi çağırırsa, evre kütüphanesi yüklü olduğu takdirde kısır döngü oluşur.
       </p>
              <p>
        Dahası, bir ilklendirici iptal edilmeden veya işleyicisi aynı ilklendirmeyi gerektiren bir sinyal tarafından kesintiye uğratılmadan önce kısmen tamamlanmışsa, ilklendirmenin bir kısmı veya tamamı birden fazla kez uygulanabilir, bu da kaynakların boşa harcanmasına ve hatta dahili verilerin bozulmasına neden olabilir.
       </p>
              <p>
        <code class="code">AS-Unsafe</code> veya <code class="code">AC-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevleri çağırması gereken yazılımlarda, <code class="code">libc_once</code> ile ilgili <code class="code">AS-Unsafe</code> ve <code class="code">AC-Unsafe</code> sorunlarının ortaya çıkmaması için sinyal işleyicileri yapılandırılmadan veya iptali etkinleştirilmeden önce ilklendirme yapılmış olmalıdır.
       </p>
            </dd>
            <dt>
              <span class="glossterm">
                <code class="code">race</code>
              </span>
              <span id="glibc-safety-race" class="indexterm"></span>
            </dt>
            <dd class="glossdef">
              <p>
        <code class="code">MT-Safety</code> özellik olarak <code class="code">race</code> ile imlenmiş işlevler, aynı anda yürütme dışında benzer yıkıcı girişim biçimlerine veya veri yarışlarına neden olabilecek şekilde nesneler üzerinde işlem yapar. Nesneler, bazı durumlarda kullanıcılar tarafından işlevlere aktarılırken bazı durumlarda da işlevler tarafından kullanıcılara değer döndürmek için kullanılır, bazı durumlarda ise kullanıcılara hiç görünmez.
       </p>
              <p>
        İşlevlere (dolaylı) olarak aktarılan nesnelere erişimin veri yarışından bağımsız olduğu varsayılır. Veri yarışından bağımsız nesnelerin güvenilirliği işlevi çağıranın sorumluluğundadır. Yazılımcı bu tür nesnelerle uğraşırken veri yarışlarını önlemek için POSIX'in gerektirdiği önlemleri almadığı için işlev hatalı davranırsa, bu işlev <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlenmez.
       </p>
              <p>
        Genel bir kural olarak, bir işlevin (atıf yoluyla) aktarılan bir nesneden okuma yaptığı veya bu nesneyi değiştirdiği durumlarda, yazılımcının kütüphane işlevini çağırmak yerine nesneye erişimi kendisinin gerçekleştirmesi, veri yarışlarından kaçınmak için de bellek eşzamanlama ilkellerini kullanması gerekir. POSIX, <code class="type">FILE</code> akımlarını işleyen birçok işlevde veri yarışlarına karşı kütüphanenin koruma sağlamasını zorunlu kıldığından <code class="type">FILE</code> akımları bu genel kuralın dışındadır. Bunu, diğer türleri de kapsayacak şekilde genişletilmesi gerektiği yönündeki beklentilerin aksine, genel bir gereklilik olarak değil, kullanıcılara sağlanan bir kolaylık olarak görüyoruz.
       </p>
              <p>
        Yazılımcılara belirli bağımsız değişkenleri korumanın kendi sorumlulukları olduğunu hatırlatmak için, belirli türdeki nesneleri bağımsız değişken olarak alan işlevlere açıklama ekleyeceğiz. Yazılımcı tarafından aktarılan nesneler ile ilgili olarak çizgiyi şu şekilde çekiyoruz: Bellek tamponları, dizgeler ve kullanıcı tarafından görülebilen <code class="type">struct</code> türleri gibi, türleri kullanıcılara açık olan ve kullanıcıların doğrudan erişmesi beklenen nesneler, işlevlerin <code class="code">race</code> ile imlenmesine neden <em class="emphasis">olmaz</em>. Bu, genel gereksinime göre gürültülü ve gereksiz olacak ve yazılımcının doğrudan erişilebildiği nesnelere erişirken kütüphanenin buna dahili olarak koruma sağlamaması kimseyi pek şaşırtmayacaktır.
       </p>
              <p>
        Yalnızca kütüphane işlevlerine aktarılarak üzerinde işlem yapılabilecek olan (örneğin, <code class="type">FILE</code>, <code class="type">DIR</code>, <code class="type">obstack</code>, <code class="type">iconv_t</code> gibi) geçirimsiz nesneler ve benzeri için, kütüphane tarafından erişimin dahili yönetimine ilişkin ek beklentiler olabilir. Bu tür nesneleri alan ancak öntanımlı olarak bunlara erişimi zamanlamaya özen göstermeyen işlevlerin bağımsız değişkenlerini, <code class="code">race</code>:<em class="replaceable"><code>değişken</code></em> sözdizimiyle imleyeceğiz. Örneğin, <code class="type">FILE</code> akımının "kilitleme yapmayan" işlevleri imlenir, ancak örtük kilitleme akım bazında devre dışı bırakılmış olsa bile, <code class="code">FILE</code> akımlarında öntanımlı olarak örtük kilitleme gerçekleştirenlere bu uygulanmaz.
       </p>
              <p>
        Her iki durumda da, yazılımcının, erişimlerin iyi tanımlandığından emin olmaması durumunda, yazılımcı tarafından sağlanan nesnelere güvenli olmayan yollarla erişebilen <code class="code">MT-Unsafe</code> işlevleri dikkate almayacağız. Yazılımcılarda, yazılımcı tarafından sağlanan ve kütüphanenin yazılımcı adına eriştiği nesneleri veri yarışlarına karşı korumasının beklendiği fikri hakimdir.
       </p>
              <p>
        Ancak, bu kullanıcı sorumluluğu, belirli çağrılardan değer döndürmek için kullanılan dahili nesneler ve statik tamponlar gibi kütüphane tarafından denetlenen nesneler için geçerli değildir. Kütüphane bunları artalandaki kullanımlara karşı korumadığında, bu durumlar <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak kabul edilir (ancak <code class="code">AS-Unsafe</code> özellik olarak <code class="code">race</code> imi, <code class="code">MT-Unsafe</code> olanı varken gereksiz olduğundan yok sayılır). Yazılımcıya terkedilen nesnelerde olduğu gibi, imden sonra iki nokta üst üste ve <em class="replaceable"><code>tanıtıcı</code></em> gelebilir. <em class="replaceable"><code>tanıtıcı</code></em>, belirli bir korumasız nesne üzerinde çalışan tüm işlevleri gruplandırır. Yazılımcı, denetimindeki nesnenin <em class="replaceable"><code>tanıtıcı</code></em>sıyla ilgili ardışık olmayan bir muteks oluşturarak ve bu <em class="replaceable"><code>tanıtıcı</code></em>da <code class="code">race</code> olarak imlenmiş herhangi bir işlevi çağırırken muteksi daima tutarak, bu tür dahili nesnelere önalanda korumasız erişimle ilgili <code class="code">MT-Safe</code> sorunlarından kaçınabilir. Ardışık olmayan muteks, Çok Evreli güvenilirliği ile ilgili sorunu önler, ancak Önalanda Sinyal güvenilirliği sorununu diğeriyle değiştirir, bu nedenle önalanda sinyal kullanımı tanımsız kalır.
       </p>
              <p>
        <em class="replaceable"><code>tanıtıcı</code></em>, dönüş değerlerini tutmak için kullanılan statik bir tampona ait olduğunda, tampon çağrıcı tarafından kullanıldığı sürece muteks tutulmalıdır. Statik tamponlara gösterici döndüren birçok işlev, bunun yerine geri dönüş değerlerini çağrıcı tarafından sağlanan tamponlarda saklayan evresel karşılıklarını sunar. <code class="code">tmpname</code> gibi bazı durumlarda bu evresel karşılık, ayrı bir giriş noktası çağrılarak değil, döndürülen değerlerin saklanacağı tampona NULL olmayan bir gösterici aktarılarak seçilir. Bu evresel karşılıklar, <code class="code">race</code> olarak imlenmiş diğer dahili tamponlar nedeniyle <code class="code">MT-Safe</code> değilse de, genellikle çok evreli yazılımlarda tercih edilir.
       </p>
            </dd>
            <dt>
              <span class="glossterm">
                <code class="code">const</code>
              </span>
              <span id="glibc-safety-const" class="indexterm"></span>
            </dt>
            <dd class="glossdef">
              <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">const</code> ile imlenmiş işlevler, GNU C Kütüphanesinin önemli bir bölümü bunlara zamanlamasız eriştiğinden, sabit olarak kabul edilmesi daha iyi olan dahili nesneleri bütünlüklerini bozarak değiştirir. Dahili nesnelerin hem oku hem de yaz işlevlerinin <code class="code">MT-Unsafe</code> ve <code class="code">AS-Unsafe</code> olarak değerlendirilmesine neden olan <code class="code">race</code> iminden farklı olarak, <code class="code">const</code> yalnızca yaz işlevlerine uygulanır. Yaz işlevleri çağrılmak için eşit derecede <code class="code">MT-Unsafe</code> ve <code class="code">AS-Unsafe</code> olarak kalırlar, ancak nesneler etkin birer sabit olduğunda zamanlama eksikliği sorun yaratmadığından, nesnelerin değiştirildikten sonraki zorunlu sabitliği, oku işlevlerinin <code class="code">MT-Safe</code> ve <code class="code">AS-Safe</code> olarak kabul edilmesini sağlar (güvenli olmamaları için başka bir neden kalmadığı sürece).
       </p>
              <p>
        Oku işlevlerinde <code class="code">const:</code><em class="replaceable"><code>tanıtıcı</code></em>,  kendiliğinden bir güvenilirlik imi olarak görünecektir. Yaz işlevlerini çağırmak için bu güvenlik sorununa geçici bir çözüm bulmak isteyen yazılımlar, <em class="replaceable"><code>tanıtıcı</code></em> ile ilişkili ardışık olmayan bir <code class="code">rwlock</code> kullanabilir ve <code class="code">const:</code><em class="replaceable"><code>tanıtıcı</code></em> ile imlenmiş işlevlere yapılan tüm çağrıları yazma kilidiyle ve yalnızca <em class="replaceable"><code>tanıtıcı</code></em> ile imlenmiş işlevlere yapılan tüm çağrıları da bir okuma kilidiyle koruyabilir.
       </p>
            </dd>
            <dt>
              <span class="glossterm">
                <code class="code">sig</code>
              </span>
              <span id="glibc-safety-sig" class="indexterm"></span>
            </dt>
            <dd class="glossdef">
              <p>
        <code class="code">MT-Safe</code> (ve kısa olması için çıkarılan, örtük olarak uygulanan özdeşi olan <code class="code">AS-Safe</code>) özellik olarak <code class="code">sig</code> ile imlenmiş işlevler, iki nokta üst üste iminden sonra tanımlanan sinyalin diğer kullanımları ile etkileşebilen bir sinyal işleyiciyi dahili amaçlarla geçici olarak kurabilir.
       </p>
              <p>
        Bu güvenilirlik sorunu, çağrı süresince sinyalin başka hiçbir şekilde kullanılmaması sağlanarak çözülebilir. Aynı geçici sinyali kullanan tüm işlevleri çağırırken ardışık olmayan bir muteks tutulması; çağrıdan önce bu sinyalin engellenmesi ve daha sonra işleyicisinin sıfırlanması önerilir.
       </p>
              <p>
        Önalanda iptal durumunda özgün sinyal işleyicinin geri yükleneceğini garanti etmenin güvenli bir yolu yoktur, bu nedenle bu şekilde imlenmiş işlevler ayrıca <code class="code">AC-Unsafe</code>'tir.
       </p>
              <p>
        İptal sorununu önlemek ve <code class="code">MT-Safe</code>/<code class="code">AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <em class="emphasis">ve</em> sinyali istenen duruma geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </p>
            </dd>
            <dt>
              <span class="glossterm">
                <code class="code">term</code>
              </span>
              <span id="glibc-safety-term" class="indexterm"></span>
            </dt>
            <dd class="glossdef">
              <p>
        <code class="code">MT-Safe</code>  özellik olarak <code class="code">term</code> ile imlenmiş işlevler, uçbirim ayarlarını önerilen şekilde değiştirebilir, yani: <strong class="function"><code>tcgetattr</code></strong> çağrısı yapar, bazı bayrakları değiştir ve ardından <strong class="function"><code>tcsetattr</code></strong> çağrısı yapar; Bu, diğer evreler tarafından yapılan değişikliklerin kaybolduğu bir pencere oluşturur. Bu nedenle, <code class="code">term</code> ile imlenen işlevler <code class="code">MT-Unsafe</code>'tir. Aynı pencere, önalan sinyallerinin kaybolması ile yapılan değişikliklerin etkin olmasını sağlar. Bu işlevler aynı zamanda <code class="code">AC-Unsafe</code>'tir, ancak ilgili im gereksiz olduğundan belirtilmez.
       </p>
              <p>
        Bu nedenle, uçbirimi kullanan uygulamaların uçbirimi sinyal işleyicilerde kullanmayarak veya onu kullanabilecek sinyalleri engelleyerek ve bu işlevleri çağırırken ve uçbirimle etkileşimde bulunurken bir kilit tutarak uç birim ile eşzamanlı ve çok evreli etkileşimlerden kaçınması önerilir. Bu kilit aynı zamanda <code class="code">race:tcattr(dt)</code> ile imlenmiş işlevlerle karşılıklı dışlama için kullanılmalıdır; burada <strong class="varname"><code>dt</code></strong>, denetim uçbiriminin dosya tanıtıcısıdır. Çağrıcı, basitlik için tek bir muteks kullanabilir veya farklı dosya tanıtıcıları tarafından atıf yapılsa bile uçbirim başına bir muteks kullanabilir.
       </p>
              <p>
        <code class="code">AC-Safe</code> özellik olarak <code class="code">term</code> ile imlenmiş işlevlerin, geçici değişiklikler sonrası uçbirimi özgün durumuna geri getiren ancak iptal edilmeleri durumunda bunu yapmakta başarısız olabilen işlevler olduğu varsayılır.
       </p>
              <p>
        İptal sorununu önlemek ve <code class="code">MT-Safe</code>/<code class="code">AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <em class="emphasis">ve</em> uçbirimi özgün durumuna geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </p>
            </dd>
          </dl>
        </div>
      </section>
    </section>
  </body>
</html>
