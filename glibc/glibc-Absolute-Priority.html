<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>22.3.1. Mutlak Öncelik</title>
    <link rel="stylesheet" type="text/css" href="../../style/nav.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/images/belgeler-logo.png" />
    <meta name="robots" content="index, follow" />
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Priority.html')">Önceki</button>
          <div class="dropdown-content">22.3. Sürecin İşlemci Önceliği ve Zamanlama</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc.html')">Ana Başlık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Priority.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Realtime-Scheduling.html')">Sonraki</button>
          <div class="dropdown-content">22.3.2. Anlık Zamanlama</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="sect1" id="glibc-Absolute-Priority">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">22.3.1. Mutlak Öncelik</h2>
            </div>
          </div>
        </div>
        <p>
    <span id="idm124418" class="indexterm"></span>
    <span id="idm124420" class="indexterm"></span>
    Her sürecin mutlak önceliği vardır ve bir sayı ile ifade edilir. Daha yüksek sayı daha yüksek mutlak öncelik demektir.
   </p>
        <p>
    <span id="idm124424" class="indexterm"></span>
    <span id="idm124428" class="indexterm"></span>
    Geçmişteki bazı sistemlerde ve günümüzde çoğu sistemde, tüm süreçlerin mutlak önceliği 0'dır ve bu bölümün konusu dışındadır. Bu durumla ilgili olarak, bkz. <a class="xref" href="glibc-Traditional-Scheduling.html" title="22.3.4. Geleneksel Zamanlama">Geleneksel Zamanlama</a>.  Mutlak öncelikler, belli süreçlerin dış olaylara yanıt vermesinin hayati önemde olduğu gerçek zamanlı sistemler için tasarlanmıştır. Bu sistemlerde çalışmak <em class="emphasis">isteyen</em> süreçler işlemciyi tutarken çalışması <em class="emphasis">gereken</em> süreçleri bekletmemesi amaçlanmıştır.
   </p>
        <p>
    <span id="idm124436" class="indexterm"></span>
    <span id="idm124439" class="indexterm"></span>
    <span id="idm124442" class="indexterm"></span>
    İşlemciyi herhangi bir anda kullanmaya çalışacak iki süreçten daha yüksek önceliği olan işlemciyi alır. Bunlardan biri işlemciyi zaten kullanmaktaysa ve önceliği düşükse önceliği yüksek olan işlemciyi yine alacaktır (yani, zamanlama ayrıcalıklıdır). Şüphesiz, burada bahsettiğimiz süreçler zaten başlatılmış yani çalışabilir olan ya da o an komutlarını çalıştırmaya hazır olmak anlamında "çalışmaya hazır" süreçlerdir. Bir süreç G/Ç işlemi gibi bir işlem nedeniyle beklemedeyse, onun önceliği konu dışıdır.
   </p>
        <div class="admon note">
          <h3 class="admon-title">Bilginize</h3>
          <div class="admon-contents">
            <p>
     "çalışabilir olmak" ile "çalışmaya hazır olmak" aynı anlamda kullanılmıştır.
    </p>
          </div>
        </div>
        <p>
    İki süreç de çalışabilir durumdaysa ya da çalışmaya hazırsa ve ikisinin de mutlak önceliği aynıysa, bu daha ilginçtir. Bu durumda işlemciyi hangisinin alacağını zamanlama kuralları belirler. Eğer süreçlerin mutlak öncelikleri 0 ise, işlemciyi hangisinin alacağı <a class="xref" href="glibc-Traditional-Scheduling.html" title="22.3.4. Geleneksel Zamanlama">Geleneksel Zamanlama</a> bölümünde anlatılan geleneksel zamanlama kurallarına göre bu saptanır. Aksi takdirde <a class="xref" href="glibc-Realtime-Scheduling.html" title="22.3.2. Anlık Zamanlama">Anlık Zamanlama</a> bölümünde anlatılan kurallar uygulanır..
   </p>
        <p>
    Normalde 0'ın üstünde bir mutlak öncelik, işlemciyi etkisiz bırakmayacaksa verilir. Böyle süreçler kısa bir işlemci kullanımından sonra beklemeye geçmek ya da sonlanmak üzere tasarlanır.
   </p>
        <p>
    Bir süreç, kendini başlatan süreç ile aynı mutlak öncelikle oluşturulur. Bu durumu değiştirebilen işlevler <a class="xref" href="glibc-Basic-Scheduling-Functions.html" title="22.3.3. Temel Zamanlama İşlevleri">Temel Zamanlama İşlevleri</a> bölümünde açıklanmıştır.
   </p>
        <p>
    Sadece ayrıcalıklı bir süreç kendi mutlak önceliğini <code class="code">0</code>'dan farklı bir değere ayarlayabilir. Sadece ayrıcalıklı süreç ya da hedef sürecin sahibi mutlak önceliği değiştirebilir.
   </p>
        <p>
    POSIX, gerçek zamanlı zamanlama kuralları ile kullanılan mutlak öncelik değerlerinin 32'den başlayan ve ardışık sıralanan değerler olmasını gerektirir. Linux'ta 1 ile 99 arasındadır. Taşınabilirlik açısından, <a href="glibc-Basic-Scheduling-Functions.html#glibc-fn-sched_get_priority_max"><strong class="function"><code>sched_get_priority_max</code></strong></a> ve <strong class="function"><code>sched_set_priority_min</code></strong> işlevleri belli bir sistem üzerinde geçerli aralığın ne olduğunu söyler.
   </p>
        <section class="sect2" id="glibc-Using-Absolute-Priority">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">22.3.1.1. Mutlak Önceliğin Kullanımı</h3>
              </div>
            </div>
          </div>
          <p>
     Gerçek zamanlı uygulamalar tasarlanırken unutulmaması gereken tek şey diğer süreçlerden daha yüksek bir mutlak önceliğin sürecin çalışma sürekliliğini garanti etmeyeceğidir. İşlemcinin çalışmasını kazaya uğratan iki şey vardır: kesmeler ve sayfalama hataları.
    </p>
          <p>
     Kesme işleyicileri süreçler arasındaki bu belirsizlik içinde yaşar. Komutlarını işlemci çalıştırır ama onlar sürecin parçası değildir. Bir kesme en yüksek öncelikli süreci bile durdurur. Bu durumda önemsiz derecede küçük gecikmelere izin verilmeli ve sürecin komutları arasında çok uzun gecikmelere sebep olabilecek kesme işleyicilere sahip aygıtların olmadığından da emin olunmalıdır.
    </p>
          <p>
     Benzer şekilde, bir sayfalama hatası, basit bir komut dizisinin uzun bir zaman alıyormuş gibi görünmesine sebep olur. Aslında, sayfalama hatası sırasında bundan etkilenmeyen süreçler çalışmaya devam eder, çünkü G/Ç'ların tamamlanması gerekir, ancak yüksek öncelikli süreç onları atıp tekrar çalışmaya devam eder. Esas sorun G/Ç için, öncelikli sürecin kendisinin bekleme durumuna geçmesi olurdu. Bu aşamayı etkisiz hale getirmek için <a href="glibc-Page-Lock-Functions.html#glibc-fn-mlock"><strong class="function"><code>mlock</code></strong></a> veya <a href="glibc-Page-Lock-Functions.html#glibc-fn-mlockall"><strong class="function"><code>mlockall</code></strong></a> kullanılır.
    </p>
          <p>
     Bir öncelik vermeyi seçerken ve ayrıca yüksek mutlak öncelikli bir yazılım da çalıştırılıyorsa, akılda tutulması gereken şey, tek işlem birimli tek işlemcili bir sistemde bu önceliğin mutlaklığının bunlar arasında bölüneceğidir. Diğer süreçlere göre daha yüksek mutlak öncelikli bir sürecin, yazılımındaki bir hatadan dolayı sonsuz döngüye girdiğini varsayılsın. Çalışması sırasında işlemciden asla vazgeçmeyecektir. Hatalı yazılım denetimi tamamen, her yönden ele geçirir. Bir komut çalıştırmak için onu öldürmekten başka çare kalmaz.
    </p>
          <p>
     Bundan kaçınmanın iki yolu vardır: 1) bir yerlerde çalışmakta olan daha yüksek öncelikli bir kabuk bulundurmak (root'un açtığı bir kabuk örneğin). 2) yüksek öncelikli süreç grubu ile ilişkili bir denetim uçbirimi tutmak. Çalışmaya başlayan bir kesme işleyiciden kaçacak ya da <span class="keycap"><strong>C-c</strong></span> tuşlandığında sinyal alıp da durmayacak bir öncelik mevcut değildir.
    </p>
          <p>
     Bazı sistemler mutlak önceliği, işlemci zamanının belli bir yüzdesini bir sürece ayırmak manasında kullanırlar. Bunu yapmak için, süper yüksek öncelikli ve ayrıcalıklı bir süreç, süreclerin işlemci kullanımını sürekli olarak gözler, payını alamayan sürecin mutlak önceliğini yükseltir, payından fazlasını alan sürecin mutlak önceliğini düşürür.
    </p>
          <div class="admon note">
            <h3 class="admon-title">Bilginize</h3>
            <div class="admon-contents">
              <p>
      Mutlak öncelik kimi zaman "duruk öncelik" diye de anılır; bu kılavuzda bu terim kullanılmamaktadır, çünkü mutlak önceliğin en önemli özelliği, mutlaklığı kaybolur.
     </p>
            </div>
          </div>
        </section>
      </section>
      <footer>
        <div align="center" class="footer">
          <small>Bir <a href="http://belgeler.org.tr/">Linux Kitaplığı</a> Sayfası</small>
        </div>
      </footer>
    </section>
  </body>
</html>
