<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="tr" xml:lang="tr">
  <head>
    <title>1.3.2. POSIX (Taşınabilir İşletim Sistemi Arayüzü)</title>
    <meta name="generator" content="DocBook XSL Stylesheets V-special (derived from DocBook XSL v1.79.1 for Turkish Linux Documentation Project by Nilgün Belma Bugüner - nilgun (at) tlbp.org.tr)" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="/style/belgeler.css" />
    <link rel="stylesheet" type="text/css" href="/style/nav.css" />
    <link rel="icon" type="image/png" href="/images/belgeler-logo.png" />
  </head>
  <body>
    <header>
      <div class="navbar">
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-ISO-C.html')">Önceki</button>
          <div class="dropdown-content">1.3.1. ISO C</div>
        </div>
        <div style="width:34%" class="dropdown">
          <button class="dropbtn">Yukarı</button>
          <div class="dropdown-content">
            <button type="button" class="dropbtn" onclick="window.location.assign('/index.html')">Baş Sayfa</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('/KiTAPLIK/index.html')">Kitaplık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc.html')">Ana Başlık</button>
            <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Standards-and-Portability.html')">Üst Başlık</button>
          </div>
        </div>
        <div style="width:33%" class="dropdown">
          <button type="button" class="dropbtn" onclick="window.location.assign('glibc-Berkeley-Unix.html')">Sonraki</button>
          <div class="dropdown-content">1.3.3. Berkeley Unix, SVID ve XPG</div>
        </div>
      </div>
    </header>
    <section class="mainpage">
      <div class="crumbs">
        <p>  </p>
      </div>
      <section class="sect1" id="glibc-POSIX">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">1.3.2. POSIX (Taşınabilir İşletim Sistemi Arayüzü)</h2>
            </div>
            <div>
              <h3 class="subtitle">POSIX (The Portable Operating System Interface)</h3>
            </div>
          </div>
        </div>
        <span id="glibc-cp-posix" class="indexterm"></span>
        <span id="glibc-cp-posix1" class="indexterm"></span>
        <span id="glibc-cp-10031" class="indexterm"></span>
        <span id="glibc-cp-99451" class="indexterm"></span>
        <span id="glibc-cp-posix2" class="indexterm"></span>
        <span id="glibc-cp-10032" class="indexterm"></span>
        <span id="glibc-cp-99452" class="indexterm"></span>
        <p>
    GNU kütüphanesi ayrıca, <em class="wordasword">Bilgisayar Ortamları için Taşınabilir İşletim Sistemi Arayüzü</em> olarak da bilinen ISO  <em class="firstterm">POSIX</em> ailesi standartlarla da (ISO/IEC 9945) uyumludur.  Bunlar ayrıca ANSI/IEEE Std 1003 olarak da yayınlanmıştır. POSIX genellikle Unix işletim sisteminin çeşitli sürümlerinden türetilmiştir.
   </p>
        <p>
    
    
    
    
    POSIX standartları ile belirtilen kütüphane oluşumları ISO C ile belirlenenlerin bir üst kümesidir. POSIX, yeni ek işlevler ya da ISO C işlevlerine eklenen bazı özellikleri belirtir. Genellikle POSIX standartları tarafından tanımlanan ek gereksinimler ve işlevsellik, farklı işletim sistemi ortamlarında çalışabilen genel yazılım geliştirme dilinden ziyade işletim sistemlerinin belli çeşitlerine düşük seviyede destek sağlamak amacındadır.
   </p>
        <p>
    GNU C kütüphanesi [<span class="citation">ISO/IEC 9945-1:1996, POSIX Sistem Uygulaması Geliştirme Arayüzü</span>] tarafından belirlenen işlevlerin tümünü gerçekler. Kılavuzda bu standart bahis konusu olduğunda POSIX.1 nitelemesi kullanılacaktır. Bu standart tarafından ISO C oluşumlarına ek birincil genişletmeler, dosya sistemi arayüzü ilkelleri (<a class="xref" href="glibc-File-System-Interface.html" title="14. Dosya Sistemi Arayüzü">Dosya Sistemi Arayüzü</a>), aygıta özgü uçbirim denetim işlevleri (<a class="xref" href="glibc-Low-Level-Terminal-Interface.html" title="17. Düşük Seviyeli Uçbirim Arayüzü">Düşük Seviyeli Uçbirim Arayüzü</a>) ile süreç denetim işlevlerini (<a class="xref" href="glibc-Processes.html" title="26. Süreçler">Süreçler</a>) içerir.
   </p>
        <p>
    
    
    
    Ayrıca, [<span class="citation">ISO/IEC 9945-2:1993, POSIX Kabuk and Komutlar standardı</span>] (POSIX.2) içindeki bazı oluşumlara da GNU kütüphanesinde yer verilmiştir. Bunlar kalıp eşleme oluşumlarını ve düzenli ifadeleri kullanan uygulamalardır(Bkz. <a class="xref" href="glibc-Pattern-Matching.html" title="10. Şablon Eşleme">Şablon Eşleme</a>).
   </p>
        <section class="sect2" id="glibc-POSIX-Safety-Concepts">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">1.3.2.1. POSIX Güvenlik Kavramları</h3>
              </div>
            </div>
          </div>
          <span id="glibc-cp-safety" class="indexterm"></span>
          <p>
     Bu kılavuz, GNU C Kütüphanesi işlevlerinin çeşitli güvenilirlik özelliklerini, işlevlerin gösterimlerinin ardından gelen ve şuna benzer satırlarda belgelemektedir:
    </p>
          <p>Evresel Güvenilirlik: | MT-Safe | AS-Safe | AC-Safe |</p>
          <p>
     Özellikler, <code class="literal">Thread-</code>, <code class="literal">Async-Signal-</code> ve <code class="literal">Async-Cancel- -Safety</code> gibi güvenlik bağlamları için POSIX standardında belirtilen kurallara göre değerlendirilir. Bunu standart tanımların anlamını yakalamaya çalışan, bu özelliklerin sezgisel tanımları izler.
    </p>
          <div class="glosslist">
            <dl>
              <dt>
                <span class="glossterm"><code class="code">MT-Safe</code>, <code class="code">Thread-Safe</code></span>
                <span id="glibc-cp-mtsafe" class="indexterm"></span>
                <span id="glibc-cp-tsafe" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> (Çok Evreli Güvenilir) veya <code class="code">Thread-Safe</code> (Evreli Güvenilir) işlevlerin başka evreler varken çağrılması güvenlidir. <code class="code">MT-Safe</code> içindeki MT, "Çok Evreli" anlamında bir kısaltmadır.
       </p>
                <p>
        <code class="code">MT-Safe</code> olmak, o işlevin bölünmez bütünlükte olduğu veya POSIX'in kullanıcılara sunduğu eşzamanlı bellek tahsis mekanizmalarından birinin kullanıldığı anlamına gelmez. İşlem sırasında  <code class="code">MT-Safe</code> işlevlerin çağrılmasının bir  <code class="code">MT-Safe</code> birleşimi vermemesi bile mümkündür. Örneğin, iki  <code class="code">MT-Safe</code> işlevin peşpeşe evresel çağrı yapması, diğer evrelerdeki eşzamanlı çağrılarla yıkıcı şekilde etkileşime gireceğinden, bunların tek bir bölünmez bütün olarak yürütülmesini garanti etmez.
       </p>
                <p>
        
        Kütüphane arayüzleri genelinde işlevlerde satırlaştırma yapabilen tüm en iyilemeler, güvenli olmayan yeniden sıralamaya neden olabileceğinden GNU C Kitaplığı arayüzü genelinde satırlaştırma (inlining) yapılması önerilmez. Belgelenmiş  <code class="code">MT-Safe</code> durumu, yazılımın tamamının en iyilenmesi durumunda garanti edilmez. Ancak, kullanıcıya görünür başlık dosyalarında tanımlanan işlevler, satırlaştırma için güvenilir olacak şekilde tasarlanmıştır.
       </p>
              </dd>
              <dt>
                <span class="glossterm"><code class="code">AS-Safe</code>, <code class="code">Async-Signal-Safe</code></span>
                <span id="glibc-cp-assafe" class="indexterm"></span>
                <span id="glibc-cp-as-safe" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AS-Safe</code> (Önalanda Sinyal Güvenilir) veya <code class="code">Async-Signal-Safe</code> (Önalan-Sinyal-Güvenilir) işlevlerin önalanda sinyal işleyiciler varken çağrılması güvenlidir.  <code class="code">AS-Safe</code> içindeki AS, "Önalanda Sinyal" anlamında bir kısaltmadır.
       </p>
                <p>
        <code class="code">AS-Safe</code> olan pek çok işlev, <code class="code">errno</code> değeri atayabilir veya kayan- noktalı sayı ortamını değiştirebilir, çünkü bunu yapmaları onları sinyal işleyicilerde kullanılamaz duruma getirmez. Ancak, önalandaki sinyal işleyicileri bu evreye-özgülük durumunu değiştirirse uygulamalar yanlış çalışabilir ve sinyal işleme mekanizmasının bunu koruyacağına güvenilemez. Bu nedenle,<code class="code">errno</code> değeri atayabilecek veya  kayan- noktalı sayı ortamını değiştirebilecek işlevleri çağıran sinyal işleyicileri özgün değerlerini kaydetmeli ve geri dönmeden önce bu özgün değerleri yerine koymalıdır.
       </p>
              </dd>
              <dt>
                <span class="glossterm"><code class="code">AC-Safe</code>, <code class="code">Async-Cancel-Safe</code></span>
                <span id="glibc-cp-acsafe" class="indexterm"></span>
                <span id="glibc-cp-ac-safe" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AC-Safe</code> (Önalanda İptal Güvenilir) veya <code class="code">Async-Cancel-Safe</code> (Önalanda-İptal-Güvenilir) işlevlerin çağrılması önalanda iptal etkin olduğunda güvenlidir.  <code class="code">AC-Safe</code> içindeki AC, "Önalanda İptal" anlamında bir kısaltmadır.
       </p>
                <p>
        POSIX standardı yalnızca üç <code class="code">AC-Safe</code> işlev tanımlar:  <strong class="function"><code>pthread_cancel</code></strong>, <strong class="function"><code>pthread_setcancelstate</code></strong> ve <strong class="function"><code>pthread_setcanceltype</code></strong>. Günümüzde GNU C Kütüphanesi bu üç işlevle ilgili hiçbir garanti vermez, yalnızca hangi işlevlerin halihazırda <code class="code">AC-Safe</code> olduğunu belgelendirir. Bu belgelendirme GNU C Kütüphanesi geliştiricilerinin kullanımına ayrılmıştır.
       </p>
                <p>
        Tıpkı sinyal işleyiciler gibi, iptal temizleme yordamları da ihtiyaç duydukları kayan-noktalı ortamı yapılandırmalıdır. Bu yordamlar, özellikle önalanda iptal etkin olduğunda, bir kayan-noktalı ortam olduğunu varsayamaz. Kayan-noktalı ortamının yapılandırması atomik olarak (bölünmez bütünlükte) gerçekleştirilemezse, karşılaşılan ortamın kendi içinde tutarsız olması da mümkündür.
       </p>
              </dd>
              <dt>
                <span class="glossterm"><code class="code">MT-Unsafe</code>, <code class="code">AS-Unsafe</code>, <code class="code">AC-Unsafe</code></span>
                <span id="glibc-cp-mtunsafe" class="indexterm"></span>
                <span id="glibc-cp-tunsafe" class="indexterm"></span>
                <span id="glibc-cp-asunsafe" class="indexterm"></span>
                <span id="glibc-cp-as-unsafe" class="indexterm"></span>
                <span id="glibc-cp-acunsafe" class="indexterm"></span>
                <span id="glibc-safety-ac-unsafe" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Unsafe</code> (Çok Evreli Güvenilmez), <code class="code">AS-Unsafe</code> (Önalanda Sinyal Güvenilmez), <code class="code">AC-Unsafe</code> (Önalanda İptal Güvenilmez) özellikli işlevlerin çağrılması yukarıda açıklanan güvenlik bağlamları içinde güvenli değildir. Böyle bağlamlar içinde çağrılmaları tanımsız davranışa yol açar.
       </p>
                <p>
        Güvenilir bağlamda açıkça "Güvenilir" olarak belgelenmemiş işlevler "Güvenilmez" olarak kabul edilmelidir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">Preliminary</code>
                </span>
                <span id="glibc-cp-preliminary" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">Preliminary</code> güvenilirlik (Evresel Güvenilirlik) özellikleri, bu özelliklerin GNU C Kitaplığının <em class="emphasis">gelecekteki sürümlerinde hesaba katılmayabileceği varsayımıyla</em> belgelenmiştir.
       </p>
                <p>
        Bu belgeye konu evresel güvenilirlik özellikleri, mevcut ve gelecekteki standartlar tarafından zorunlu kılınan ve izin verilen özelliklerin değil, mevcut GNU C Kütüphanesi gerçekleniminin özelliklerinin değerlendirilmesinin sonucudur.
       </p>
                <p>
        Standartlara uymaya çalışmamıza rağmen bazı durumlarda, standart tarafından talep edilmese bile, gerçeklenimimiz güvenilirdir ve diğer durumlarda gerçeklenimimiz standart güvenilirlik gereksinimlerini karşılamamaktadır. İkinci durum büyük olasılıkla gerçeklenimdeki hatalardır; İlki, "Evresel Güvenilirlik" bağlamında ele alınmamalıdır: Gelecekteki standartlar, mevcut gerçeklenimin sağladığı ek güvenlik özellikleriyle uyumlu olmayan değişiklikler gerektirebilir.
       </p>
                <p>
        Ayrıca, POSIX standardı ayrıntılı bir güvenilirlik tanımı da sunmamaktadır. POSIX'in "çağırmak için güvenilir" ile, yazılım tanımsız davranış başlatmadığı sürece, "çağırmak için güvenilir" işlevin belirtildiği gibi davrandığını ve diğer işlevlerin belirtilen davranışlarından sapmasına neden olmadığını kastettiğini varsayıyoruz. Gevşek güvenilirlik tanımlarını, kullanılacak en iyi tanımlar oldukları için değil, ancak bu kılavuzu POSIX ile uyumlu hale getirdiği için kullanmayı seçtik.
       </p>
                <p>
        Bunların ön tanımlar ve ek açıklamalar olduğu, tanımların belirli yönlerinin hala tartışıldığı, açıklanmaya veya değişikliğe konu olabileceği unutulmamalıdır.
       </p>
                <p>
        Zamanla, "Evresel Güvenilirlik" bilgilerini, arayüzlerimiz kadar istikrarlı, kararlı taahhütlere dönüştürmeyi düşünüyoruz. Yaptığımızda görüleceği gibi, <code class="code">Preliminary</code> anahtar sözcüğünü (bu çeviride "Evresel Güvenilirlik" karşılığını) güvenilirlik bilgilerinden kaldıracağız. Bununla birlikte, anahtar sözcük olarak kaldığı sürece, gelecekteki davranışımızın teminatı olarak görülmemelidir.
       </p>
              </dd>
            </dl>
          </div>
          <p>
     "Evresel Güvenilirlik" bilgilerinde görünen diğer anahtar sözcükler sonraki bölümlerde tanımlanmıştır.
    </p>
        </section>
        <section class="sect2" id="glibc-Unsafe-Features">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">1.3.2.2. Güvenilmez Özellikler</h3>
              </div>
            </div>
          </div>
          <span id="glibc-cp-unsafety" class="indexterm"></span>
          <p>
     Belirli bağlamlarda çağrılması güvenli olmayan işlevlerin çağrılmalarını güvensiz kılan özellikleri belirli anahtar sözcüklerle sınıflandırılmıştır. Bu bölümdeki <code class="code">AS-Unsafe</code> özellikler, önalanda sinyaller etkinken çağrılması asla güvenilir olmayan işlevleri belirtir. <code class="code">AC-Unsafe</code> özellikler ise önalanda iptal etkinken çağrılması asla güvenilir olmayan işlevleri belirtir. Bu bölümde <code class="code">MT-Unsafe</code> özelliklerle ilgili sınıflama yoktur.
    </p>
          <div class="glosslist">
            <dl>
              <dt>
                <span class="glossterm">
                  <code class="code">lock</code>
                </span>
                <span id="glibc-safety-lock" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AS-Unsafe</code> özellik olarak <code class="code">lock</code> ile belirtilen işlevler, ardışık olmayan bir kilidi tutarken sinyalle kesintiye uğrayabilir. Sinyal işleyici aynı kilidi alan başka bir işlevi çağırırsa, sonuç kısır döngüdür.
       </p>
                <p>
        <code class="code">AC-Unsafe</code> özellik olarak <code class="code">lock</code> ile belirtilen işlevler, önalanda iptal edilirse, yürütmeleri bu şekilde kesintiye uğratılmamış olsaydı serbest bırakacakları bir kilidi serbest bırakamayabilir. Bir kilit bir kere alındıktan sonra, o kilidi alma girişimleri sürekli engellenir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">corrupt</code>
                </span>
                <span id="glibc-safety-corrupt" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AS-Unsafe</code> özellik olarak <code class="code">corrupt</code> ile belirtilen işlevler, veri yapılarını bozabilir ve kesintiye sebep olduklarında veya başka bir işlev tarafından kesintiye uğratıldıklarında yanlış davranabilir. <code class="code">lock</code> ile belirtilen işlevlerin tersine, bunlar, <code class="code">MT-Safety</code> sorunlarından kaçınmak için ardışık kilitler alır, ancak bu, bir sinyal işleyicinin kısmen güncellenmiş bir veri yapısını gözlemlemesini durdurmak için yeterli değildir. Kesintiye uğrayan işlevin sinyal işleyiciler tarafından yapılan güncellemeleri fark etmemesi daha fazla bozulmaya neden olabilir.
       </p>
                <p>
        <code class="code">AC-Unsafe</code> özellik olarak <code class="code">corrupt</code> ile belirtilen işlevler, veri yapılarını bozuk, kısmen güncellenmiş durumda bırakabilir, veri yapısının sonraki kullanımlarında işlev yanlış davranabilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">heap</code>
                </span>
                <span id="glibc-safety-heap" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">heap</code> ile belirtilen işlevler, <a href="glibc-Unconstrained-Allocation.html#glibc-fn-malloc"><strong class="function"><code>malloc</code></strong></a>/<a href="glibc-Freeing-after-Malloc.html#glibc-fn-free"><strong class="function"><code>free</code></strong></a> işlev ailesinden yığın bellek yönetimi işlevlerini çağırabilir ve yalnızca bu işlevler kadar güvenilirdir. <code class="code">heap</code> şuna eşdeğerdir:
       </p>
                <p>
        | AS-Unsafe lock | AC-Unsafe lock fd mem |
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">dlopen</code>
                </span>
                <span id="glibc-safety-dlopen" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
       <code class="code">dlopen</code> ile belirtilen işlevler, paylaşımlı kütüphaneleri geçerli yürütme imgesine yüklemek için özdevimli yükleyiciyi kullanır. Bu, dahili özdevimli yükleyicinin kilitleri tutulurken dosyalar açılabilir, bunlar belleğe eşlenebilir, ek bellek tahsis edilebilir, semboller çözümlenebilir, yer değiştirmeler uygulanabilir ve daha pek çok şey yapılabilir.
       </p>
                <p>
        Kilitler, bu işlevlerin <code class="code">AS-Unsafe</code> ve <code class="code">AC-Unsafe</code>  olması için yeterlidir, ancak başka sorunlar ortaya çıkabilir. Şu anda <code class="code">dlopen</code>, kendi üzerinden gündeme getirilen tüm olası güvenilirlik sorunları için bir yer tutucudur.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">plugin</code>
                </span>
                <span id="glibc-safety-plugin" class="indexterm"></span>
                <span id="glibc-safety-plugin-nss" class="indexterm"></span>
                <span id="glibc-safety-plugin-iconv" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">plugin</code> ile belirtilen işlevler GNU C Kütüphanesinin dışındaki eklentilerden kod çalıştırabilir. Bu tür eklenti işlevlerinin <code class="code">MT-Safe</code>, <code class="code">AS-Unsafe</code> ve <code class="code">AC-Unsafe</code> olduğu varsayılır. Bu tür eklentilere örnek olarak yığıt boşaltma kütüphaneleri, ad hizmeti anahtarı (NSS) ve karakter kümesi dönüştürme (iconv) eklentileri verilebilir.
       </p>
                <p>
        Örnek olarak belirtilen eklentilerin tümü <code class="code">dlopen</code> aracılığıyla getirilse de, <code class="code">plugin</code> anahtar sözcüğü, özdevimli yükleyicinin veya <code class="code">libdl</code> arayüzlerinin herhangi bir doğrudan katkısını gerektirmez, bunlar <code class="code">dlopen</code> kapsamındadır. Örneğin, bir işlev zaten çözülmüş işlevleri çağırırken başka bir işlev bir modülü yükleyip modüldeki işlevlerin bazı adreslerini buluyorsa, ilki <code class="code">plugin</code> ile, ikincisi <code class="code">dlopen</code> ile imlenir. Tüm eylemleri tek bir işlev yerine getiriyorsa, her iki imi de alır.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">i18n</code>
                </span>
                <span id="glibc-safety-i18n" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">i18n</code> ile belirtilen işlevler <code class="code">gettext</code> ailesinden 18n işlevlerini çağırabilir ve ancak bu işlevler kadar güvenilir olabilir. <code class="code">i18n</code> şuna eşdeğerdir:
       </p>
                <p>
        | MT-Safe env | AS-Unsafe corrupt heap dlopen | AC-Unsafe corrupt
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">timer</code>
                </span>
                <span id="glibc-safety-timer" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">timer</code> ile belirtilen işlevler, bir sistem çağrısı veya uzun süren bir işlem için zaman aşımı ayarlamak üzere <strong class="function"><code>alarm</code></strong> işlevini veya benzerini kullanır. Çok evreli bir yazılımda, zaman aşımı sinyalinin farklı bir evreyi kesintiye uğratması ve dolayısıyla amaçlanan evrenin kesintiye uğramaması riski vardır. <code class="code">MT-Unsafe</code> olmanın yanısıra bu tür işlevler, bunları çağıran sinyal işleyiciler, kesintiye uğratılan kod tarafından atanan zamanlayıcılarla etkileşime girebileceğinden daima <code class="code">AS-Unsafe</code>'tir ve önalanda iptal durumunda daha önceki bir zamanlayıcının sıfırlanacağını garanti etmenin güvenilir bir yolu olmadığından <code class="code">AC-Unsafe</code>'tir.
       </p>
              </dd>
            </dl>
          </div>
        </section>
        <section class="sect2" id="glibc-Conditionally-Safe-Features">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">1.3.2.3. Koşullu Olarak Güvenilir Özellikler</h3>
              </div>
            </div>
          </div>
          <span id="glibc-cp-consafe" class="indexterm"></span>
          <p>
     Belirli bağlamlarda işlevlerin çağrılmasını güvensiz kılan bazı özellikler için, işlevi çağırmaktan tamamen kaçınmak dışında güvenlik sorununu ortadan kaldıracak bazı yollar vardır. Aşağıdaki anahtar sözcükler bu tür özelliklere atıfta bulunur ve bunların tanımlarının her biri, anahtar sözcük tarafından belirtilen güvenilirlik sorununu ortadan kaldırmak için tüm yazılımın nasıl sınırlandırılması gerektiğini gösterir. Yalnız ve yalnız, bir işlevi güvensiz kılan tüm nedenler gözlemlenip belgelenmiş kısıtlamalar uygulanarak ele alındığında işlevin o bağlamda çağrılması güvenilir hale gelir.
    </p>
          <div class="glosslist">
            <dl>
              <dt>
                <span class="glossterm">
                  <code class="code">init</code>
                </span>
                <span id="glibc-safety-init" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevler, ilk çağrıldıklarında <code class="code">MT-Unsafe</code> ilklendirme yapar.
       </p>
                <p>
        Böyle bir işlevi tek evreli kipte en az bir kez çağırmak, işlevin <code class="code">MT-Unsafe</code> olarak değerlendirilmesine sebep olan bu özel nedeni ortadan kaldırır. Bunun için başka bir neden kalmadıysa, diğer evreler başlatıldıktan sonra işlev güvenli bir şekilde çağrılabilir.
       </p>
                <p>
        <code class="code">AS-Unsafe</code> veya <code class="code">AC-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevler, dahili veri yapılarını ilklendirmek için dahili <code class="code">libc_once</code> mekanizmasını veya benzerini kullanır.
       </p>
                <p>
        Bir sinyal işleyici böyle bir ilklendiriciyi kesintiye uğratır ve üstüne <code class="code">libc_once</code> ilklendirmesini uygulayacak bir işlevi çağırırsa, evre kütüphanesi yüklü olduğu takdirde kısır döngü oluşur.
       </p>
                <p>
        Dahası, bir ilklendirici iptal edilmeden veya işleyicisi aynı ilklendirmeyi gerektiren bir sinyal tarafından kesintiye uğratılmadan önce kısmen tamamlanmışsa, ilklendirmenin bir kısmı veya tamamı birden fazla kez uygulanabilir, bu da kaynakların boşa harcanmasına ve hatta dahili verilerin bozulmasına neden olabilir.
       </p>
                <p>
        <code class="code">AS-Unsafe</code> veya <code class="code">AC-Unsafe</code> özellik olarak <code class="code">init</code> ile imlenmiş işlevleri çağırması gereken yazılımlarda, <code class="code">libc_once</code> ile ilgili <code class="code">AS-Unsafe</code> ve <code class="code">AC-Unsafe</code> sorunlarının ortaya çıkmaması için sinyal işleyicileri yapılandırılmadan veya iptali etkinleştirilmeden önce ilklendirme yapılmış olmalıdır.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">race</code>
                </span>
                <span id="glibc-safety-race" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safety</code> özellik olarak <code class="code">race</code> ile imlenmiş işlevler, aynı anda yürütme dışında benzer yıkıcı girişim biçimlerine veya veri yarışlarına neden olabilecek şekilde nesneler üzerinde işlem yapar. Nesneler, bazı durumlarda kullanıcılar tarafından işlevlere aktarılırken bazı durumlarda da işlevler tarafından kullanıcılara değer döndürmek için kullanılır, bazı durumlarda ise kullanıcılara hiç görünmez.
       </p>
                <p>
        İşlevlere (dolaylı) olarak aktarılan nesnelere erişimin veri yarışından bağımsız olduğu varsayılır. Veri yarışından bağımsız nesnelerin güvenilirliği işlevi çağıranın sorumluluğundadır. Yazılımcı bu tür nesnelerle uğraşırken veri yarışlarını önlemek için POSIX'in gerektirdiği önlemleri almadığı için işlev hatalı davranırsa, bu işlev <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlenmez.
       </p>
                <p>
        Genel bir kural olarak, bir işlevin (atıf yoluyla) aktarılan bir nesneden okuma yaptığı veya bu nesneyi değiştirdiği durumlarda, yazılımcının kütüphane işlevini çağırmak yerine nesneye erişimi kendisinin gerçekleştirmesi, veri yarışlarından kaçınmak için de bellek eşzamanlama ilkellerini kullanması gerekir. POSIX, <code class="type">FILE</code> akımlarını işleyen birçok işlevde veri yarışlarına karşı kütüphanenin koruma sağlamasını zorunlu kıldığından <code class="type">FILE</code> akımları bu genel kuralın dışındadır. Bunu, diğer türleri de kapsayacak şekilde genişletilmesi gerektiği yönündeki beklentilerin aksine, genel bir gereklilik olarak değil, kullanıcılara sağlanan bir kolaylık olarak görüyoruz.
       </p>
                <p>
        Yazılımcılara belirli bağımsız değişkenleri korumanın kendi sorumlulukları olduğunu hatırlatmak için, belirli türdeki nesneleri bağımsız değişken olarak alan işlevlere açıklama ekleyeceğiz. Yazılımcı tarafından aktarılan nesneler ile ilgili olarak çizgiyi şu şekilde çekiyoruz: Bellek tamponları, dizgeler ve kullanıcı tarafından görülebilen <code class="type">struct</code> türleri gibi, türleri kullanıcılara açık olan ve kullanıcıların doğrudan erişmesi beklenen nesneler, işlevlerin <code class="code">race</code> ile imlenmesine neden <em class="emphasis">olmaz</em>. Bu, genel gereksinime göre gürültülü ve gereksiz olacak ve yazılımcının doğrudan erişilebildiği nesnelere erişirken kütüphanenin buna dahili olarak koruma sağlamaması kimseyi pek şaşırtmayacaktır.
       </p>
                <p>
        Yalnızca kütüphane işlevlerine aktarılarak üzerinde işlem yapılabilecek olan (örneğin, <code class="type">FILE</code>, <code class="type">DIR</code>, <code class="type">obstack</code>, <code class="type">iconv_t</code> gibi) geçirimsiz nesneler ve benzeri için, kütüphane tarafından erişimin dahili yönetimine ilişkin ek beklentiler olabilir. Bu tür nesneleri alan ancak öntanımlı olarak bunlara erişimi zamanlamaya özen göstermeyen işlevlerin bağımsız değişkenlerini, <code class="code">race</code>:<em class="replaceable"><code>değişken</code></em> sözdizimiyle imleyeceğiz. Örneğin, <code class="type">FILE</code> akımının "kilitleme yapmayan" işlevleri imlenir, ancak örtük kilitleme akım bazında devre dışı bırakılmış olsa bile, <code class="code">FILE</code> akımlarında öntanımlı olarak örtük kilitleme gerçekleştirenlere bu uygulanmaz.
       </p>
                <p>
        Her iki durumda da, yazılımcının, erişimlerin iyi tanımlandığından emin olmaması durumunda, yazılımcı tarafından sağlanan nesnelere güvenli olmayan yollarla erişebilen <code class="code">MT-Unsafe</code> işlevleri dikkate almayacağız. Yazılımcılarda, yazılımcı tarafından sağlanan ve kütüphanenin yazılımcı adına eriştiği nesneleri veri yarışlarına karşı korumasının beklendiği fikri hakimdir.
       </p>
                <p>
        Ancak, bu kullanıcı sorumluluğu, belirli çağrılardan değer döndürmek için kullanılan dahili nesneler ve statik tamponlar gibi kütüphane tarafından denetlenen nesneler için geçerli değildir. Kütüphane bunları artalandaki kullanımlara karşı korumadığında, bu durumlar <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak kabul edilir (ancak <code class="code">AS-Unsafe</code> özellik olarak <code class="code">race</code> imi, <code class="code">MT-Unsafe</code> olanı varken gereksiz olduğundan yok sayılır). Yazılımcıya terkedilen nesnelerde olduğu gibi, imden sonra iki nokta üst üste ve <em class="replaceable"><code>tanıtıcı</code></em> gelebilir. <em class="replaceable"><code>tanıtıcı</code></em>, belirli bir korumasız nesne üzerinde çalışan tüm işlevleri gruplandırır. Yazılımcı, denetimindeki nesnenin <em class="replaceable"><code>tanıtıcı</code></em>sıyla ilgili ardışık olmayan bir muteks oluşturarak ve bu <em class="replaceable"><code>tanıtıcı</code></em>da <code class="code">race</code> olarak imlenmiş herhangi bir işlevi çağırırken muteksi daima tutarak, bu tür dahili nesnelere önalanda korumasız erişimle ilgili <code class="code">MT-Safe</code> sorunlarından kaçınabilir. Ardışık olmayan muteks, Çok Evreli güvenilirliği ile ilgili sorunu önler, ancak Önalanda Sinyal güvenilirliği sorununu diğeriyle değiştirir, bu nedenle önalanda sinyal kullanımı tanımsız kalır.
       </p>
                <p>
        <em class="replaceable"><code>tanıtıcı</code></em>, dönüş değerlerini tutmak için kullanılan statik bir tampona ait olduğunda, tampon çağrıcı tarafından kullanıldığı sürece muteks tutulmalıdır. Statik tamponlara gösterici döndüren birçok işlev, bunun yerine geri dönüş değerlerini çağrıcı tarafından sağlanan tamponlarda saklayan evresel karşılıklarını sunar. <code class="code">tmpname</code> gibi bazı durumlarda bu evresel karşılık, ayrı bir giriş noktası çağrılarak değil, döndürülen değerlerin saklanacağı tampona NULL olmayan bir gösterici aktarılarak seçilir. Bu evresel karşılıklar, <code class="code">race</code> olarak imlenmiş diğer dahili tamponlar nedeniyle <code class="code">MT-Safe</code> değilse de, genellikle çok evreli yazılımlarda tercih edilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">const</code>
                </span>
                <span id="glibc-safety-const" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">const</code> ile imlenmiş işlevler, GNU C Kütüphanesinin önemli bir bölümü bunlara zamanlamasız eriştiğinden, sabit olarak kabul edilmesi daha iyi olan dahili nesneleri bütünlüklerini bozarak değiştirir. Dahili nesnelerin hem oku hem de yaz işlevlerinin <code class="code">MT-Unsafe</code> ve <code class="code">AS-Unsafe</code> olarak değerlendirilmesine neden olan <code class="code">race</code> iminden farklı olarak, <code class="code">const</code> yalnızca yaz işlevlerine uygulanır. Yaz işlevleri çağrılmak için eşit derecede <code class="code">MT-Unsafe</code> ve <code class="code">AS-Unsafe</code> olarak kalırlar, ancak nesneler etkin birer sabit olduğunda zamanlama eksikliği sorun yaratmadığından, nesnelerin değiştirildikten sonraki zorunlu sabitliği, oku işlevlerinin <code class="code">MT-Safe</code> ve <code class="code">AS-Safe</code> olarak kabul edilmesini sağlar (güvenli olmamaları için başka bir neden kalmadığı sürece).
       </p>
                <p>
        Oku işlevlerinde <code class="code">const:</code><em class="replaceable"><code>tanıtıcı</code></em>,  kendiliğinden bir güvenilirlik imi olarak görünecektir. Yaz işlevlerini çağırmak için bu güvenlik sorununa geçici bir çözüm bulmak isteyen yazılımlar, <em class="replaceable"><code>tanıtıcı</code></em> ile ilişkili ardışık olmayan bir <code class="code">rwlock</code> kullanabilir ve <code class="code">const:</code><em class="replaceable"><code>tanıtıcı</code></em> ile imlenmiş işlevlere yapılan tüm çağrıları yazma kilidiyle ve yalnızca <em class="replaceable"><code>tanıtıcı</code></em> ile imlenmiş işlevlere yapılan tüm çağrıları da bir okuma kilidiyle koruyabilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">sig</code>
                </span>
                <span id="glibc-safety-sig" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> (ve kısa olması için çıkarılan, örtük olarak uygulanan özdeşi olan <code class="code">AS-Safe</code>) özellik olarak <code class="code">sig</code> ile imlenmiş işlevler, iki nokta üst üste iminden sonra tanımlanan sinyalin diğer kullanımları ile etkileşebilen bir sinyal işleyiciyi dahili amaçlarla geçici olarak kurabilir.
       </p>
                <p>
        Bu güvenilirlik sorunu, çağrı süresince sinyalin başka hiçbir şekilde kullanılmaması sağlanarak çözülebilir. Aynı geçici sinyali kullanan tüm işlevleri çağırırken ardışık olmayan bir muteks tutulması; çağrıdan önce bu sinyalin engellenmesi ve daha sonra işleyicisinin sıfırlanması önerilir.
       </p>
                <p>
        Önalanda iptal durumunda özgün sinyal işleyicinin geri yükleneceğini garanti etmenin güvenli bir yolu yoktur, bu nedenle bu şekilde imlenmiş işlevler ayrıca <code class="code">AC-Unsafe</code>'tir.
       </p>
                <p>
        İptal sorununu önlemek ve <code class="code">MT-Safe</code>/<code class="code">AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <em class="emphasis">ve</em> sinyali istenen duruma geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">term</code>
                </span>
                <span id="glibc-safety-term" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code>  özellik olarak <code class="code">term</code> ile imlenmiş işlevler, uçbirim ayarlarını önerilen şekilde değiştirebilir, yani: <strong class="function"><code>tcgetattr</code></strong> çağrısı yapar, bazı bayrakları değiştir ve ardından <strong class="function"><code>tcsetattr</code></strong> çağrısı yapar; Bu, diğer evreler tarafından yapılan değişikliklerin kaybolduğu bir pencere oluşturur. Bu nedenle, <code class="code">term</code> ile imlenen işlevler <code class="code">MT-Unsafe</code>'tir. Aynı pencere, önalan sinyallerinin kaybolması ile yapılan değişikliklerin etkin olmasını sağlar. Bu işlevler aynı zamanda <code class="code">AC-Unsafe</code>'tir, ancak ilgili im gereksiz olduğundan belirtilmez.
       </p>
                <p>
        Bu nedenle, uçbirimi kullanan uygulamaların uçbirimi sinyal işleyicilerde kullanmayarak veya onu kullanabilecek sinyalleri engelleyerek ve bu işlevleri çağırırken ve uçbirimle etkileşimde bulunurken bir kilit tutarak uç birim ile eşzamanlı ve çok evreli etkileşimlerden kaçınması önerilir. Bu kilit aynı zamanda <code class="code">race:tcattr(dt)</code> ile imlenmiş işlevlerle karşılıklı dışlama için kullanılmalıdır; burada <strong class="varname"><code>dt</code></strong>, denetim uçbiriminin dosya tanıtıcısıdır. Çağrıcı, basitlik için tek bir muteks kullanabilir veya farklı dosya tanıtıcıları tarafından atıf yapılsa bile uçbirim başına bir muteks kullanabilir.
       </p>
                <p>
        <code class="code">AC-Safe</code> özellik olarak <code class="code">term</code> ile imlenmiş işlevlerin, geçici değişiklikler sonrası uçbirimi özgün durumuna geri getiren ancak iptal edilmeleri durumunda bunu yapmakta başarısız olabilen işlevler olduğu varsayılır.
       </p>
                <p>
        İptal sorununu önlemek ve <code class="code">MT-Safe</code>/<code class="code">AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <em class="emphasis">ve</em> uçbirimi özgün durumuna geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </p>
              </dd>
            </dl>
          </div>
        </section>
        <section class="sect2" id="glibc-Other-Safety-Remarks">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">1.3.2.4. Güvenilirlikle ilgili Diğer Açıklamalar</h3>
              </div>
            </div>
          </div>
          <span id="glibc-cp-othersafe" class="indexterm"></span>
          <p>
     İşlevlere, işlev çağrısını güvensiz hale getirmeyen, ancak belirli yazılım sınıflarında dikkate alınması gerekebilecek özellikleri belirten ek anahtar sözcükler eklenebilir:
    </p>
          <div class="glosslist">
            <dl>
              <dt>
                <span class="glossterm">
                  <code class="code">locale</code>
                </span>
                <span id="glibc-safety-locale" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">locale</code> ile imlenmiş işlevler, herhangi bir eşzamanlama biçimi olmaksızın yerele özgü nesnelerden okuma yapar. Yerele özgü değişikliklerle eşzamanlı çağrılan <code class="code">locale</code> imli işlevler, yürütülmeleri sırasında etkin olan yerellerden hiçbirine karşılık gelmeyen, ancak bunların öngörülemeyen bir karışımı olan biçimlerde davranabilir.
       </p>
                <p>
        Ancak, yerele özgü nesneyi değiştiren işlevler <code class="code">const:locale</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan yerel (locale), bu bağlamlarda etkili şekilde sabit (<code class="code">const</code>) kabul edilebilir, bu da <code class="code">const:locale</code> imli işlevleri güvenilir kılar.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">env</code>
                </span>
                <span id="glibc-safety-env" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">env</code> ile imlenmiş işlevler, eşzamanlı değişikliklerin varlığında güvenilirliği sağlamak için herhangi bir koruma olmadan ortama <strong class="function"><code>getenv</code></strong> veya benzeri bir işlev ile erişir.
       </p>
                <p>
        Ancak, ortamı değiştiren işlevler <code class="code">const:env</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan ortam (env), bu bağlamlarda etkili şekilde sabit (<code class="code">const</code>) kabul edilebilir, bu da <code class="code">const:env</code> imli işlevleri güvenilir kılar.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">hostid</code>
                </span>
                <span id="glibc-safety-hostid" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">hostid</code> ile imlenmiş işlevler, makinenin "konak kimliğini" saklandığı sistem genelindeki veri yapılarından okur. Bu veri yapıları genellikle atomik olarak (bütünlüğü bozulacak şekilde) değiştirilemez. "Konak kimliğinin" normal olarak değişmeyeceği beklendiğinden, okuyan işlev (<strong class="function"><code>gethostid</code></strong>) güvenilir olarak kabul edilirken, değiştiren işlev (<strong class="function"><code>sethostid</code></strong>) çağrıldığında değişikliğin yalnızca süreç içinde değil sistem genelinde ele alınmasının gerekebileceğini belirtmek için <code class="code">const:hostid</code> ile imlenir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">sigintr</code>
                </span>
                <span id="glibc-safety-sigintr" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">sigintr</code> ile imlenmiş işlevler, eşzamanlı değişikliklerin varlığında güvenilirliği sağlamak için <strong class="structname"><code>_sigintr</code></strong> dahili veri yapısına herhangi bir koruma olmaksızın erişir.
       </p>
                <p>
        Ancak, bu veri yapısını değiştiren işlevler <code class="code">const:sigintr</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan veri yapısı, bu bağlamlarda etkili şekilde sabit (<code class="code">const</code>) kabul edilebilir, bu da <code class="code">const:sigintr</code> imli işlevleri güvenilir kılar.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">fd</code>
                </span>
                <span id="glibc-safety-fd" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AC-Safe</code> özellik olarak <code class="code">fd</code> ile imlenmiş işlevler, önalanda evre iptali yürütülmelerini kesintiye uğratırsa dosya tanıtıcılarında kaçak olabilir.
       </p>
                <p>
        Dosya tanıtıcıları ayıran ve serbest bırakan işlevler genelde böyle imlenir. Dosya tanıtıcı tahsisi ve yeniden tahsis işlemleri, temizlik işlevleri ile korunmaya çalışılsa bile, yeni bir tanıtıcı tahisis ve numarasını temizlik işlevlerinin serbest bırakabileceği bir yerde saklamak, tek bir bölünmez işlem olarak gerçekleştirilemez. Benzer şekilde tanıtıcının serbest bırakılması ve normalde serbest bırakılmasından sorumlu olan veri yapısından çıkarılması da tek bir bölünmez işlem olarak gerçekleştirilemez. Henüz temizleme işleyici bağımsız değişkeninde saklanmadığı veya serbest bırakılmadan önce zaten çıkarıldığı için tanıtıcının serbest bırakılamadığı bir pencere her zaman olacaktır. Tanıtıcı serbest bırakıldıktan sonra çıkarılamaz: Açık bir tanıtıcı, tanıtıcının hala kapatılması gerektiği veya zaten kapalı olduğu ancak tanıtıcının başka bir evre veya sinyal işleyici tarafından yeniden tahsis edildiği anlamına da gelebilir.
       </p>
                <p>
        Bu tür kaçaklar, önalanda evre iptalini geçici olarak devre dışı bırakarak, bir miktar başarım düşüşüyle dahili olarak önlenebilir. Bununla birlikte, tahsis veya yeniden tahsis işlev çağrılarının yapıldığı katmanda aynı türden bir kaçağı önlemek için bunun çağrıcı tarafından yapılması gerekeceğinden, üst katmanlarda sorun çözüldüğünde gereksiz, çözülmediğinde yetersiz bir başarım cezası vermektense sorunla kütüphanenin ilgilendiğinin varsayılması daha mantıklıdır.
       </p>
                <p>
        Bu açıklama tek başına bir işlevin <code class="code">AC-Unsafe</code> olarak değerlendirilmesine neden olmaz. Ancak bu tür kaçakların birikerek artan etkileri bazı uygulamalar için sorun teşkil edebilir. Bu durumda, bu tür işlevlere yapılan çağrıların yürütülmesi sırasında önalanda iptalin askıya alınması önerilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">mem</code>
                </span>
                <span id="glibc-safety-mem" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">AC-Safe</code> özellik olarak <code class="code">mem</code> ile imlenmiş işlevler,  önalanda evre iptali yürütülmelerini kesintiye uğratırsa bellek kaçağı oluşabilir.
       </p>
                <p>
        Bu sorun, dosya tanıtıcıların sorunlarıyla benzerlik gösterir: Bu işlevlerin yapmadığı önalanda iptali en azından geçici olarak devre dışı bırakmadan, belleği tahsis edip adresini bağımsız bir değişken üzerinden bir temizleme işleyicisinde saklama veya belleği serbest bırakıp adresini bu bağımsız değişkenden kaldırma işlemini tek bir bölünmez işlem halinde yerine getirebilecek herhangi bir arayüz yoktur.
       </p>
                <p>
        Bu açıklama tek başına bir işlevin <code class="code">AC-Unsafe</code> olarak değerlendirilmesine neden olmaz. Ancak bu tür kaçakların birikerek artan etkileri bazı uygulamalar için sorun teşkil edebilir. Bu durumda, bu tür işlevlere yapılan çağrıların yürütülmesi sırasında önalanda iptalin askıya alınması gerekebilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">cwd</code>
                </span>
                <span id="glibc-safety-cwd" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        <code class="code">MT-Safe</code> özellik olarak <code class="code">cwd</code> ile imlenmiş işlevler, yürütülürken geçerli çalışma dizinini geçici olarak değiştirebilir, bu da göreli yolların diğer evrelerde veya önalanda sinyal veya iptal işleyicileri içinde beklenmedik şekillerde çözümlenmesine neden olabilir.
       </p>
                <p>
        Bu açıklama tek başına <code class="code">cwd</code> imli işlevlerin <code class="code">MT-Unsafe</code> veya <code class="code">AS-Unsafe</code> olarak imlenmesi için yeterli neden değildir, ancak bu davranış seçimlik olduğunda (örneğin, <code class="code">FTW_CHDIR</code> özellikli <strong class="function"><code>nftw</code></strong> çağrılarında), tam dosya yollarını kullanmak veya (<strong class="function"><code>openat</code></strong> gibi) göreli dosya tanıtıcılı sistem çağrıları yapmaktansa bu seçenekten kaçınılması daha iyi olabilir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">!posix</code>
                </span>
                <span id="glibc-safety-posix" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        Bu im, işlevin güvenilirlik durmunun POSIX standardında belirtilenden farklı olduğunun bilindiğini belirtmek üzere, işleve <code class="code">MT-Safe</code>, <code class="code">AS-Safe</code> veya <code class="code">AC-Safe</code> özellik atfedebilir. Örneğin POSIX, bir işlevin güvenilir olmasını gerektirmezken bizim gerçeklenimimiz güvenilirdir veya bunun tam tersidir.
       </p>
                <p>
        Şimdilik, bu imin olmaması, belgelediğimiz güvenilirlik özelliklerinin ilgili işlevler için POSIX tarafından zorunlu kılınanlarla aynı olduğu anlamına gelmez.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">:</code>
                  <em class="replaceable">
                    <code>belirteç</code>
                  </em>
                </span>
                <span id="glibc-safety-identifier" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        Örneğin, veri yapılarına güvensiz yollarla erişen birkaç işlevi gruplamak için tasarlanmış <code class="code">race</code> ve <code class="code">const</code> imlemelerinde olduğu gibi veya <code class="code">sig</code> ile imlenmiş bir işlevde bir sinyal adının belirtilmesi gibi daha duruma özgü bilgiler sağlamak için imlemeler bazen <em class="replaceable"><code>im:belirteç</code></em> biçiminde belirteçleriyle birlikte belirtilebilir. Bunun gelecekte <code class="code">lock</code> ve <code class="code">corrupt</code> için de uygulanabileceği öngörülmektedir.
       </p>
                <p>
        Çoğu durumda, belirteç bir işlevi kümesinin adı olacaktır, ancak genel nesnelerin veya işlev bağımsız değişkenlerinin ya da tanımlanabilir özelliklerin adları olabileceği gibi bunlarla ilişkili mantıksal bileşenlerin, örneğin <strong class="varname"><code>var</code></strong> bağımsız değişkeniyle ilişkili bir tamponu belirtmek için <code class="code">:tampon(var)</code> veya <strong class="varname"><code>dt</code></strong> dosya tanıtıcılı bir uçbirimin özniteliklerini belirtmek için <code class="code">:tcnitelik(dt)</code> gibi bir gösterimi olabilir.
       </p>
                <p>
        Belirteçlerin en yaygın kullanımı, belirli bir bağlamda güvenilir yürütmeyi sağlamak için aynı artalan ilkeli tarafından korunması gereken mantıksal işlev ve bağımsız değişken gruplarını belirlemektir.
       </p>
              </dd>
              <dt>
                <span class="glossterm">
                  <code class="code">/</code>
                  <em class="replaceable">
                    <code>koşul</code>
                  </em>
                </span>
                <span id="glibc-safety-condition" class="indexterm"></span>
              </dt>
              <dd class="glossdef">
                <p>
        Bazı güvenilirlik imlemeleri koşula bağlı olabilir, örneğin yalnızca bağımsız değişkenleri, genel değişkenleri ve hatta sistemdeki çekirdeği içeren mantıksal bir ifadenin doğru olarak değerlendirildiği durumda uygulanabiliyor olabilir. <code class="code">/hurd</code> veya <code class="code">/!linux!bsd</code> gibi koşullar, yalnızca sistem çekirdeği HURD olduğunda veya sırasıyla ne Linux ne de BSD çekirdeği olduğunda önlerindeki imin geçerli olduğunu gösterir. <code class="code">/!ps</code> ve <code class="code">/one_per_line</code>,  yalnızca <strong class="varname"><code>ps</code></strong> bağımsız değişkeni NULL olduğunda veya <strong class="varname"><code>one_per_line</code></strong> küresel değişkeni sıfır olmadığında önlerindeki imin geçerli olduğunu belirtir.
       </p>
                <p>
        Bir işlevi güvensiz kılan tüm imlemeler bu tür koşullarla donandığında ve belirtilen koşullardan hiçbiri sağlanmadığında, işlev güvenli olarak kabul edilebilir.
       </p>
              </dd>
            </dl>
          </div>
        </section>
      </section>
    </section>
  </body>
</html>
